{"id": "CONTRIBUTING.md#0", "content": "# Contributing\n\nThis book is developed using [GitBook](https://github.com/GitbookIO/gitbook). Authored in Markdown files (I use [atom](http://atom.io)).\n\nHere's how to setup a Dev Environment:\n\n```\nnpm install gitbook-cli -g\ngitbook install\ngitbook serve .\n```\n> Note: serve needs port `35729` (for live reload) and `4000` for serving http://localhost:4000.\n\nAlso you can mostly just edit the `.md` files in [`/docs`](https://github.com/basarat/typescript-book/docs) using github and create a Pull Request (PR).\n\n# Code\nAll the code for the book is in the `/code` folder. Tested with `atom-typescript`.\n\n### More Gitbook Tips\n* Links best work if they are relative (e.g. `./foo.md`) to the *current* file.\n* For links in the same file (`#foo-bar` style links) best to click the heading on github to get what gitbook expects."}
{"id": "CONTRIBUTING.md#1", "content": "### TypeScript Compiler Docs\nThanks to the TypeScript team for providing much of the docs: https://github.com/Microsoft/TypeScript/wiki/Architectural-Overview that are used to write the compiler story."}
{"id": "footer.md#0", "content": "[![fork me](/images/github.png) Fork me on github](https://github.com/basarat/typescript-book/)"}
{"id": "GLOSSARY.md#0", "content": "# Duck Typing\nIf it walks like a duck and quacks like a duck, it is a duck. For TypeScript if it has all the members structurally then it is okay for other things (irrespecitive of name) that accept that structure.\n\n# OE\nOperating Environment. I'd like to use the term Operating System, but that is not necessarily what I mean here. Think Browser,Node.js,WScriptHost etc.\n\n# Incremental Parsing\nRe-Parsing as the user edits the code."}
{"id": "LICENSE.md#0", "content": "Creative Commons \n\nhttps://creativecommons.org/licenses/by/4.0/"}
{"id": "README.md#0", "content": "[![YouTube Channel Subscribers](https://img.shields.io/youtube/channel/subscribers/UCGD_0i6L48hucTiiyhb5QzQ?style=social)](https://www.youtube.com/@basarat)\n\nTypeScript Deep Dive\n=======\n\nLearn Professional TypeScript. I've been looking at the issues that turn up commonly when people start using TypeScript. This is based on the lessons from [Stack Overflow](http://stackoverflow.com/tags/typescript/topusers) / [DefinitelyTyped](https://github.com/DefinitelyTyped/) and general engagement with the [TypeScript community](https://github.com/TypeStrong/). You can [follow for updates](https://twitter.com/basarat) and [don't forget to \u2605 on GitHub](https://github.com/basarat/typescript-book) \ud83c\udf39\n\n## Reviews"}
{"id": "README.md#1", "content": "* Thanks for the wonderful book. Learned a lot from it. ([link](https://www.gitbook.com/book/basarat/typescript/discussions/21#comment-1468279131934))\n* Its probably the Best TypeScript book out there. Good Job ([link](https://twitter.com/thelondonjs/status/756419561570852864))\n* Love how precise and clear the examples and explanations are! ([link](https://twitter.com/joe_mighty/status/758290957280346112))\n* For the low, low price of free, you get pages of pure awesomeness. Chock full of source code examples and clear, concise explanations, TypeScript Deep Dive will help you learn TypeScript development. ([link](https://www.nativescript.org/blog/details/free-book-typescript-deep-dive))\n* Just a big thank you! **Best TypeScript 2 detailed explanation!** ([link](https://www.gitbook.com/book/basarat/typescript/discussions/38))\n* This gitbook got my project going pronto. Fluent easy read 5 stars. ([link](https://twitter.com/thebabellion/status/779888195559235584))\n* I recommend the online #typescript book by @basarat you'll love it.([link](https://twitter.com/markpieszak/status/788099306590969860))\n* I've always found this by @basarat really helpful. ([link](https://twitter.com/Brocco/status/789887640656945152))\n* We must highlight TypeScript Deep Dive, an open source book.([link](https://www.siliconrepublic.com/enterprise/typescript-programming-javascript))\n* Great online resource for learning. ([link](https://twitter.com/rdfuhr/status/790193307708076035))\n* Thank you for putting this book together, and for all your hard work within the TypeScript community. ([link](https://github.com/basarat/typescript-book/pull/183#issuecomment-257799713))\n* TypeScript Deep Dive is one of the best technical texts I've read in a while. ([link](https://twitter.com/borekb/status/794287092272599040))\n* Thanks @basarat for the TypeScript Deep Dive Book. Help me a lot with my first TypeScript project. ([link](https://twitter.com/betolinck/status/797901548562960384))\n* Thanks to @basarat for this great #typescript learning resource. ([link](https://twitter.com/markuse1501/status/799116176815230976))\n* Guyz excellent book on Typescript(@typescriptlang) by @basarat ([link](https://twitter.com/deeinlove/status/813245965507260417))\n* Leaning on the legendary @basarat's \"TypeScript Deep Dive\" book heavily at the moment ([link](https://twitter.com/sitapati/status/814379404956532737))\n* numTimesPointedPeopleToBasaratsTypeScriptBook++; ([link](https://twitter.com/brocco/status/814227741696462848))\n* A book not only for typescript, a good one for deeper JavaScript knowledge as well. [link](https://www.gitbook.com/book/basarat/typescript/discussions/59)\n* In my new job, we're using @typescriptlang, which I am new to. This is insanely helpful huge thanks, @basarat! [link](https://twitter.com/netchkin/status/855339390566096896)\n* Thank you for writing TypeScript Deep Dive. I have learned so much. [link](https://twitter.com/buctwbzs/status/857198618704355328?refsrc=email&s=11)\n* Loving @basarat's @typescriptlang online book basarat.gitbooks.io/typescript/# loaded with great recipes! [link](https://twitter.com/ericliprandi/status/857608837309677568)\n* Microsoft doc is great already, but if want to \"dig deeper\" into TypeScript I find this book of great value  [link](https://twitter.com/caludio/status/876729910550831104)\n* Thanks, this is a great book \ud83e\udd13\ud83e\udd13 [link](https://twitter.com/jjwonmin/status/885666375548547073)\n* Deep dive to typescript is awesome in so many levels. i find it very insightful. Thanks [link](https://twitter.com/orenmizr/status/891083492787970053)\n* @basarat's intro to @typescriptlang is still one of the best going (if not THE best) [link](https://twitter.com/stevealee/status/953953255968698368)\n* \n* This is sweet! So many #typescript goodies! [link](https://twitter.com/pauliescanlon/status/989898852474998784)"}
{"id": "README.md#2", "content": "## Get Started\nIf you are here to read the book online [get started](https://basarat.gitbook.io/typescript/getting-started)."}
{"id": "README.md#3", "content": "## Translations \nBook is completely free so you can copy paste whatever you want without requiring permission. If you have a translation you want me to link here. [Send a PR](https://github.com/basarat/typescript-book/edit/master/README.md).\n* [Filipino](https://github.com/themarshann/typescript-book-fil)\n* [Italian](https://github.com/TizioFittizio/typescript-book)\n* [Chinese](https://github.com/jkchao/typescript-book-chinese)\n* [Russian](https://github.com/etroynov/typescript-book)\n* [Portuguese](https://github.com/overlineink/typescript-book)\n* [Japanese](https://github.com/yohamta/typescript-book)\n* [Spanish](https://github.com/melissarofman/typescript-book)\n* [Korean](https://github.com/radlohead/typescript-book)\n* [French](https://github.com/HachemiH/typescript-book)\n* [Polish](https://github.com/mbiesiad/typescript-book/tree/pl_PL)\n* [Thai](https://github.com/futurouz/typescript-book)\n* [Bengali](https://github.com/Acesif/typescript-book)\n* [Ukrainian](https://github.com/ArtfulBits/typescript-book)"}
{"id": "README.md#4", "content": "## Other Options\nYou can also download one of the Epub, Mobi, or PDF formats from the [actions tab](https://github.com/basarat/typescript-book/actions) by clicking on the latest build run. You will find the files in the artifacts section.\n\n## Special Thanks\nAll the amazing [contributors](https://github.com/basarat/typescript-book/graphs/contributors) \ud83c\udf39\n\n## Share\nShare URL: https://basarat.gitbook.io/typescript/"}
{"id": "SUMMARY.md#0", "content": "# Summary"}
{"id": "SUMMARY.md#1", "content": "* [Getting Started](docs/getting-started.md)\n  * [Why TypeScript](docs/why-typescript.md)\n* [JavaScript](docs/javascript/recap.md)\n  * [Equality](docs/javascript/equality.md)\n  * [References](docs/javascript/references.md)\n  * [Null vs. Undefined](docs/javascript/null-undefined.md)\n  * [this](docs/javascript/this.md)\n  * [Closure](docs/javascript/closure.md)\n  * [Number](docs/javascript/number.md)\n  * [Truthy](docs/javascript/truthy.md)\n* [Future JavaScript Now](docs/future-javascript.md)\n  * [Classes](docs/classes.md)\n    * [Classes Emit](docs/classes-emit.md)\n  * [Arrow Functions](docs/arrow-functions.md)\n  * [Rest Parameters](docs/rest-parameters.md)\n  * [let](docs/let.md)\n  * [const](docs/const.md)\n  * [Destructuring](docs/destructuring.md)\n  * [Spread Operator](docs/spread-operator.md)\n  * [for...of](docs/for...of.md)\n  * [Iterators](docs/iterators.md)\n  * [Template Strings](docs/template-strings.md)\n  * [Promise](docs/promise.md)\n  * [Generators](docs/generators.md)\n  * [Async Await](docs/async-await.md)\n* [Project](docs/project/project.md)\n  * [Compilation Context](docs/project/compilation-context.md)\n    * [tsconfig.json](docs/project/tsconfig.md)\n    * [Which Files?](docs/project/files.md)\n  * [Declaration Spaces](docs/project/declarationspaces.md)\n  * [Modules](docs/project/modules.md)\n    * [File Module Details](docs/project/external-modules.md)\n    * [global.d.ts](docs/project/globals.md)\n  * [Namespaces](docs/project/namespaces.md)\n  * [Dynamic Import Expressions](docs/project/dynamic-import-expressions.md)\n* [Node.js QuickStart](docs/quick/nodejs.md)\n* [Browser QuickStart](docs/quick/browser.md)\n* [Library QuickStart](docs/quick/library.md)\n* [TypeScript's Type System](docs/types/type-system.md)\n  * [JS Migration Guide](docs/types/migrating.md)\n  * [@types](docs/types/@types.md)\n  * [Ambient Declarations](docs/types/ambient/intro.md)\n    * [Declaration Files](docs/types/ambient/d.ts.md)\n    * [Variables](docs/types/ambient/variables.md)\n  * [Interfaces](docs/types/interfaces.md)\n  * [Enums](docs/enums.md)\n  * [`lib.d.ts`](docs/types/lib.d.ts.md)\n  * [Functions](docs/types/functions.md)\n  * [Callable](docs/types/callable.md)\n  * [Type Assertion](docs/types/type-assertion.md)\n  * [Freshness](docs/types/freshness.md)\n  * [Type Guard](docs/types/typeGuard.md)\n  * [Literal Types](docs/types/literal-types.md)\n  * [Readonly](docs/types/readonly.md)\n  * [Generics](docs/types/generics.md)\n  * [Type Inference](docs/types/type-inference.md)\n  * [Type Compatibility](docs/types/type-compatibility.md)\n  * [Never Type](docs/types/never.md)\n  * [Discriminated Unions](docs/types/discriminated-unions.md)\n  * [Index Signatures](docs/types/index-signatures.md)\n  * [Moving Types](docs/types/moving-types.md)\n  * [Exception Handling](docs/types/exceptions.md)\n  * [Mixins](docs/types/mixins.md)\n* [JSX](docs/jsx/tsx.md)\n  * [React](docs/jsx/react.md)\n  * [Non React JSX](docs/jsx/others.md)\n* [Options](docs/options/intro.md)\n  * [noImplicitAny](docs/options/noImplicitAny.md)\n  * [strictNullChecks](docs/options/strictNullChecks.md)\n* [Errors in TypeScript](docs/errors/main.md)\n  * [Interpreting Errors](docs/errors/interpreting-errors.md)\n  * [Common Errors](docs/errors/common-errors.md)\n* [NPM](docs/npm/index.md)\n* [Testing](docs/testing/intro.md)\n  * [Jest](docs/testing/jest.md)\n  * [Cypress](docs/testing/cypress.md)\n* [Tools](docs/tools/intro.md)\n  * [Prettier](docs/tools/prettier.md)\n  * [Husky](docs/tools/husky.md)\n  * [ESLint](docs/tools/eslint.md)\n  * [Changelog](docs/tools/changelog.md)\n* [TIPs](docs/tips/main.md)\n  * [String Based Enums](docs/tips/stringEnums.md)\n  * [Nominal Typing](docs/tips/nominalTyping.md)\n  * [Stateful Functions](docs/tips/statefulFunctions.md)\n  * [Currying](docs/tips/currying.md)\n  * [Type Instantiation](docs/tips/typeInstantiation.md)\n  * [Lazy Object Literal Initialization](docs/tips/lazyObjectLiteralInitialization.md)\n  * [Classes are Useful](docs/tips/classesAreUseful.md)\n  * [Avoid Export Default](docs/tips/defaultIsBad.md)\n  * [Limit Property Setters](docs/tips/propertySetters.md)\n  * [`outFile` caution](docs/tips/outFile.md)\n  * [JQuery tips](docs/tips/jquery.md)\n  * [static constructors](docs/tips/staticConstructor.md)\n  * [singleton pattern](docs/tips/singleton.md)\n  * [Function parameters](docs/tips/functionParameters.md)\n  * [Build Toggles](docs/tips/build-toggles.md)\n  * [Barrel](docs/tips/barrel.md)\n  * [Create Arrays](docs/tips/create-arrays.md)\n  * [Typesafe Event Emitter](docs/tips/typed-event.md)\n* [StyleGuide](docs/styleguide/styleguide.md)\n* [TypeScript Compiler Internals](docs/compiler/overview.md)\n  * [Program](docs/compiler/program.md)\n  * [AST](docs/compiler/ast.md)\n    * [TIP: Visit Children](docs/compiler/ast-tip-children.md)\n    * [TIP: SyntaxKind enum](docs/compiler/ast-tip-syntaxkind.md)\n    * [Trivia](docs/compiler/ast-trivia.md)\n  * [Scanner](docs/compiler/scanner.md)\n  * [Parser](docs/compiler/parser.md)\n    * [Parser Functions](docs/compiler/parser-functions.md)\n  * [Binder](docs/compiler/binder.md)\n    * [Binder Functions](docs/compiler/binder-functions.md)\n    * [Binder Declarations](docs/compiler/binder-declarations.md)\n    * [Binder Container](docs/compiler/binder-container.md)\n    * [Binder SymbolTable](docs/compiler/binder-symboltable.md)\n    * [Binder Error Reporting](docs/compiler/binder-diagnostics.md)\n  * [Checker](docs/compiler/checker.md)\n    * [Checker Diagnostics](docs/compiler/checker-global.md)\n    * [Checker Error Reporting](docs/compiler/checker-diagnostics.md)\n  * [Emitter](docs/compiler/emitter.md)\n    * [Emitter Functions](docs/compiler/emitter-functions.md)\n    * [Emitter SourceMaps](docs/compiler/emitter-sourcemaps.md)\n  * [Contributing](docs/compiler/contributing.md)"}
{"id": "code\\compiler\\node_modules\\ntypescript\\CONTRIBUTING.md#0", "content": "# Release\n\n## Quickly\n\nQuick workflow (runs `prepare` and `release`): \n\n```sh\nquick.sh\n```\n\n## Manually\n\n```sh\nprepare.sh\n```\n\nManual verification here ... then:\n\n```sh\nrelease.sh\nnpm publish\n```\n\n## globals\n\nYou can try the globals using:\n\n```\nnpm link\n```\n\n# Inspiration \nhttps://github.com/Arnavion/typescript-github\n\n# Travis\nCron job setup using : http://traviscron.pythonanywhere.com/ for daily"}
{"id": "code\\compiler\\node_modules\\ntypescript\\README.md#0", "content": "# NTypeScript\n\n[![BuildStatus](https://travis-ci.org/TypeStrong/ntypescript.svg)](https://travis-ci.org/TypeStrong/ntypescript)\n\nNightly build snapshots of [Microsoft/TypeScript](https://github.com/Microsoft/TypeScript).\n\nNiceties:\n\n* Consistent side by side usage (just add an `n` prefix): `require('ntypescript')`, `ntsc`, `ntsserver`\n* `package.json` links you to typescript definitions (using `typescript.definition` entry)\n* We expose the internal APIs (the ones that have `/* internal */`)\n* We expose the global `ts` variable. Just `require('ntypescript')` once and start using `ts` like you are in the actual compiler source code.\n* More frequent releases\n\n## Install\nSimilar to `typescript` you can install and use `ntypescript` globally:\n\n``` sh\nnpm install ntypescript -g\n```\n\nor in your package.json\n\n```sh\nnpm install ntypescript@latest --save --save-exact\n```"}
{"id": "code\\compiler\\node_modules\\ntypescript\\README.md#1", "content": "Each release is named after the day it was built and the git commit hash in Microsoft/TypeScript/master that it was built from. We recommend adding `save-exact` as there are no guarantees on when stuff might break and you want your users to get the same version you tested.\n\n## Usage\n\n### Globally\nYou can use `ntsc` and the `ntsserver` command line tools.\n\n### Require\nUse `require('ntypescript')`\n\n### Global `ts`\nIn addition to returning what `typescript` returns we also expose `ts` as a global.\n\n```ts\ndeclare var require: any;\nrequire('ntypescript');\nconsole.log(ts.createScanner);\n```\nWhich makes it easy to use the compiler API if you are using it heavily. Note you only need to `require` *once* from any file.\n\n### Replace TypeScript\nFor `require('typescript')` you can do that quite simply using your package.json:"}
{"id": "code\\compiler\\node_modules\\ntypescript\\README.md#2", "content": "```json\n\"dependencies\": {\n    \"typescript\": \"https://github.com/basarat/ntypescript/tarball/<release name>\"\n}\n```\nRelease name example : `1.201506301047.1+e1c9d28cb0706f81c14ca95b92fa3e2a223cc60b`\n\n### Grunt\nThis project comes with a built in `grunt` task called `ntypescript`. Just has just one *task* level option: \n\n* `project` : path to the project directory i.e. the *directory* that contains `tsconfig.json`.\n\nHere is a sample `Gruntfile.js` for usage:\n\n```ts\nmodule.exports = function(grunt) {    \n    grunt.loadNpmTasks('ntypescript');\n    \n    grunt.initConfig({\n        ntypescript: {\n            options: {\n                project: '.'\n            }\n        },\n    });\n\n    grunt.registerTask('default', ['ntypescript']);\n};\n```\n\n# About\nNote that this is a personal endeavor, not officially by Microsoft."}
{"id": "docs\\arrow-functions.md#0", "content": "* [Arrow Functions](#arrow-functions)\n* [Tip: Arrow Function Need](#tip-arrow-function-need)\n* [Tip: Arrow Function Danger](#tip-arrow-function-danger)\n* [Tip: Libraries that use `this`](#tip-arrow-functions-with-libraries-that-use-this)\n* [Tip: Arrow Function inheritance](#tip-arrow-functions-and-inheritance)\n* [Tip: Quick object return](#tip-quick-object-return)\n\n### Arrow Functions\n\nLovingly called the *fat arrow* (because `->` is a thin arrow and `=>` is a fat arrow) and also called a *lambda function* (because of other languages). Another commonly used feature is the fat arrow function `()=>something`. The motivation for a *fat arrow* is:\n\n1. You don't need to keep typing `function`\n1. It lexically captures the meaning of `this`\n1. It lexically captures the meaning of `arguments`"}
{"id": "docs\\arrow-functions.md#1", "content": "For a language that claims to be functional, in JavaScript you tend to be typing `function` quite a lot. The fat arrow makes it simple for you to create a function\n```ts\nvar inc = (x)=>x+1;\n```\n`this` has traditionally been a pain point in JavaScript. As a wise man once said \"I hate JavaScript as it tends to lose the meaning of `this` all too easily\". Fat arrows fix it by capturing the meaning of `this` from the surrounding context. Consider this pure JavaScript class:\n\n```ts\nfunction Person(age) {\n    this.age = age;\n    this.growOld = function() {\n        this.age++;\n    }\n}\nvar person = new Person(1);\nsetTimeout(person.growOld,1000);"}
{"id": "docs\\arrow-functions.md#2", "content": "setTimeout(function() { console.log(person.age); },2000); // 1, should have been 2\n```\nIf you run this code in the browser `this` within the function is going to point to `window` because `window` is going to be what executes the `growOld` function. Fix is to use an arrow function:\n```ts\nfunction Person(age) {\n    this.age = age;\n    this.growOld = () => {\n        this.age++;\n    }\n}\nvar person = new Person(1);\nsetTimeout(person.growOld,1000);\n\nsetTimeout(function() { console.log(person.age); },2000); // 2\n```\nThe reason why this works is the reference to `this` is captured by the arrow function from outside the function body. This is equivalent to the following JavaScript code (which is what you would write yourself if you didn't have TypeScript):\n```ts\nfunction Person(age) {\n    this.age = age;\n    var _this = this;  // capture this\n    this.growOld = function() {\n        _this.age++;   // use the captured this\n    }\n}\nvar person = new Person(1);\nsetTimeout(person.growOld,1000);"}
{"id": "docs\\arrow-functions.md#3", "content": "setTimeout(function() { console.log(person.age); },2000); // 2\n```\nNote that since you are using TypeScript you can be even sweeter in syntax and combine arrows with classes:\n```ts\nclass Person {\n    constructor(public age:number) {}\n    growOld = () => {\n        this.age++;\n    }\n}\nvar person = new Person(1);\nsetTimeout(person.growOld,1000);\n\nsetTimeout(function() { console.log(person.age); },2000); // 2\n```\n\n> [A sweet video about this pattern \ud83c\udf39](https://egghead.io/lessons/typescript-make-usages-of-this-safe-in-class-methods)\n\n#### Tip: Arrow Function Need\nBeyond the terse syntax, you only *need* to use the fat arrow if you are going to give the function to someone else to call. Effectively:\n```ts\nvar growOld = person.growOld;\n// Then later someone else calls it:\ngrowOld();\n```\nIf you are going to call it yourself, i.e.\n```ts\nperson.growOld();\n```\nthen `this` is going to be the correct calling context (in this example `person`).\n\n#### Tip: Arrow Function Danger"}
{"id": "docs\\arrow-functions.md#4", "content": "In fact if you want `this` *to be the calling context* you should *not use the arrow function*. This is the case with callbacks used by libraries like jquery, underscore, mocha and others. If the documentation mentions functions on `this` then you should probably just use a `function` instead of a fat arrow. Similarly if you plan to use `arguments` don't use an arrow function.\n\n#### Tip: Arrow functions with libraries that use `this`\nMany libraries do this e.g. `jQuery` iterables (one example https://api.jquery.com/jquery.each/) will use `this` to pass you the object that it is currently iterating over. In this case if you want to access the library passed `this` as well as the surrounding context just use a temp variable like `_self` like you would in the absence of arrow functions.\n\n```ts\nlet _self = this;\nsomething.each(function() {\n    console.log(_self); // the lexically scoped value\n    console.log(this); // the library passed value\n});\n```"}
{"id": "docs\\arrow-functions.md#5", "content": "#### Tip: Arrow functions and inheritance\nArrow functions as properties on classes work fine with inheritance: \n\n```ts\nclass Adder {\n    constructor(public a: number) {}\n    add = (b: number): number => {\n        return this.a + b;\n    }\n}\nclass Child extends Adder {\n    callAdd(b: number) {\n        return this.add(b);\n    }\n}\n// Demo to show it works\nconst child = new Child(123);\nconsole.log(child.callAdd(123)); // 246\n```\n\nHowever, they do not work with the `super` keyword when you try to override the function in a child class. Properties go on `this`. Since there is only one `this` such functions cannot participate in a call to `super` (`super` only works on prototype members). You can easily get around it by creating a copy of the method before overriding it in the child.\n\n```ts\nclass Adder {\n    constructor(public a: number) {}\n    // This function is now safe to pass around\n    add = (b: number): number => {\n        return this.a + b;\n    }\n}"}
{"id": "docs\\arrow-functions.md#6", "content": "class ExtendedAdder extends Adder {\n    // Create a copy of parent before creating our own\n    private superAdd = this.add;\n    // Now create our override\n    add = (b: number): number => {\n        return this.superAdd(b);\n    }\n}\n```\n\n### Tip: Quick object return\n\nSometimes you need a function that just returns a simple object literal. However, something like\n\n```ts\n// WRONG WAY TO DO IT\nvar foo = () => {\n    bar: 123\n};\n```\nis parsed as a *block* containing a *JavaScript Label* by JavaScript runtimes (cause of the JavaScript specification).\n\n>  If that doesn't make sense, don't worry, as you get a nice compiler error from TypeScript saying \"unused label\" anyways. Labels are an old (and mostly unused) JavaScript feature that you can ignore as a modern GOTO (considered bad by experienced developers \ud83c\udf39)\n\nYou can fix it by surrounding the object literal with `()`:\n\n```ts\n// Correct \ud83c\udf39\nvar foo = () => ({\n    bar: 123\n});\n```"}
{"id": "docs\\async-await.md#0", "content": "## Async Await\n\n> [A PRO egghead video course that covers the same material](https://egghead.io/courses/async-await-using-typescript)\n\nAs a thought experiment imagine the following: a way to tell the JavaScript runtime to pause the executing of code on the `await` keyword when used on a promise and resume *only* once (and if) the promise returned from the function is settled:\n\n```ts\n// Not actual code. A thought experiment\nasync function foo() {\n    try {\n        var val = await getMeAPromise();\n        console.log(val);\n    }\n    catch(err) {\n        console.log('Error: ', err.message);\n    }\n}\n```\n\nWhen the promise settles execution continues,\n* if it was fulfilled then await will return the value,\n* if it's rejected an error will be thrown synchronously which we can catch.\n\nThis suddenly (and magically) makes asynchronous programming as easy as synchronous programming.  Three things needed for this thought experiment are:"}
{"id": "docs\\async-await.md#1", "content": "* Ability to *pause function* execution.\n* Ability to *put a value inside* the function.\n* Ability to *throw an exception inside* the function.\n\nThis is exactly what generators allowed us to do! The thought experiment *is actually real* and so is the `async`/`await` implementation in TypeScript / JavaScript. Under the covers it just uses generators.\n\n### Generated JavaScript\n\nYou don't have to understand this, but it's fairly simple if you've [read up on generators][generators]. The function `foo` can be simply wrapped up as follows:\n\n```ts\nconst foo = wrapToReturnPromise(function* () {\n    try {\n        var val = yield getMeAPromise();\n        console.log(val);\n    }\n    catch(err) {\n        console.log('Error: ', err.message);\n    }\n});\n```"}
{"id": "docs\\async-await.md#2", "content": "where the `wrapToReturnPromise` just executes the generator function to get the `generator` and then use `generator.next()`, if the value is a `promise` it would `then`+`catch` the promise and depending upon the result call `generator.next(result)` or `generator.throw(error)`. That's it!\n\n\n\n### Async Await Support in TypeScript\n**Async - Await** has been supported by [TypeScript since version 1.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-7.html). Asynchronous functions are prefixed with the *async* keyword; *await* suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the *Promise* returned.\nIt was only supported for **target es6** transpiling directly to **ES6 generators**."}
{"id": "docs\\async-await.md#3", "content": "**TypeScript 2.1** [added the capability to ES3 and ES5 run-times](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html), meaning you\u2019ll be free to take advantage of it no matter what environment you\u2019re using. It's important to notice that we can use async / await with TypeScript 2.1 and many browsers are supported, of course, having globally added a **polyfill for Promise**.\n\nLet's see this **example** and take a look at this code to figure out how TypeScript async / await **notation** works: \n```ts\nfunction delay(milliseconds: number, count: number): Promise<number> {\n    return new Promise<number>(resolve => {\n            setTimeout(() => {\n                resolve(count);\n            }, milliseconds);\n        });\n}\n\n// async function always returns a Promise\nasync function dramaticWelcome(): Promise<void> {\n    console.log(\"Hello\");"}
{"id": "docs\\async-await.md#4", "content": "for (let i = 0; i < 5; i++) {\n        // await is converting Promise<number> into number\n        const count: number = await delay(500, i);\n        console.log(count);\n    }\n\n    console.log(\"World!\");\n}\n\ndramaticWelcome();\n```"}
{"id": "docs\\async-await.md#5", "content": "**Transpiling to ES6 (--target es6)**\n```js\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction delay(milliseconds, count) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve(count);\n        }, milliseconds);\n    });\n}\n// async function always returns a Promise\nfunction dramaticWelcome() {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"Hello\");\n        for (let i = 0; i < 5; i++) {\n            // await is converting Promise<number> into number\n            const count = yield delay(500, i);\n            console.log(count);\n        }\n        console.log(\"World!\");\n    });\n}\ndramaticWelcome();\n```\nYou can see full example [here][asyncawaites6code]."}
{"id": "docs\\async-await.md#6", "content": "**Transpiling to ES5 (--target es5)**\n```js\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nfunction delay(milliseconds, count) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(count);\n        }, milliseconds);\n    });\n}\n// async function always returns a Promise\nfunction dramaticWelcome() {\n    return __awaiter(this, void 0, void 0, function () {\n        var i, count;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"Hello\");\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(i < 5)) return [3 /*break*/, 4];\n                    return [4 /*yield*/, delay(500, i)];\n                case 2:\n                    count = _a.sent();\n                    console.log(count);\n                    _a.label = 3;\n                case 3:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 4:\n                    console.log(\"World!\");\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\ndramaticWelcome();\n```\nYou can see full example [here][asyncawaites5code]."}
{"id": "docs\\async-await.md#7", "content": "**Note**: for both target scenarios, we need to make sure our run-time has an ECMAScript-compliant Promise available globally. That might involve grabbing a polyfill for Promise. We also need to make sure that TypeScript knows Promise exists by setting our lib flag to something like \"dom\", \"es2015\" or \"dom\", \"es2015.promise\", \"es5\". \n**We can see what browsers DO have Promise support (native and polyfilled) [here](https://kangax.github.io/compat-table/es6/#test-Promise).**\n\n[generators]:./generators.md\n[asyncawaites5code]:https://cdn.rawgit.com/basarat/typescript-book/705e4496/code/async-await/es5/asyncAwaitES5.js\n[asyncawaites6code]:https://cdn.rawgit.com/basarat/typescript-book/705e4496/code/async-await/es6/asyncAwaitES6.js"}
{"id": "docs\\classes-emit.md#0", "content": "#### What's up with the IIFE\nThe js generated for the class could have been:\n```ts\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\nPoint.prototype.add = function (point) {\n    return new Point(this.x + point.x, this.y + point.y);\n};\n```\n\nThe reason it's wrapped in an Immediately-Invoked Function Expression (IIFE) i.e.\n\n```ts\n(function () {\n\n    // BODY\n\n    return Point;\n})();\n```\n\nhas to do with inheritance. It allows TypeScript to capture the base class as a variable `_super` e.g.\n\n```ts\nvar Point3D = (function (_super) {\n    __extends(Point3D, _super);\n    function Point3D(x, y, z) {\n        _super.call(this, x, y);\n        this.z = z;\n    }\n    Point3D.prototype.add = function (point) {\n        var point2D = _super.prototype.add.call(this, point);\n        return new Point3D(point2D.x, point2D.y, this.z + point.z);\n    };\n    return Point3D;\n})(Point);\n```"}
{"id": "docs\\classes-emit.md#1", "content": "Notice that the IIFE allows TypeScript to easily capture the base class `Point` in a `_super` variable and that is used consistently in the class body.\n\n### `__extends`\nYou will notice that as soon as you inherit a class TypeScript also generates the following function:\n```ts\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\n```\nHere `d` refers to the derived class and `b` refers to the base class. This function does two things:\n\n1. copies the static members of the base class onto the child class i.e. `for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];`\n1. sets up the child class function's prototype to optionally lookup members on the parent's `proto` i.e. effectively `d.prototype.__proto__ = b.prototype`\n\nPeople rarely have trouble understanding 1, but many people struggle with 2. So an explanation is in order."}
{"id": "docs\\classes-emit.md#2", "content": "#### `d.prototype.__proto__ = b.prototype`\n\nAfter having tutored many people about this I find the following explanation to be simplest. First we will explain how the code from `__extends` is equivalent to the simple `d.prototype.__proto__ = b.prototype`, and then why this line in itself is significant. To understand all this you need to know these things:\n\n1. `__proto__`\n1. `prototype`\n1. effect of `new` on `this` inside the called function\n1. effect of `new` on `prototype` and `__proto__`"}
{"id": "docs\\classes-emit.md#3", "content": "All objects in JavaScript contain a `__proto__` member. This member is often not accessible in older browsers (sometimes documentation refers to this magical property as `[[prototype]]`). It has one objective: If a property is not found on an object during lookup (e.g. `obj.property`) then it is looked up at `obj.__proto__.property`. If it is still not found then `obj.__proto__.__proto__.property` till either: *it is found* or *the latest `.__proto__` itself is null*. This explains why JavaScript is said to support *prototypal inheritance* out of the box. This is shown in the following example, which you can run in the chrome console or Node.js:\n\n```ts\nvar foo = {}\n\n// setup on foo as well as foo.__proto__\nfoo.bar = 123;\nfoo.__proto__.bar = 456;\n\nconsole.log(foo.bar); // 123\ndelete foo.bar; // remove from object\nconsole.log(foo.bar); // 456\ndelete foo.__proto__.bar; // remove from foo.__proto__\nconsole.log(foo.bar); // undefined\n```"}
{"id": "docs\\classes-emit.md#4", "content": "Cool so you understand `__proto__`. Another useful fact is that all `function`s in JavaScript have a property called `prototype` and that it has a member `constructor` pointing back to the function. This is shown below:\n\n```ts\nfunction Foo() { }\nconsole.log(Foo.prototype); // {} i.e. it exists and is not undefined\nconsole.log(Foo.prototype.constructor === Foo); // Has a member called `constructor` pointing back to the function\n```\n\nNow let's look at *effect of `new` on `this` inside the called function*. Basically `this` inside the called function is going to point to the newly created object that will be returned from the function. It's simple to see if you mutate a property on `this` inside the function:\n\n```ts\nfunction Foo() {\n    this.bar = 123;\n}\n\n// call with the new operator\nvar newFoo = new Foo();\nconsole.log(newFoo.bar); // 123\n```"}
{"id": "docs\\classes-emit.md#5", "content": "Now the only other thing you need to know is that calling `new` on a function assigns the `prototype` of the function to the `__proto__` of the newly created object that is returned from the function call. Here is the code you can run to completely understand it:\n\n```ts\nfunction Foo() { }\n\nvar foo = new Foo();\n\nconsole.log(foo.__proto__ === Foo.prototype); // True!\n```\n\nThat's it. Now look at the following straight out of `__extends`. I've taken the liberty to number these lines:\n\n```ts\n1  function __() { this.constructor = d; }\n2   __.prototype = b.prototype;\n3   d.prototype = new __();\n```\n\nReading this function in reverse the `d.prototype = new __()` on line 3 effectively means `d.prototype = {__proto__ : __.prototype}` (because of the effect of `new` on `prototype` and `__proto__`), combining it with the previous line (i.e. line 2 `__.prototype = b.prototype;`) you get `d.prototype = {__proto__ : b.prototype}`."}
{"id": "docs\\classes-emit.md#6", "content": "But wait, we wanted `d.prototype.__proto__` i.e. just the proto changed and maintain the old `d.prototype.constructor`. This is where the significance of the first line (i.e. `function __() { this.constructor = d; }`) comes in. Here we will effectively have `d.prototype = {__proto__ : __.prototype, constructor : d}` (because of the effect of `new` on `this` inside the called function). So, since we restore `d.prototype.constructor`, the only thing we have truly mutated is the `__proto__` hence `d.prototype.__proto__ = b.prototype`.\n\n#### `d.prototype.__proto__ = b.prototype` significance\n\nThe significance is that it allows you to add member functions to a child class and inherit others from the base class. This is demonstrated by the following simple example:\n\n```ts\nfunction Animal() { }\nAnimal.prototype.walk = function () { console.log('walk') };\n\nfunction Bird() { }\nBird.prototype.__proto__ = Animal.prototype;\nBird.prototype.fly = function () { console.log('fly') };"}
{"id": "docs\\classes-emit.md#7", "content": "var bird = new Bird();\nbird.walk();\nbird.fly();\n```\nBasically `bird.fly` will be looked up from `bird.__proto__.fly` (remember that `new` makes the `bird.__proto__` point to `Bird.prototype`) and `bird.walk` (an inherited member) will be looked up from `bird.__proto__.__proto__.walk` (as `bird.__proto__ == Bird.prototype` and `bird.__proto__.__proto__` == `Animal.prototype`)."}
{"id": "docs\\classes.md#0", "content": "### Classes\nThe reason why it's important to have classes in JavaScript as a first class item is that:\n\n1. [Classes offer a useful structural abstraction](./tips/classesAreUseful.md)\n1. Provides a consistent way for developers to use classes instead of every framework (emberjs,reactjs etc) coming up with their own version.\n1. Object Oriented Developers already understand classes.\n\nFinally JavaScript developers can *have `class`*. Here we have a basic class called Point:\n```ts\nclass Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n    add(point: Point) {\n        return new Point(this.x + point.x, this.y + point.y);\n    }\n}"}
{"id": "docs\\classes.md#1", "content": "var p1 = new Point(0, 10);\nvar p2 = new Point(10, 20);\nvar p3 = p1.add(p2); // {x:10,y:30}\n```\nThis class generates the following JavaScript on ES5 emit:\n```ts\nvar Point = (function () {\n    function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype.add = function (point) {\n        return new Point(this.x + point.x, this.y + point.y);\n    };\n    return Point;\n})();\n```\nThis is a fairly idiomatic traditional JavaScript class pattern now as a first class language construct.\n\n### Inheritance\nClasses in TypeScript (like other languages) support *single* inheritance using the `extends` keyword as shown below:"}
{"id": "docs\\classes.md#2", "content": "```ts\nclass Point3D extends Point {\n    z: number;\n    constructor(x: number, y: number, z: number) {\n        super(x, y);\n        this.z = z;\n    }\n    add(point: Point3D) {\n        var point2D = super.add(point);\n        return new Point3D(point2D.x, point2D.y, this.z + point.z);\n    }\n}\n```\nIf you have a constructor in your class then you *must* call the parent constructor from your constructor (TypeScript will point this out to you). This ensures that the stuff that it needs to set on `this` gets set. Followed by the call to `super` you can add any additional stuff you want to do in your constructor (here we add another member `z`).\n\nNote that you override parent member functions easily (here we override `add`) and still use the functionality of the super class in your members (using `super.` syntax)."}
{"id": "docs\\classes.md#3", "content": "### Statics\nTypeScript classes support `static` properties that are shared by all instances of the class. A natural place to put (and access) them is on the class itself and that is what TypeScript does:\n\n```ts\nclass Something {\n    static instances = 0;\n    constructor() {\n        Something.instances++;\n    }\n}\n\nvar s1 = new Something();\nvar s2 = new Something();\nconsole.log(Something.instances); // 2\n```\n\nYou can have static members as well as static functions.\n\n### Access Modifiers\nTypeScript supports access modifiers `public`,`private` and `protected` which determine the accessibility of a `class` member as shown below:\n\n| accessible on   | `public` | `protected` | `private` |\n|-----------------|----------|-------------|-----------|\n| class           | yes      | yes         | yes       |\n| class children  | yes      | yes         | no        |\n| class instances | yes      | no          | no        |"}
{"id": "docs\\classes.md#4", "content": "If an access modifier is not specified it is implicitly `public` as that matches the *convenient* nature of JavaScript \ud83c\udf39.\n\nNote that at runtime (in the generated JS) these have no significance but will give you compile time errors if you use them incorrectly. An example of each is shown below:\n\n```ts\nclass FooBase {\n    public x: number;\n    private y: number;\n    protected z: number;\n}\n\n// EFFECT ON INSTANCES\nvar foo = new FooBase();\nfoo.x; // okay\nfoo.y; // ERROR : private\nfoo.z; // ERROR : protected\n\n// EFFECT ON CHILD CLASSES\nclass FooChild extends FooBase {\n    constructor() {\n      super();\n        this.x; // okay\n        this.y; // ERROR: private\n        this.z; // okay\n    }\n}\n```\n\nAs always these modifiers work for both member properties and member functions."}
{"id": "docs\\classes.md#5", "content": "### Abstract\n`abstract` can be thought of as an access modifier. We present it separately because opposed to the previously mentioned modifiers it can be on a `class` as well as any member of the class. Having an `abstract` modifier primarily means that such functionality *cannot be directly invoked* and a child class must provide the functionality.\n\n* `abstract` **classes** cannot be directly instantiated. Instead the user must create some `class` that inherits from the `abstract class`.\n\n```ts\nabstract class FooCommand {}\n\nclass BarCommand extends FooCommand {}\n\nconst fooCommand: FooCommand = new FooCommand(); // Cannot create an instance of an abstract class.\n\nconst barCommand = new BarCommand(); // You can create an instance of a class that inherits from an abstract class.\n```\n\n* `abstract` **members** cannot be directly accessed and a child class must provide the functionality.\n\n```ts\nabstract class FooCommand {\n  abstract execute(): string;\n}"}
{"id": "docs\\classes.md#6", "content": "class BarErrorCommand  extends FooCommand {} // 'BarErrorCommand' needs implement abstract member 'execute'.\n\nclass BarCommand extends FooCommand {\n  execute() {\n    return `Command Bar executed`;\n  }\n}\n\nconst barCommand = new BarCommand();\n\nbarCommand.execute(); // Command Bar executed\n```\n\n### Constructor is optional\n\nThe class does not need to have a constructor. e.g. the following is perfectly fine. \n\n```ts\nclass Foo {}\nvar foo = new Foo();\n```\n\n### Define using constructor\n\nHaving a member in a class and initializing it like below:\n\n```ts\nclass Foo {\n    x: number;\n    constructor(x:number) {\n        this.x = x;\n    }\n}\n```\nis such a common pattern that TypeScript provides a shorthand where you can prefix the member with an *access modifier* and it is automatically declared on the class and copied from the constructor. So the previous example can be re-written as (notice `public x:number`):\n\n```ts\nclass Foo {\n    constructor(public x:number) {\n    }\n}\n```"}
{"id": "docs\\classes.md#7", "content": "### Property initializer\nThis is a nifty feature supported by TypeScript (from ES7 actually). You can initialize any member of the class outside the class constructor, useful to provide default (notice `members = []`)\n\n```ts\nclass Foo {\n    members = [];  // Initialize directly\n    add(x) {\n        this.members.push(x);\n    }\n}\n```"}
{"id": "docs\\compiler-options.md#0", "content": "// mention Pinned comments\n\n```ts\n/*!\n * License\n */\n```"}
{"id": "docs\\const.md#0", "content": "### const\n\n`const` is a very welcomed addition offered by ES6 / TypeScript. It allows you to be immutable with variables. This is good from a documentation as well as a runtime perspective. To use const just replace `var` with `const`:\n\n```ts\nconst foo = 123;\n```\n\n> The syntax is much better (IMHO) than other languages that force the user to type something like `let constant foo` i.e. a variable + behavior specifier.\n\n`const` is a good practice for both readability and maintainability and avoids using *magic literals* e.g.\n\n```ts\n// Low readability\nif (x > 10) {\n}\n\n// Better!\nconst maxRows = 10;\nif (x > maxRows) {\n}\n```\n\n#### const declarations must be initialized\nThe following is a compiler error:\n\n```ts\nconst foo; // ERROR: const declarations must be initialized\n```\n\n#### Left hand side of assignment cannot be a constant\nConstants are immutable after creation, so if you try to assign them to a new value it is a compiler error:"}
{"id": "docs\\const.md#1", "content": "```ts\nconst foo = 123;\nfoo = 456; // ERROR: Left-hand side of an assignment expression cannot be a constant\n```\n\n#### Block Scoped\nA `const` is block scoped like we saw with [`let`](./let.md):\n\n```ts\nconst foo = 123;\nif (true) {\n    const foo = 456; // Allowed as its a new variable limited to this `if` block\n}\n```\n\n#### Deep immutability\nA `const` works with object literals as well, as far as protecting the variable *reference* is concerned:\n\n```ts\nconst foo = { bar: 123 };\nfoo = { bar: 456 }; // ERROR : Left hand side of an assignment expression cannot be a constant\n```\n\nHowever, it still allows sub properties of objects to be mutated, as shown below:\n\n```ts\nconst foo = { bar: 123 };\nfoo.bar = 456; // Allowed!\nconsole.log(foo); // { bar: 456 }\n```\n\n#### Prefer const\n\nAlways use `const`, unless you plan to either lazily initialization of a variable, or do a reassignment (use `let` for those cases)."}
{"id": "docs\\declaration.md#0", "content": "analogy with c headers"}
{"id": "docs\\destructuring.md#0", "content": "### Destructuring\n\nTypeScript supports the following forms of Destructuring (literally named after de-structuring i.e. breaking up the structure):\n\n1. Object Destructuring\n1. Array Destructuring\n\nIt is easy to think of destructuring as an inverse of *structuring*. The method of *structuring* in JavaScript is the object literal:\n\n```ts\nvar foo = {\n    bar: {\n        bas: 123\n    }\n};\n```\nWithout the awesome *structuring* support built into JavaScript, creating new objects on the fly would indeed be very cumbersome. Destructuring brings the same level of convenience to getting data out of a structure.\n\n#### Object Destructuring\nDestructuring is useful because it allows you to do in a single line, what would otherwise require multiple lines. Consider the following case:\n\n```ts\nvar rect = { x: 0, y: 10, width: 15, height: 20 };\n\n// Destructuring assignment\nvar {x, y, width, height} = rect;\nconsole.log(x, y, width, height); // 0,10,15,20"}
{"id": "docs\\destructuring.md#1", "content": "rect.x = 10;\n({x, y, width, height} = rect); // assign to existing variables using outer parentheses\nconsole.log(x, y, width, height); // 10,10,15,20\n```\nHere in the absence of destructuring you would have to pick off `x,y,width,height` one by one from `rect`.\n\nTo assign an extracted variable to a new variable name you can do the following:\n\n```ts\n// structure\nconst obj = {\"some property\": \"some value\"};\n\n// destructure\nconst {\"some property\": someProperty} = obj;\nconsole.log(someProperty === \"some value\"); // true\n```\n\nAdditionally you can get *deep* data out of a structure using destructuring. This is shown in the following example:\n\n```ts\nvar foo = { bar: { bas: 123 } };\nvar {bar: {bas}} = foo; // Effectively `var bas = foo.bar.bas;`\n```\n\n#### Object Destructuring with rest\nYou can pick up any number of elements from an object and get *an object* of the remaining elements using object destructuring with rest."}
{"id": "docs\\destructuring.md#2", "content": "```ts\nvar {w, x, ...remaining} = {w: 1, x: 2, y: 3, z: 4};\nconsole.log(w, x, remaining); // 1, 2, {y:3,z:4}\n```\nA common use case is also to ignore certain properties. For example:\n```ts\n// Example function\nfunction goto(point2D: {x: number, y: number}) {\n  // Imagine some code that might break\n  // if you pass in an object\n  // with more items than desired\n}\n// Some point you get from somewhere\nconst point3D = {x: 1, y: 2, z: 3};\n/** A nifty use of rest to remove extra properties */\nconst { z, ...point2D } = point3D;\ngoto(point2D);\n```\n\n#### Array Destructuring\nA common programming question: \"How to swap two variables without using a third one?\". The TypeScript solution:\n\n```ts\nvar x = 1, y = 2;\n[x, y] = [y, x];\nconsole.log(x, y); // 2,1\n```\nNote that array destructuring is effectively the compiler doing the `[0], [1], ...` and so on for you. There is no guarantee that these values will exist."}
{"id": "docs\\destructuring.md#3", "content": "#### Array Destructuring with rest\nYou can pick up any number of elements from an array and get *an array* of the remaining elements using array destructuring with rest.\n\n```ts\nvar [x, y, ...remaining] = [1, 2, 3, 4];\nconsole.log(x, y, remaining); // 1, 2, [3,4]\n```\n\n#### Array Destructuring with ignores\nYou can ignore any index by simply leaving its location empty i.e. `, ,` in the left hand side of the assignment. For example:\n```ts\nvar [x, , ...remaining] = [1, 2, 3, 4];\nconsole.log(x, remaining); // 1, [3,4]\n```\n\n#### JS Generation\nThe JavaScript generation for non ES6 targets simply involves creating temporary variables, just like you would have to do yourself without native language support for destructuring e.g.\n\n```ts\nvar x = 1, y = 2;\n[x, y] = [y, x];\nconsole.log(x, y); // 2,1\n\n// becomes //\n\nvar x = 1, y = 2;\n_a = [y,x], x = _a[0], y = _a[1];\nconsole.log(x, y);\nvar _a;\n```"}
{"id": "docs\\destructuring.md#4", "content": "#### Summary\nDestructuring can make your code more readable and maintainable by reducing the line count and making the intent clear. Array destructuring can allow you to use arrays as though they were tuples."}
{"id": "docs\\enums.md#0", "content": "* [Enums](#enums)\n* [Number Enums and numbers](#number-enums-and-numbers)\n* [Number Enums and strings](#number-enums-and-strings)\n* [Changing the number associated with a number enum](#changing-the-number-associated-with-a-number-enum)\n* [Enums are open ended](#enums-are-open-ended)\n* [Number Enums as flags](#number-enums-as-flags)\n* [String Enums](#string-enums)\n* [Const enums](#const-enums)\n* [Enum with static functions](#enum-with-static-functions)\n\n### Enums\nAn enum is a way to organize a collection of related values. Many other programming languages (C/C#/Java) have an `enum` data type but JavaScript does not. However, TypeScript does. Here is an example definition of a TypeScript enum:\n\n```ts\nenum CardSuit {\n\tClubs,\n\tDiamonds,\n\tHearts,\n\tSpades\n}\n\n// Sample usage\nvar card = CardSuit.Clubs;\n\n// Safety\ncard = \"not a member of card suit\"; // Error : string is not assignable to type `CardSuit`\n```\n\nThese enums values are `number`s so I'll call them Number Enums from hence forth."}
{"id": "docs\\enums.md#1", "content": "#### Number Enums and Numbers\nTypeScript enums are number based. This means that numbers can be assigned to an instance of the enum, and so can anything else that is compatible with `number`.\n\n```ts\nenum Color {\n    Red,\n    Green,\n    Blue\n}\nvar col = Color.Red;\ncol = 0; // Effectively same as Color.Red\n```\n\n#### Number Enums and Strings\nBefore we look further into enums let's look at the JavaScript that it generates, here is a sample TypeScript:\n\n```ts\nenum Tristate {\n    False,\n    True,\n    Unknown\n}\n```\ngenerates the following JavaScript:\n\n```js\nvar Tristate;\n(function (Tristate) {\n    Tristate[Tristate[\"False\"] = 0] = \"False\";\n    Tristate[Tristate[\"True\"] = 1] = \"True\";\n    Tristate[Tristate[\"Unknown\"] = 2] = \"Unknown\";\n})(Tristate || (Tristate = {}));\n```"}
{"id": "docs\\enums.md#2", "content": "let's focus on the line `Tristate[Tristate[\"False\"] = 0] = \"False\";`. Within it `Tristate[\"False\"] = 0` should be self explanatory, i.e. sets `\"False\"` member of `Tristate` variable to be `0`. Note that in JavaScript the assignment operator returns the assigned value (in this case `0`). Therefore the next thing executed by the JavaScript runtime is `Tristate[0] = \"False\"`. This means that you can use the `Tristate` variable to convert a string version of the enum to a number or a number version of the enum to a string. This is demonstrated below:\n\n```ts\nenum Tristate {\n    False,\n    True,\n    Unknown\n}\nconsole.log(Tristate[0]); // \"False\"\nconsole.log(Tristate[\"False\"]); // 0\nconsole.log(Tristate[Tristate.False]); // \"False\" because `Tristate.False == 0`\n```\n\n#### Changing the number associated with a Number Enum\nBy default enums are `0` based and then each subsequent value increments by 1 automatically. As an example consider the following:"}
{"id": "docs\\enums.md#3", "content": "```ts\nenum Color {\n    Red,     // 0\n    Green,   // 1\n    Blue     // 2\n}\n```\n\nHowever, you can change the number associated with any enum member by assigning to it specifically. This is demonstrated below where we start at 3 and start incrementing from there:\n\n```ts\nenum Color {\n    DarkRed = 3,  // 3\n    DarkGreen,    // 4\n    DarkBlue      // 5\n}\n```\n\n> TIP: I quite commonly initialize the first enum with ` = 1` as it allows me to do a safe truthy check on an enum value.\n\n#### Number Enums as flags\nOne excellent use of enums is the ability to use enums as `Flags`. Flags allow you to check if a certain condition from a set of conditions is true. Consider the following example where we have a set of properties about animals:\n\n```ts\nenum AnimalFlags {\n    None           = 0,\n    HasClaws       = 1 << 0,\n    CanFly         = 1 << 1,\n    EatsFish       = 1 << 2,\n    Endangered     = 1 << 3\n}\n```"}
{"id": "docs\\enums.md#4", "content": "Here we are using the left shift operator to move `1` around a certain level of bits to come up with bitwise disjoint numbers `0001`, `0010`, `0100` and `1000` (these are decimals `1`,`2`,`4`,`8` if you are curious). The bitwise operators `|` (or) / `&` (and) / `~` (not) are your best friends when working with flags and are demonstrated below:\n\n```ts\nenum AnimalFlags {\n    None           = 0,\n    HasClaws       = 1 << 0,\n    CanFly         = 1 << 1,\n}\ntype Animal = {\n    flags: AnimalFlags\n}\n\nfunction printAnimalAbilities(animal: Animal) {\n    var animalFlags = animal.flags;\n    if (animalFlags & AnimalFlags.HasClaws) {\n        console.log('animal has claws');\n    }\n    if (animalFlags & AnimalFlags.CanFly) {\n        console.log('animal can fly');\n    }\n    if (animalFlags == AnimalFlags.None) {\n        console.log('nothing');\n    }\n}"}
{"id": "docs\\enums.md#5", "content": "let animal: Animal = { flags: AnimalFlags.None };\nprintAnimalAbilities(animal); // nothing\nanimal.flags |= AnimalFlags.HasClaws;\nprintAnimalAbilities(animal); // animal has claws\nanimal.flags &= ~AnimalFlags.HasClaws;\nprintAnimalAbilities(animal); // nothing\nanimal.flags |= AnimalFlags.HasClaws | AnimalFlags.CanFly;\nprintAnimalAbilities(animal); // animal has claws, animal can fly\n```\n\nHere:\n* we used `|=` to add flags\n* a combination of `&=` and `~` to clear a flag\n* `|` to combine flags\n\n> Note: you can combine flags to create convenient shortcuts within the enum definition e.g. `EndangeredFlyingClawedFishEating` below:\n\n```ts\nenum AnimalFlags {\n\tNone           = 0,\n    HasClaws       = 1 << 0,\n    CanFly         = 1 << 1,\n    EatsFish       = 1 << 2,\n    Endangered     = 1 << 3,\n\n\tEndangeredFlyingClawedFishEating = HasClaws | CanFly | EatsFish | Endangered,\n}\n```"}
{"id": "docs\\enums.md#6", "content": "#### String Enums\nWe've only looked at enums where the member values are `number`s. You are actually allowed to have enum members with string values as well. e.g. \n\n```ts\nexport enum EvidenceTypeEnum {\n  UNKNOWN = '',\n  PASSPORT_VISA = 'passport_visa',\n  PASSPORT = 'passport',\n  SIGHTED_STUDENT_CARD = 'sighted_tertiary_edu_id',\n  SIGHTED_KEYPASS_CARD = 'sighted_keypass_card',\n  SIGHTED_PROOF_OF_AGE_CARD = 'sighted_proof_of_age_card',\n}\n```\n\nThese can be easier to deal with and debug as they provide meaningful / debuggable string values. \n\nYou can use these values to do simple string comparisons. e.g. \n\n```ts\n// Where `someStringFromBackend` will be '' | 'passport_visa' | 'passport' ... etc.\nconst value = someStringFromBackend as EvidenceTypeEnum; \n\n// Sample use in code\nif (value === EvidenceTypeEnum.PASSPORT){\n    console.log('You provided a passport');\n    console.log(value); // `passport`\n}\n```\n\n#### Const Enums\n\nIf you have an enum definition like the following:"}
{"id": "docs\\enums.md#7", "content": "```ts\nenum Tristate {\n    False,\n    True,\n    Unknown\n}\n\nvar lie = Tristate.False;\n```\n\nThe line `var lie = Tristate.False` is compiled to the JavaScript `var lie = Tristate.False` (yes, output is same as input). This means that at execution the runtime will need to lookup `Tristate` and then `Tristate.False`. To get a performance boost here you can mark the `enum` as a `const enum`. This is demonstrated below:\n\n```ts\nconst enum Tristate {\n    False,\n    True,\n    Unknown\n}\n\nvar lie = Tristate.False;\n```\n\ngenerates the JavaScript:\n\n```js\nvar lie = 0;\n```\n\ni.e. the compiler:\n\n1. *Inlines* any usages of the enum (`0` instead of `Tristate.False`).\n1. Does not generate any JavaScript for the enum definition (there is no `Tristate` variable at runtime) as its usages are inlined."}
{"id": "docs\\enums.md#8", "content": "##### Const enum preserveConstEnums\nInlining has obvious performance benefits. The fact that there is no `Tristate` variable at runtime is simply the compiler helping you out by not generating JavaScript that is not actually used at runtime. However, you might want the compiler to still generate the JavaScript version of the enum definition for stuff like *number to string* or *string to number* lookups as we saw. In this case you can use the compiler flag `--preserveConstEnums` and it will still generate the `var Tristate` definition so that you can use `Tristate[\"False\"]` or `Tristate[0]` manually at runtime if you want. This does not impact *inlining* in any way.\n\n### Enum with static functions\nYou can use the declaration `enum` + `namespace` merging to add static methods to an enum. The following demonstrates an example where we add a static member `isBusinessDay` to an enum `Weekday`:"}
{"id": "docs\\enums.md#9", "content": "```ts\nenum Weekday {\n\tMonday,\n\tTuesday,\n\tWednesday,\n\tThursday,\n\tFriday,\n\tSaturday,\n\tSunday\n}\nnamespace Weekday {\n\texport function isBusinessDay(day: Weekday) {\n\t\tswitch (day) {\n\t\t\tcase Weekday.Saturday:\n\t\t\tcase Weekday.Sunday:\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n}\n\nconst mon = Weekday.Monday;\nconst sun = Weekday.Sunday;\nconsole.log(Weekday.isBusinessDay(mon)); // true\nconsole.log(Weekday.isBusinessDay(sun)); // false\n```\n\n#### Enums are open ended\n\n> NOTE: open ended enums are only relevant if you are not using modules. You should be using modules. Hence this section is last.\n\nHere is the generated JavaScript for an enum shown again:\n\n```js\nvar Tristate;\n(function (Tristate) {\n    Tristate[Tristate[\"False\"] = 0] = \"False\";\n    Tristate[Tristate[\"True\"] = 1] = \"True\";\n    Tristate[Tristate[\"Unknown\"] = 2] = \"Unknown\";\n})(Tristate || (Tristate = {}));\n```"}
{"id": "docs\\enums.md#10", "content": "We already explained the `Tristate[Tristate[\"False\"] = 0] = \"False\";` portion. Now notice the surrounding code `(function (Tristate) { /*code here */ })(Tristate || (Tristate = {}));` specifically the `(Tristate || (Tristate = {}));` portion. This basically captures a local variable `TriState` that will either point to an already defined `Tristate` value or initialize it with a new empty `{}` object.\n\nThis means that you can split (and extend) an enum definition across multiple files. For example below we have split the definition for `Color` into two blocks\n\n```ts\nenum Color {\n    Red,\n    Green,\n    Blue\n}\n\nenum Color {\n    DarkRed = 3,\n    DarkGreen,\n    DarkBlue\n}\n```"}
{"id": "docs\\enums.md#11", "content": "Note that you *should* reinitialize the first member (here `DarkRed = 3`) in a continuation of an enum to get the generated code not clobber values from a previous definition (i.e. the `0`, `1`, ... so on values). TypeScript will warn you if you don't anyways (error message `In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.`)."}
{"id": "docs\\for...of.md#0", "content": "### for...of\nA common error experienced by beginning JavaScript developers is that `for...in` for an array does not iterate over the array items. Instead it iterates over the *keys* of the object passed in. This is demonstrated in the below example. Here you would expect `9,2,5` but you get the indexes `0,1,2`:\n\n```ts\nvar someArray = [9, 2, 5];\nfor (var item in someArray) {\n    console.log(item); // 0,1,2\n}\n```\n\nThis is one of the reasons why `for...of` exists in TypeScript (and ES6). The following iterates over the array correctly logging out the members as expected:\n\n```ts\nvar someArray = [9, 2, 5];\nfor (var item of someArray) {\n    console.log(item); // 9,2,5\n}\n```\n\nSimilarly TypeScript has no trouble going through a string character by character using `for...of`:\n\n```ts\nvar hello = \"is it me you're looking for?\";\nfor (var char of hello) {\n    console.log(char); // is it me you're looking for?\n}\n```"}
{"id": "docs\\for...of.md#1", "content": "#### JS Generation\nFor pre ES6 targets TypeScript will generate the standard `for (var i = 0; i < list.length; i++)` kind of loop. For example here's what gets generated for our previous example:\n```ts\nvar someArray = [9, 2, 5];\nfor (var item of someArray) {\n    console.log(item);\n}\n\n// becomes //\n\nfor (var _i = 0; _i < someArray.length; _i++) {\n    var item = someArray[_i];\n    console.log(item);\n}\n```\nYou can see that using `for...of` makes *intent* clearer and also decreases the amount of code you have to write (and variable names you need to come up with).\n\n#### Limitations\nIf you are not targeting ES6 or above, the generated code assumes the property `length` exists on the object and that the object can be indexed via numbers e.g. `obj[2]`. So it is only supported on `string` and `array` for these legacy JS engines."}
{"id": "docs\\for...of.md#2", "content": "If TypeScript can see that you are not using an array or a string it will give you a clear error *\"is not an array type or a string type\"*;\n```ts\nlet articleParagraphs = document.querySelectorAll(\"article > p\");\n// Error: Nodelist is not an array type or a string type\nfor (let paragraph of articleParagraphs) {\n    paragraph.classList.add(\"read\");\n}\n```\n\nUse `for...of` only for stuff that *you know* to be an array or a string. Note that this limitation might be removed in a future version of TypeScript.\n\n#### Summary\nYou would be surprised at how many times you will be iterating over the elements of an array. The next time you find yourself doing that, give `for...of` a go. You might just make the next person who reviews your code happy."}
{"id": "docs\\future-javascript.md#0", "content": "# Future JavaScript: Now\nOne of the main selling points of TypeScript is that it allows you to use a bunch of features from ES6 and beyond in current (ES3 and ES5 level) JavaScript engines (like current browsers and Node.js). Here we deep dive into why these features are useful followed by how these features are implemented in TypeScript.\n\nNote: Not all of these features are slated for immediate addition to JavaScript but provide great utility to your code organization and maintenance. Also note that you are free to ignore any of the constructs that don't make sense for your project, although you will end up using most of them eventually ;)"}
{"id": "docs\\generators.md#0", "content": "## Generators\n\n`function *` is the syntax used to create a *generator function*. Calling a generator function returns a *generator object*. The generator object just follows the [iterator][iterator] interface (i.e. the `next`, `return` and `throw` functions). \n\nThere are two key motivations behind generator functions: \n\n### Lazy Iterators\n\nGenerator functions can be used to create lazy iterators e.g. the following function returns an **infinite** list of integers on demand:\n\n```ts\nfunction* infiniteSequence() {\n    var i = 0;\n    while(true) {\n        yield i++;\n    }\n}\n\nvar iterator = infiniteSequence();\nwhile (true) {\n    console.log(iterator.next()); // { value: xxxx, done: false } forever and ever\n}\n```\n\nOf course if the iterator does end, you get the result of `{ done: true }` as demonstrated below:\n\n```ts\nfunction* idMaker(){\n  let index = 0;\n  while(index < 3)\n    yield index++;\n}\n\nlet gen = idMaker();"}
{"id": "docs\\generators.md#1", "content": "console.log(gen.next()); // { value: 0, done: false }\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { done: true }\n```\n\n### Externally Controlled Execution\nThis is the part of generators that is truly exciting. It essentially allows a function to pause its execution and pass control (fate) of the remainder of the function execution to the caller.\n\nA generator function does not execute when you call it. It just creates a generator object. Consider the following example along with a sample execution:\n\n```ts\nfunction* generator(){\n    console.log('Execution started');\n    yield 0;\n    console.log('Execution resumed');\n    yield 1;\n    console.log('Execution resumed');\n}"}
{"id": "docs\\generators.md#2", "content": "var iterator = generator();\nconsole.log('Starting iteration'); // This will execute before anything in the generator function body executes\nconsole.log(iterator.next()); // { value: 0, done: false }\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n\nIf you run this you get the following output:\n\n```\n$ node outside.js\nStarting iteration\nExecution started\n{ value: 0, done: false }\nExecution resumed\n{ value: 1, done: false }\nExecution resumed\n{ value: undefined, done: true }\n```\n\n* The function only starts execution once `next` is called on the generator object.\n* The function *pauses* as soon as a `yield` statement is encountered.\n* The function *resumes* when `next` is called.\n\n> So essentially the execution of the generator function is controllable by the generator object."}
{"id": "docs\\generators.md#3", "content": "Our communication using the generator has been mostly one way with the generator returning values for the iterator. One extremely powerful feature of generators in JavaScript is that they allow two way communications (with caveats).\n\n* you can control the resulting value of the `yield` expression using `iterator.next(valueToInject)`\n* you can throw an exception at the point of the `yield` expression using `iterator.throw(error)`\n\nThe following example demonstrates `iterator.next(valueToInject)`:\n\n```ts\nfunction* generator() {\n    const bar = yield 'foo'; // bar may be *any* type\n    console.log(bar); // bar!\n}\n\nconst iterator = generator();\n// Start execution till we get first yield value\nconst foo = iterator.next();\nconsole.log(foo.value); // foo\n// Resume execution injecting bar\nconst nextThing = iterator.next('bar');\n```"}
{"id": "docs\\generators.md#4", "content": "Since `yield` returns the parameter passed to the iterator's `next` function, and all iterators' `next` functions accept a parameter of any type, TypeScript will always assign the `any` type to the result of the `yield` operator (`bar` above).\n\n> You are on your own to coerce the result to the type you expect, and ensure that only values of that type are passed to next (such as by scaffolding an additional type-enforcement layer that calls `next` for you.) If strong typing is important to you, you may want to avoid two-way communication altogether, as well as packages that rely heavily on it (e.g., redux-saga).\n\nThe following example demonstrates `iterator.throw(error)`:\n\n```ts\nfunction* generator() {\n    try {\n        yield 'foo';\n    }\n    catch(err) {\n        console.log(err.message); // bar!\n    }\n}"}
{"id": "docs\\generators.md#5", "content": "var iterator = generator();\n// Start execution till we get first yield value\nvar foo = iterator.next();\nconsole.log(foo.value); // foo\n// Resume execution throwing an exception 'bar'\nvar nextThing = iterator.throw(new Error('bar'));\n```\n\nSo here is the summary:\n* `yield` allows a generator function to pause its communication and pass control to an external system\n* the external system can push a value into the generator function body\n* the external system can throw an exception into the generator function body\n\nHow is this useful? Jump to the next section [**async/await**][async-await] and find out.\n\n[iterator]:./iterators.md\n[async-await]:./async-await.md"}
{"id": "docs\\getting-started.md#0", "content": "* [Getting Started with TypeScript](#getting-started-with-typescript)\n* [TypeScript Version](#typescript-version)\n\n# Getting Started With TypeScript\n\nTypeScript compiles into JavaScript. JavaScript is what you are actually going to execute (either in the browser or on the server). So you are going to need the following:\n\n* TypeScript compiler (OSS available [in source](https://github.com/Microsoft/TypeScript/) and on [NPM](https://www.npmjs.com/package/typescript))\n* A TypeScript editor (you can use notepad if you want but I use [vscode \ud83c\udf39](https://code.visualstudio.com/) with an [extension I wrote](https://marketplace.visualstudio.com/items?itemName=basarat.god). Also [lots of other IDES support it as well]( https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support))\n\n\n## TypeScript Version"}
{"id": "docs\\getting-started.md#1", "content": "Instead of using the *stable* TypeScript compiler we will be presenting a lot of new stuff in this book that may not be associated with a version number yet. I generally recommend people to use the nightly version because **the compiler test suite only catches more bugs over time**.\n\nYou can install it on the command line as\n\n```\nnpm install -g typescript@next\n```\n\nAnd now the command line `tsc` will be the latest and greatest. Various IDEs support it too, e.g.\n\n* You can ask vscode to use this version by creating `.vscode/settings.json` with the following contents:\n\n```json\n{\n  \"typescript.tsdk\": \"./node_modules/typescript/lib\"\n}\n```"}
{"id": "docs\\getting-started.md#2", "content": "## Getting the Source Code\nThe source for this book is available in the books github repository https://github.com/basarat/typescript-book/tree/master/code most of the code samples can be copied into vscode and you can play with them as is. For code samples that need additional setup (e.g. npm modules), we will link you to the code sample before presenting the code. e.g.\n\n`this/will/be/the/link/to/the/code.ts`\n```ts\n// This will be the code under discussion\n```\n\nWith a dev setup out of the way let's jump into TypeScript syntax."}
{"id": "docs\\iterators.md#0", "content": "### Iterators\n\nIterator itself is not a TypeScript or ES6 feature, Iterator is a\nBehavioral Design Pattern common for Object oriented programming languages.\nIt is, generally, an object which implements the following interface:\n\n```ts\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\n```\n([More on that `<T>` notation later][generics])  \nThis interface allows to retrieve a value from some collection or sequence\nwhich belongs to the object.\n\nThe `IteratorResult` is simply a `value`+`done` pair: \n```ts\ninterface IteratorResult<T> {\n    done: boolean;\n    value: T;\n}\n```\n\nImagine that there's an object of some frame, which includes the list of\ncomponents of which this frame consists. With Iterator interface it is possible\nto retrieve components from this frame object like below:\n\n```ts\nclass Component {\n  constructor (public name: string) {}\n}\n\nclass Frame implements Iterator<Component> {"}
{"id": "docs\\iterators.md#1", "content": "private pointer = 0;\n\n  constructor(public name: string, public components: Component[]) {}\n\n  public next(): IteratorResult<Component> {\n    if (this.pointer < this.components.length) {\n      return {\n        done: false,\n        value: this.components[this.pointer++]\n      }\n    } else {\n      return {\n        done: true,\n        value: null\n      }\n    }\n  }\n\n}\n\nlet frame = new Frame(\"Door\", [new Component(\"top\"), new Component(\"bottom\"), new Component(\"left\"), new Component(\"right\")]);\nlet iteratorResult1 = frame.next(); //{ done: false, value: Component { name: 'top' } }\nlet iteratorResult2 = frame.next(); //{ done: false, value: Component { name: 'bottom' } }\nlet iteratorResult3 = frame.next(); //{ done: false, value: Component { name: 'left' } }\nlet iteratorResult4 = frame.next(); //{ done: false, value: Component { name: 'right' } }\nlet iteratorResult5 = frame.next(); //{ done: true, value: null }"}
{"id": "docs\\iterators.md#2", "content": "//It is possible to access the value of iterator result via the value property:\nlet component = iteratorResult1.value; //Component { name: 'top' }\n```\nAgain. Iterator itself is not a TypeScript feature, this code could work without\nimplementing Iterator and IteratorResult interfaces explicitly.\nHowever, it is very helpful to use these common\nES6 [interfaces](./types/interfaces.md) for code consistency.\n\nOk, Nice, but could be more helpful. ES6 defines the *iterable protocol*\nwhich includes the [Symbol.iterator] `symbol` if the Iterable interface is implemented:\n```ts\n//...\nclass Frame implements Iterable<Component> {\n\n  constructor(public name: string, public components: Component[]) {}\n\n  [Symbol.iterator]() {\n    let pointer = 0;\n    let components = this.components;"}
{"id": "docs\\iterators.md#3", "content": "return {\n      next(): IteratorResult<Component> {\n        if (pointer < components.length) {\n          return {\n            done: false,\n            value: components[pointer++]\n          }\n        } else {\n          return {\n            done: true,\n            value: null\n          }\n        }\n      }\n    }\n  }\n}\n\nlet frame = new Frame(\"Door\", [new Component(\"top\"), new Component(\"bottom\"), new Component(\"left\"), new Component(\"right\")]);\nfor (let cmp of frame) {\n  console.log(cmp);\n}\n```\n\nUnfortunately `frame.next()` won't work with this pattern and it also looks\na bit clunky. IterableIterator interface to the rescue!\n```ts\n//...\nclass Frame implements IterableIterator<Component> {\n\n  private pointer = 0;\n\n  constructor(public name: string, public components: Component[]) {}"}
{"id": "docs\\iterators.md#4", "content": "public next(): IteratorResult<Component> {\n    if (this.pointer < this.components.length) {\n      return {\n        done: false,\n        value: this.components[this.pointer++]\n      }\n    } else {\n      return {\n        done: true,\n        value: null\n      }\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<Component> {\n    return this;\n  }\n\n}\n//...\n```\nBoth `frame.next()` and `for` cycle now work fine with IterableIterator interface.\n\nIterator does not have to iterate a finite value.\nThe typical example is a Fibonacci sequence:\n```ts\nclass Fib implements IterableIterator<number> {\n\n  protected fn1 = 0;\n  protected fn2 = 1;\n\n  constructor(protected maxValue?: number) {}"}
{"id": "docs\\iterators.md#5", "content": "public next(): IteratorResult<number> {\n    var current = this.fn1;\n    this.fn1 = this.fn2;\n    this.fn2 = current + this.fn1;\n    if (this.maxValue != null && current >= this.maxValue) {\n      return {\n        done: true,\n        value: null\n      } \n    } \n    return {\n      done: false,\n      value: current\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<number> {\n    return this;\n  }\n\n}\n\nlet fib = new Fib();\n\nfib.next() //{ done: false, value: 0 }\nfib.next() //{ done: false, value: 1 }\nfib.next() //{ done: false, value: 1 }\nfib.next() //{ done: false, value: 2 }\nfib.next() //{ done: false, value: 3 }\nfib.next() //{ done: false, value: 5 }\n\nlet fibMax50 = new Fib(50);\nconsole.log(Array.from(fibMax50)); // [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ]\n\nlet fibMax21 = new Fib(21);\nfor(let num of fibMax21) {\n  console.log(num); //Prints fibonacci sequence 0 to 21\n}\n```"}
{"id": "docs\\iterators.md#6", "content": "#### Building code with iterators for ES5 target\nCode examples above require ES6 target. However, it could work\nwith ES5 target as well if target JS engine supports `Symbol.iterator`.\nThis can be achieved by using ES6 lib with ES5 target\n(add es6.d.ts to your project) to make it compile.\nCompiled code should work in node 4+, Google Chrome and in some other browsers.\n\n[generics]: ./types/generics.md"}
{"id": "docs\\let.md#0", "content": "### let\n\n`var` Variables in JavaScript are *function scoped*. This is different from many other languages (C# / Java etc.) where the variables are *block scoped*. If you bring a *block scoped* mindset to JavaScript, you would expect the following to print `123`, instead it will print `456`:\n\n```ts\nvar foo = 123;\nif (true) {\n    var foo = 456;\n}\nconsole.log(foo); // 456\n```\nThis is because `{` does not create a new *variable scope*. The variable `foo` is the same inside the if *block* as it is outside the if block. This is a common source of errors in JavaScript programming. This is why TypeScript (and ES6) introduces the `let` keyword to allow you to define variables with true *block scope*. That is if you use `let` instead of `var` you get a true unique element disconnected from what you might have defined outside the scope. The same example is demonstrated with `let`:\n\n```ts\nlet foo = 123;\nif (true) {\n    let foo = 456;\n}\nconsole.log(foo); // 123\n```"}
{"id": "docs\\let.md#1", "content": "Another place where `let` would save you from errors is loops.\n```ts\nvar index = 0;\nvar array = [1, 2, 3];\nfor (let index = 0; index < array.length; index++) {\n    console.log(array[index]);\n}\nconsole.log(index); // 0\n```\nIn all sincerity we find it better to use `let` whenever possible as it leads to fewer surprises for new and existing multi-lingual developers.\n\n#### Functions create a new scope\nSince we mentioned it, we'd like to demonstrate that functions create a new variable scope in JavaScript. Consider the following:\n\n```ts\nvar foo = 123;\nfunction test() {\n    var foo = 456;\n}\ntest();\nconsole.log(foo); // 123\n```\nThis behaves as you would expect. Without this it would be very difficult to write code in JavaScript.\n\n#### Generated JS\nThe JS generated by TypeScript is simple renaming of the `let` variable if a similar name already exists in the surrounding scope. E.g. the following is generated as is with a simple replacement of `let` with `var`:"}
{"id": "docs\\let.md#2", "content": "```ts\nif (true) {\n    let foo = 123;\n}\n\n// becomes //\n\nif (true) {\n    var foo = 123;\n}\n```\nHowever, if the variable name is already taken by the surrounding scope then a new variable name is generated as shown (notice `foo_1`):\n\n```ts\nvar foo = '123';\nif (true) {\n    let foo = 123;\n}\n\n// becomes //\n\nvar foo = '123';\nif (true) {\n    var foo_1 = 123; // Renamed\n}\n```\n\n#### Switch\nYou can wrap your `case` bodies in `{}` to reuse variable names reliably in different `case` statement as shown below:\n\n```ts\nswitch (name) {\n    case 'x': {\n        let x = 5;\n        // ...\n        break;\n    }\n    case 'y': {\n        let x = 10;\n        // ...\n        break;\n    }\n}\n```\n\n#### let in closures\nA common programming interview question for a JavaScript developer is what is the log of this simple file:"}
{"id": "docs\\let.md#3", "content": "```ts\nvar funcs = [];\n// create a bunch of functions\nfor (var i = 0; i < 3; i++) {\n    funcs.push(function() {\n        console.log(i);\n    })\n}\n// call them\nfor (var j = 0; j < 3; j++) {\n    funcs[j]();\n}\n```\nOne would have expected it to be `0,1,2`. Surprisingly it is going to be `3` for all three functions. Reason is that all three functions are using the variable `i` from the outer scope and at the time we execute them (in the second loop) the value of `i` will be `3` (that's the termination condition for the first loop).\n\nA fix would be to create a new variable in each loop specific to that loop iteration. As we've learnt before we can create a new variable scope by creating a new function and immediately executing it (i.e. the IIFE pattern from classes `(function() { /* body */ })();`) as shown below:"}
{"id": "docs\\let.md#4", "content": "```ts\nvar funcs = [];\n// create a bunch of functions\nfor (var i = 0; i < 3; i++) {\n    (function() {\n        var local = i;\n        funcs.push(function() {\n            console.log(local);\n        })\n    })();\n}\n// call them\nfor (var j = 0; j < 3; j++) {\n    funcs[j]();\n}\n```\nHere the functions close over (hence called a `closure`) the *local* variable (conveniently named `local`) and use that instead of the loop variable `i`.\n\n> Note that closures come with a performance impact (they need to store the surrounding state).\n\nThe ES6 `let` keyword in a loop would have the same behavior as the previous example:\n\n```ts\nvar funcs = [];\n// create a bunch of functions\nfor (let i = 0; i < 3; i++) { // Note the use of let\n    funcs.push(function() {\n        console.log(i);\n    })\n}\n// call them\nfor (var j = 0; j < 3; j++) {\n    funcs[j]();\n}\n```\n\nUsing a `let` instead of `var` creates a variable `i` unique to each loop iteration."}
{"id": "docs\\let.md#5", "content": "#### Summary\n`let` is extremely useful to have for the vast majority of code. It can greatly enhance your code readability and decrease the chance of a programming error.\n\n\n\n[](https://github.com/olov/defs/blob/master/loop-closures.md)"}
{"id": "docs\\promise.md#0", "content": "## Promise\n\nThe `Promise` class is something that exists in many modern JavaScript engines and can be easily [polyfilled][polyfill]. The main motivation for promises is to bring synchronous style error handling to Async / Callback style code.\n\n### Callback style code\n\nIn order to fully appreciate promises let's present a simple sample that proves the difficulty of creating reliable Async code with just callbacks. Consider the simple case of authoring an async version of loading JSON from a file. A synchronous version of this can be quite simple:\n\n```ts\nimport fs = require('fs');\n\nfunction loadJSONSync(filename: string) {\n    return JSON.parse(fs.readFileSync(filename));\n}\n\n// good json file\nconsole.log(loadJSONSync('good.json'));\n\n// non-existent file, so fs.readFileSync fails\ntry {\n    console.log(loadJSONSync('absent.json'));\n}\ncatch (err) {\n    console.log('absent.json error', err.message);\n}"}
{"id": "docs\\promise.md#1", "content": "// invalid json file i.e. the file exists but contains invalid JSON so JSON.parse fails\ntry {\n    console.log(loadJSONSync('invalid.json'));\n}\ncatch (err) {\n    console.log('invalid.json error', err.message);\n}\n```\n\nThere are three behaviors of this simple `loadJSONSync` function, a valid return value, a file system error or a JSON.parse error. We handle the errors with a simple try/catch as you are used to when doing synchronous programming in other languages. Now let's make a good async version of such a function. A decent initial attempt with trivial error checking logic would be as follows:\n\n```ts\nimport fs = require('fs');\n\n// A decent initial attempt .... but not correct. We explain the reasons below\nfunction loadJSON(filename: string, cb: (error: Error, data: any) => void) {\n    fs.readFile(filename, function (err, data) {\n        if (err) cb(err);\n        else cb(null, JSON.parse(data));\n    });\n}\n```"}
{"id": "docs\\promise.md#2", "content": "Simple enough, it takes a callback, passes any file system errors to the callback. If no file system errors, it returns the `JSON.parse` result. A few points to keep in mind when working with async functions based on callbacks are:\n\n1. Never call the callback twice.\n1. Never throw an error.\n\nHowever, this simple function fails to accommodate for point two. In fact, `JSON.parse` throws an error if it is passed bad JSON and the callback never gets called and the application crashes. This is demonstrated in the below example:\n\n```ts\nimport fs = require('fs');\n\n// A decent initial attempt .... but not correct\nfunction loadJSON(filename: string, cb: (error: Error, data: any) => void) {\n    fs.readFile(filename, function (err, data) {\n        if (err) cb(err);\n        else cb(null, JSON.parse(data));\n    });\n}"}
{"id": "docs\\promise.md#3", "content": "// load invalid json\nloadJSON('invalid.json', function (err, data) {\n    // This code never executes\n    if (err) console.log('bad.json error', err.message);\n    else console.log(data);\n});\n```\n\nA naive attempt at fixing this would be to wrap the `JSON.parse` in a try catch as shown in the below example:\n\n```ts\nimport fs = require('fs');\n\n// A better attempt ... but still not correct\nfunction loadJSON(filename: string, cb: (error: Error) => void) {\n    fs.readFile(filename, function (err, data) {\n        if (err) {\n            cb(err);\n        }\n        else {\n            try {\n                cb(null, JSON.parse(data));\n            }\n            catch (err) {\n                cb(err);\n            }\n        }\n    });\n}\n\n// load invalid json\nloadJSON('invalid.json', function (err, data) {\n    if (err) console.log('bad.json error', err.message);\n    else console.log(data);\n});\n```"}
{"id": "docs\\promise.md#4", "content": "However, there is a subtle bug in this code. If the callback (`cb`), and not `JSON.parse`, throws an error, since we wrapped it in a `try`/`catch`, the `catch` executes and we call the callback again i.e. the callback gets called twice! This is demonstrated in the example below:\n\n```ts\nimport fs = require('fs');\n\nfunction loadJSON(filename: string, cb: (error: Error) => void) {\n    fs.readFile(filename, function (err, data) {\n        if (err) {\n            cb(err);\n        }\n        else {\n            try {\n                cb(null, JSON.parse(data));\n            }\n            catch (err) {\n                cb(err);\n            }\n        }\n    });\n}\n\n// a good file but a bad callback ... gets called again!\nloadJSON('good.json', function (err, data) {\n    console.log('our callback called');"}
{"id": "docs\\promise.md#5", "content": "if (err) console.log('Error:', err.message);\n    else {\n        // let's simulate an error by trying to access a property on an undefined variable\n        var foo;\n        // The following code throws `Error: Cannot read property 'bar' of undefined`\n        console.log(foo.bar);\n    }\n});\n```\n\n```bash\n$ node asyncbadcatchdemo.js\nour callback called\nour callback called\nError: Cannot read property 'bar' of undefined\n```\n\nThis is because our `loadJSON` function wrongfully wrapped the callback in a `try` block. There is a simple lesson to remember here.\n\n> Simple lesson: Contain all your sync code in a try catch, except when you call the callback.\n\nFollowing this simple lesson, we have a fully functional async version of `loadJSON` as shown below:\n\n```ts\nimport fs = require('fs');"}
{"id": "docs\\promise.md#6", "content": "function loadJSON(filename: string, cb: (error: Error) => void) {\n    fs.readFile(filename, function (err, data) {\n        if (err) return cb(err);\n        // Contain all your sync code in a try catch\n        try {\n            var parsed = JSON.parse(data);\n        }\n        catch (err) {\n            return cb(err);\n        }\n        // except when you call the callback\n        return cb(null, parsed);\n    });\n}\n```\nAdmittedly this is not hard to follow once you've done it a few times but nonetheless it\u2019s a lot of boiler plate code to write simply for good error handling. Now let's look at a better way to tackle asynchronous JavaScript using promises.\n\n## Creating a Promise\n\nA promise can be either `pending` or `fulfilled` or `rejected`.\n\n![promise states and fates](https://raw.githubusercontent.com/basarat/typescript-book/master/images/promise%20states%20and%20fates.png)"}
{"id": "docs\\promise.md#7", "content": "Let's look at creating a promise. It's a simple matter of calling `new` on `Promise` (the promise constructor). The promise constructor is passed `resolve` and `reject` functions for settling the promise state:\n\n```ts\nconst promise = new Promise((resolve, reject) => {\n    // the resolve / reject functions control the fate of the promise\n});\n```\n\n### Subscribing to the fate of the promise\n\nThe promise fate can be subscribed to using `.then` (if resolved) or `.catch` (if rejected).\n\n```ts\nconst promise = new Promise((resolve, reject) => {\n    resolve(123);\n});\npromise.then((res) => {\n    console.log('I get called:', res === 123); // I get called: true\n});\npromise.catch((err) => {\n    // This is never called\n});\n```"}
{"id": "docs\\promise.md#8", "content": "```ts\nconst promise = new Promise((resolve, reject) => {\n    reject(new Error(\"Something awful happened\"));\n});\npromise.then((res) => {\n    // This is never called\n});\npromise.catch((err) => {\n    console.log('I get called:', err.message); // I get called: 'Something awful happened'\n});\n```\n\n> TIP: Promise Shortcuts\n* Quickly creating an already resolved promise: `Promise.resolve(result)`\n* Quickly creating an already rejected promise: `Promise.reject(error)`\n\n### Chain-ability of Promises\nThe chain-ability of promises **is the heart of the benefit that promises provide**. Once you have a promise, from that point on, you use the `then` function to create a chain of promises.\n\n* If you return a promise from any function in the chain, `.then` is only called once the value is resolved:"}
{"id": "docs\\promise.md#9", "content": "```ts\nPromise.resolve(123)\n    .then((res) => {\n        console.log(res); // 123\n        return 456;\n    })\n    .then((res) => {\n        console.log(res); // 456\n        return Promise.resolve(123); // Notice that we are returning a Promise\n    })\n    .then((res) => {\n        console.log(res); // 123 : Notice that this `then` is called with the resolved value\n        return 123;\n    })\n```\n\n* You can aggregate the error handling of any preceding portion of the chain with a single `catch`:\n\n```ts\n// Create a rejected promise\nPromise.reject(new Error('something bad happened'))\n    .then((res) => {\n        console.log(res); // not called\n        return 456;\n    })\n    .then((res) => {\n        console.log(res); // not called\n        return 123;\n    })\n    .then((res) => {\n        console.log(res); // not called\n        return 123;\n    })\n    .catch((err) => {\n        console.log(err.message); // something bad happened\n    });\n```"}
{"id": "docs\\promise.md#10", "content": "* The `catch` actually returns a new promise (effectively creating a new promise chain):\n\n```ts\n// Create a rejected promise\nPromise.reject(new Error('something bad happened'))\n    .then((res) => {\n        console.log(res); // not called\n        return 456;\n    })\n    .catch((err) => {\n        console.log(err.message); // something bad happened\n        return 123;\n    })\n    .then((res) => {\n        console.log(res); // 123\n    })\n```\n\n* Any synchronous errors thrown in a `then` (or `catch`) result in the returned promise to fail:\n\n```ts\nPromise.resolve(123)\n    .then((res) => {\n        throw new Error('something bad happened'); // throw a synchronous error\n        return 456;\n    })\n    .then((res) => {\n        console.log(res); // never called\n        return Promise.resolve(789);\n    })\n    .catch((err) => {\n        console.log(err.message); // something bad happened\n    })\n```"}
{"id": "docs\\promise.md#11", "content": "* Only the relevant (nearest tailing) `catch` is called for a given error (as the catch starts a new promise chain).\n\n```ts\nPromise.resolve(123)\n    .then((res) => {\n        throw new Error('something bad happened'); // throw a synchronous error\n        return 456;\n    })\n    .catch((err) => {\n        console.log('first catch: ' + err.message); // something bad happened\n        return 123;\n    })\n    .then((res) => {\n        console.log(res); // 123\n        return Promise.resolve(789);\n    })\n    .catch((err) => {\n        console.log('second catch: ' + err.message); // never called\n    })\n```\n\n* A `catch` is only called in case of an error in the preceding chain:\n\n```ts\nPromise.resolve(123)\n    .then((res) => {\n        return 456;\n    })\n    .catch((err) => {\n        console.log(\"HERE\"); // never called\n    })\n```\n\nThe fact that:\n\n* errors jump to the tailing `catch` (and skip any middle `then` calls) and\n* synchronous errors also get caught by any tailing `catch`."}
{"id": "docs\\promise.md#12", "content": "effectively provides us with an async programming paradigm that allows better error handling than raw callbacks. More on this below.\n\n\n### TypeScript and promises\nThe great thing about TypeScript is that it understands the flow of values through a promise chain:\n\n```ts\nPromise.resolve(123)\n    .then((res) => {\n         // res is inferred to be of type `number`\n         return true;\n    })\n    .then((res) => {\n        // res is inferred to be of type `boolean`\n\n    });\n```\n\nOf course it also understands unwrapping any function calls that might return a promise:\n\n```ts\nfunction iReturnPromiseAfter1Second(): Promise<string> {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve(\"Hello world!\"), 1000);\n    });\n}"}
{"id": "docs\\promise.md#13", "content": "Promise.resolve(123)\n    .then((res) => {\n        // res is inferred to be of type `number`\n        return iReturnPromiseAfter1Second(); // We are returning `Promise<string>`\n    })\n    .then((res) => {\n        // res is inferred to be of type `string`\n        console.log(res); // Hello world!\n    });\n```\n\n\n### Converting a callback style function to return a promise\n\nJust wrap the function call in a promise and\n- `reject` if an error occurs,\n- `resolve` if it is all good.\n\nE.g. let's wrap `fs.readFile`:\n\n```ts\nimport fs = require('fs');\nfunction readFileAsync(filename: string): Promise<any> {\n    return new Promise((resolve,reject) => {\n        fs.readFile(filename,(err,result) => {\n            if (err) reject(err);\n            else resolve(result);\n        });\n    });\n}\n```\n\nThe most reliable way to do this is to hand write it and it doesn't have to be as verbose as the previous example e.g. converting `setTimeout` into a promisified `delay` function is super easy:"}
{"id": "docs\\promise.md#14", "content": "```ts\nconst delay = (ms: number) => new Promise(res => setTimeout(res, ms));\n```\n\nNote that there is a handy dandy function in NodeJS that does this `node style function => promise returning function` magic for you:\n\n```ts\n/** Sample usage */\nimport fs from 'fs';\nimport util from 'util';\nconst readFile = util.promisify(fs.readFile);\n```\n\n> Webpack supports the `util` module out of the box and you can use it in the browser as well.\n\nIf you have a node callback style function as a *member* be sure to `bind` it as well to make sure it has the correct `this`: \n\n```ts\nconst dbGet = util.promisify(db.get).bind(db);\n```\n\n### Revisiting the JSON example\n\nNow let's revisit our `loadJSON` example and rewrite an async version that uses promises. All that we need to do is read the file contents as a promise, then parse them as JSON and we are done. This is illustrated in the below example:"}
{"id": "docs\\promise.md#15", "content": "```ts\nfunction loadJSONAsync(filename: string): Promise<any> {\n    return readFileAsync(filename) // Use the function we just wrote\n                .then(function (res) {\n                    return JSON.parse(res);\n                });\n}\n```\n\nUsage (notice how similar it is to the original `sync` version introduced at the start of this section \ud83c\udf39):\n```ts\n// good json file\nloadJSONAsync('good.json')\n    .then(function (val) { console.log(val); })\n    .catch(function (err) {\n        console.log('good.json error', err.message); // never called\n    })\n\n// non-existent json file\n    .then(function () {\n        return loadJSONAsync('absent.json');\n    })\n    .then(function (val) { console.log(val); }) // never called\n    .catch(function (err) {\n        console.log('absent.json error', err.message);\n    })"}
{"id": "docs\\promise.md#16", "content": "// invalid json file\n    .then(function () {\n        return loadJSONAsync('invalid.json');\n    })\n    .then(function (val) { console.log(val); }) // never called\n    .catch(function (err) {\n        console.log('bad.json error', err.message);\n    });\n```\n\nThe reason why this function was simpler is because the \"`loadFile`(async) + `JSON.parse` (sync) => `catch`\" consolidation was done by the promise chain. Also the callback was not called by *us* but called by the promise chain so we didn't have the chance of making the mistake of wrapping it in a `try/catch`.\n\n### Parallel control flow\nWe have seen how trivial doing a serial sequence of async tasks is with promises. It is simply a matter of chaining `then` calls."}
{"id": "docs\\promise.md#17", "content": "However, you might potentially want to run a series of async tasks and then do something with the results of all of these tasks. `Promise` provides a static `Promise.all` function that you can use to wait for `n` number of promises to complete. You provide it with an array of `n` promises and it gives you an array of `n` resolved values. Below we show Chaining as well as Parallel:\n\n```ts\n// an async function to simulate loading an item from some server\nfunction loadItem(id: number): Promise<{ id: number }> {\n    return new Promise((resolve) => {\n        console.log('loading item', id);\n        setTimeout(() => { // simulate a server delay\n            resolve({ id: id });\n        }, 1000);\n    });\n}\n\n// Chained / Sequential\nlet item1, item2;\nloadItem(1)\n    .then((res) => {\n        item1 = res;\n        return loadItem(2);\n    })\n    .then((res) => {\n        item2 = res;\n        console.log('done');\n    }); // overall time will be around 2s"}
{"id": "docs\\promise.md#18", "content": "// Concurrent / Parallel\nPromise.all([loadItem(1), loadItem(2)])\n    .then((res) => {\n        [item1, item2] = res;\n        console.log('done');\n    }); // overall time will be around 1s\n```\n\nSometimes, you want to run a series of async tasks, but you get all you need as long as any one of these tasks is settled. `Promise` provides a static `Promise.race` function for this scenario:\n\n```ts\nvar task1 = new Promise(function(resolve, reject) {\n    setTimeout(resolve, 1000, 'one');\n});\nvar task2 = new Promise(function(resolve, reject) {\n    setTimeout(resolve, 2000, 'two');\n});\n\nPromise.race([task1, task2]).then(function(value) {\n  console.log(value); // \"one\"\n  // Both resolve, but task1 resolves faster\n});\n```\n\n[polyfill]:https://github.com/stefanpenner/es6-promise"}
{"id": "docs\\rest-parameters.md#0", "content": "### Rest Parameters\nRest parameters (denoted by `...argumentName` for the last argument) allow you to quickly accept multiple arguments in your function and get them as an array. This is demonstrated in the below example.\n\n```ts\nfunction iTakeItAll(first, second, ...allOthers) {\n    console.log(allOthers);\n}\niTakeItAll('foo', 'bar'); // []\niTakeItAll('foo', 'bar', 'bas', 'qux'); // ['bas','qux']\n```\n\nRest parameters can be used in any function be it `function`/`()=>`/`class member`."}
{"id": "docs\\spread-operator.md#0", "content": "### Spread Operator\n\nThe main objective of the spread operator is to *spread* the elements of an array or object. This is best explained with examples.\n\n#### Apply\nA common use case is to spread an array into the function arguments. Previously you would need to use `Function.prototype.apply`:\n\n```ts\nfunction foo(x, y, z) { }\nvar args = [0, 1, 2];\nfoo.apply(null, args);\n```\n\nNow you can do this simply by prefixing the arguments with `...` as shown below:\n\n```ts\nfunction foo(x, y, z) { }\nvar args = [0, 1, 2];\nfoo(...args);\n```\n\nHere we are *spreading* the `args` array into positional `arguments`.\n\n#### Destructuring\nWe've already seen one usage of this in *destructuring*:\n\n```ts\nvar [x, y, ...remaining] = [1, 2, 3, 4];\nconsole.log(x, y, remaining); // 1,2,[3,4]\n```\nThe motivation here is to simply make it easy for you to capture the remaining elements of an array when destructuring."}
{"id": "docs\\spread-operator.md#1", "content": "#### Array Assignment\nThe spread operator allows you to easily place an *expanded version* of an array into another array. This is demonstrated in the example below:\n\n```ts\nvar list = [1, 2];\nlist = [...list, 3, 4];\nconsole.log(list); // [1,2,3,4]\n```\n\nYou can put the expanded array in at any position, and get the effect you'd expect:\n\n```ts\nvar list = [1, 2];\nlist = [0, ...list, 4];\nconsole.log(list); // [0,1,2,4]\n```\n\n#### Object spread\nYou can also spread an object into another object. A common use case is to simply add a property to an object without mutating the original:\n\n```ts\nconst point2D = {x: 1, y: 2};\n/** Create a new object by using all the point2D props along with z */\nconst point3D = {...point2D, z: 3};\n```\n\nFor objects, the order of where you put the spread matters.  This works something like `Object.assign`, and does what you'd expect: what comes first is 'overridden' by what comes later:"}
{"id": "docs\\spread-operator.md#2", "content": "```ts\nconst point2D = {x: 1, y: 2};\nconst anotherPoint3D = {x: 5, z: 4, ...point2D};\nconsole.log(anotherPoint3D); // {x: 1, y: 2, z: 4}\nconst yetAnotherPoint3D = {...point2D, x: 5, z: 4}\nconsole.log(yetAnotherPoint3D); // {x: 5, y: 2, z: 4}\n```\n\nAnother common use case is a simple shallow extend:\n\n```ts\nconst foo = {a: 1, b: 2, c: 0};\nconst bar = {c: 1, d: 2};\n/** Merge foo and bar */\nconst fooBar = {...foo, ...bar};\n// fooBar is now {a: 1, b: 2, c: 1, d: 2}\n```\n\n#### Summary\n`apply` is something that you often use in JavaScript, so it's good to have a better syntax where you don't have that ugly `null` for the `this` argument. Also having a dedicated syntax for moving arrays out of (destructuring) or into (assignment) other arrays provides a neat syntax for when you are doing array processing on partial arrays.\n\n\n[](https://github.com/Microsoft/TypeScript/pull/1931)"}
{"id": "docs\\template-strings.md#0", "content": "### Template Literals (Template Strings)\nSyntactically these are strings that use backticks ( i.e. \\` ) instead of single (') or double (\") quotes. The motivation of Template Literals is three fold:\n\n* String Interpolation\n* Multiline Strings\n* Tagged Templates\n\n#### String Interpolation\nAnother common use case is when you want to generate some string out of some static strings + some variables. For this you would need some *templating logic* and this is where *template strings* originally got their name from. They have since been officially renamed to *template literals*. Here's how you would potentially generate an html string previously:\n\n```ts\nvar lyrics = 'Never gonna give you up';\nvar html = '<div>' + lyrics + '</div>';\n```\nNow with template literals you can just do:\n\n```ts\nvar lyrics = 'Never gonna give you up';\nvar html = `<div>${lyrics}</div>`;\n```"}
{"id": "docs\\template-strings.md#1", "content": "Note that any placeholder inside the interpolation (`${` and `}`) is treated as a JavaScript expression and evaluated as such e.g. you can do fancy math.\n\n```ts\nconsole.log(`1 and 1 make ${1 + 1}`);\n```\n\n#### Multiline Literals\nEver wanted to put a newline in a JavaScript string? Perhaps you wanted to embed some lyrics? You would have needed to *escape the literal newline* using our favorite escape character `\\`, and then put a new line into the string manually `\\n` at the next line. This is shown below:\n\n```ts\nvar lyrics = \"Never gonna give you up \\\n\\nNever gonna let you down\";\n```\n\nWith TypeScript you can just use a template string:\n\n```ts\nvar lyrics = `Never gonna give you up\nNever gonna let you down`;\n```\n\n#### Tagged Templates"}
{"id": "docs\\template-strings.md#2", "content": "You can place a function (called a `tag`) before the template string and it gets the opportunity to pre process the template string literals plus the values of all the placeholder expressions and return a result. A few notes:\n* All the static literals are passed in as an array for the first argument.\n* All the values of the placeholders expressions are passed in as the remaining arguments. Most commonly you would just use rest parameters to convert these into an array as well.\n\nHere is an example where we have a tag function (named `htmlEscape`) that escapes the html from all the placeholders:\n\n```ts\nvar say = \"a bird in hand > two in the bush\";\nvar html = htmlEscape `<div> I would just like to say : ${say}</div>`;\n\n// a sample tag function\nfunction htmlEscape(literals: TemplateStringsArray, ...placeholders: string[]) {\n    let result = \"\";"}
{"id": "docs\\template-strings.md#3", "content": "// interleave the literals with the placeholders\n    for (let i = 0; i < placeholders.length; i++) {\n        result += literals[i];\n        result += placeholders[i]\n            .replace(/&/g, '&amp;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    }\n\n    // add the last literal\n    result += literals[literals.length - 1];\n    return result;\n}\n```\n> Note: You can annotate `placeholders` to be any `[]`. Whatever you annotate it as, TypeScript will type check to make sure the placeholders used to call the tag match the annotation. For example if you expect to deal with `string` or `number`s you can annotate `...placeholders:(string | number)[]`\n\n#### Generated JS\nFor pre ES6 compile targets the code is fairly simple. Multiline strings become escaped strings. String interpolation becomes *string concatenation*. Tagged Templates become function calls."}
{"id": "docs\\template-strings.md#4", "content": "#### Summary\nMultiline strings and string interpolation are just great things to have in any language. It's great that you can now use them in your JavaScript (thanks TypeScript!). Tagged templates allow you to create powerful string utilities."}
{"id": "docs\\why-typescript.md#0", "content": "# Why TypeScript\nThere are two main goals of TypeScript:\n* Provide an *optional type system* for JavaScript.\n* Provide planned features from future JavaScript editions to current JavaScript engines\n\nThe desire for these goals is motivated below.\n\n## The TypeScript type system\n\nYou might be wondering \"**Why add types to JavaScript?**\"\n\nTypes have proven ability to enhance code quality and understandability. Large teams (Google, Microsoft, Facebook) have continually arrived at this conclusion. Specifically:\n\n* Types increase your agility when doing refactoring. *It's better for the compiler to catch errors than to have things fail at runtime*.\n* Types are one of the best forms of documentation you can have. *The function signature is a theorem and the function body is the proof*.\n\nHowever, types have a way of being unnecessarily ceremonious. TypeScript is very particular about keeping the barrier to entry as low as possible. Here's how:"}
{"id": "docs\\why-typescript.md#1", "content": "### Your JavaScript is TypeScript\nTypeScript provides compile time type safety for your JavaScript code. This is no surprise given its name. The great thing is that the types are completely optional. Your JavaScript code `.js` file can be renamed to a `.ts` file and TypeScript will still give you back valid `.js` equivalent to the original JavaScript file. TypeScript is *intentionally* and strictly a superset of JavaScript with optional Type checking.\n\n### Types can be Implicit\nTypeScript will try to infer as much of the type information as it can in order to give you type safety with minimal cost of productivity during code development. For example, in the following example TypeScript will know that foo is of type `number` below and will give an error on the second line as shown:\n\n```ts\nvar foo = 123;\nfoo = '456'; // Error: cannot assign `string` to `number`"}
{"id": "docs\\why-typescript.md#2", "content": "// Is foo a number or a string?\n```\nThis type inference is well motivated. If you do stuff like shown in this example, then, in the rest of your code, you cannot be certain that `foo` is a `number` or a `string`. Such issues turn up often in large multi-file code bases. We will deep dive into the type inference rules later.\n\n### Types can be Explicit\nAs we've mentioned before, TypeScript will infer as much as it can safely. However, you can use annotations to:\n\n1. Help along the compiler, and more importantly document stuff for the next developer who has to read your code (that might be future you!).\n1. Enforce that what the compiler sees, is what you thought it should see. That is your understanding of the code matches an algorithmic analysis of the code (done by the compiler).\n\nTypeScript uses postfix type annotations popular in other *optionally* annotated languages (e.g. ActionScript and F#)."}
{"id": "docs\\why-typescript.md#3", "content": "```ts\nvar foo: number = 123;\n```\nSo if you do something wrong the compiler will report an error e.g.:\n\n```ts\nvar foo: number = '123'; // Error: cannot assign a `string` to a `number`\n```\n\nWe will discuss all the details of all the annotation syntax supported by TypeScript in a later chapter.\n\n### Types are structural\nIn some languages (specifically nominally typed ones) static typing results in unnecessary ceremony because even though *you know* that the code will work fine the language semantics force you to copy stuff around. This is why stuff like [automapper for C#](http://automapper.org/) is *vital* for C#. In TypeScript because we really want it to be easy for JavaScript developers with a minimum cognitive overload, types are *structural*. This means that *duck typing* is a first class language construct. Consider the following example. The function `iTakePoint2D` will accept anything that contains all the things (`x` and `y`) it expects:"}
{"id": "docs\\why-typescript.md#4", "content": "```ts\ninterface Point2D {\n    x: number;\n    y: number;\n}\ninterface Point3D {\n    x: number;\n    y: number;\n    z: number;\n}\nvar point2D: Point2D = { x: 0, y: 10 }\nvar point3D: Point3D = { x: 0, y: 10, z: 20 }\nfunction iTakePoint2D(point: Point2D) { /* do something */ }\n\niTakePoint2D(point2D); // exact match okay\niTakePoint2D(point3D); // extra information okay\niTakePoint2D({ x: 0 }); // Error: missing information `y`\n```\n\n### Type errors do not prevent JavaScript emit\nTo make it easy for you to migrate your JavaScript code to TypeScript, even if there are compilation errors, by default TypeScript *will emit valid JavaScript* the best that it can. e.g.\n\n```ts\nvar foo = 123;\nfoo = '456'; // Error: cannot assign a `string` to a `number`\n```\n\nwill emit the following js:\n\n```ts\nvar foo = 123;\nfoo = '456';\n```\n\nSo you can incrementally upgrade your JavaScript code to TypeScript. This is very different from how many other language compilers work and yet another reason to move to TypeScript."}
{"id": "docs\\why-typescript.md#5", "content": "### Types can be ambient\nA major design goal of TypeScript was to make it possible for you to safely and easily use existing JavaScript libraries in TypeScript. TypeScript does this by means of *declaration*. TypeScript provides you with a sliding scale of how much or how little effort you want to put in your declarations, the more effort you put the more type safety + code intelligence you get. Note that definitions for most of the popular JavaScript libraries have already been written for you by the [DefinitelyTyped community](https://github.com/borisyankov/DefinitelyTyped) so for most purposes either:\n\n1. The definition file already exists.\n1. Or at the very least, you have a vast list of well reviewed TypeScript declaration templates already available"}
{"id": "docs\\why-typescript.md#6", "content": "As a quick example of how you would author your own declaration file, consider a trivial example of [jquery](https://jquery.com/). By default (as is to be expected of good JS code) TypeScript expects you to declare (i.e. use `var` somewhere) before you use a variable\n```ts\n$('.awesome').show(); // Error: cannot find name `$`\n```\nAs a quick fix *you can tell TypeScript* that there is indeed something called `$`:\n```ts\ndeclare var $: any;\n$('.awesome').show(); // Okay!\n```\nIf you want you can build on this basic definition and provide more information to help protect you from errors:\n```ts\ndeclare var $: {\n    (selector:string): any;\n};\n$('.awesome').show(); // Okay!\n$(123).show(); // Error: selector needs to be a string\n```\n\nWe will discuss the details of creating TypeScript definitions for existing JavaScript in detail later once you know more about TypeScript (e.g. stuff like `interface` and the `any`)."}
{"id": "docs\\why-typescript.md#7", "content": "## Future JavaScript => Now\nTypeScript provides a number of features that are planned in ES6 for current JavaScript engines (that only support ES5 etc). The TypeScript team is actively adding these features and this list is only going to get bigger over time and we will cover this in its own section. But just as a specimen here is an example of a class:\n\n```ts\nclass Point {\n    constructor(public x: number, public y: number) {\n    }\n    add(point: Point) {\n        return new Point(this.x + point.x, this.y + point.y);\n    }\n}\n\nvar p1 = new Point(0, 10);\nvar p2 = new Point(10, 20);\nvar p3 = p1.add(p2); // { x: 10, y: 30 }\n```\n\nand the lovely fat arrow function:\n\n```ts\nvar inc = x => x+1;\n```\n\n### Summary\nIn this section we have provided you with the motivation and design goals of TypeScript. With this out of the way we can dig into the nitty gritty details of TypeScript."}
{"id": "docs\\why-typescript.md#8", "content": "[](Interfaces are open ended)\n[](Type Inference rules)\n[](Cover all the annotations)\n[](Cover all ambients : also that there are no runtime enforcement)\n[](.ts vs. .d.ts)"}
{"id": "docs\\compiler\\ast-tip-children.md#0", "content": "### AST Tip: Visit Children\n\nThere is a utility function `ts.forEachChild` that allows you to visit all the child nodes of any Node in the AST.\n\nHere is simplified snippet of the source code to demonstrate how it functions:\n\n```ts\n\nexport function forEachChild<T>(node: Node, cbNode: (node: Node) => T, cbNodeArray?: (nodes: Node[]) => T): T {\n        if (!node) {\n            return;\n        }\n        switch (node.kind) {\n            case SyntaxKind.BinaryExpression:\n                return visitNode(cbNode, (<BinaryExpression>node).left) ||\n                    visitNode(cbNode, (<BinaryExpression>node).operatorToken) ||\n                    visitNode(cbNode, (<BinaryExpression>node).right);\n            case SyntaxKind.IfStatement:\n                return visitNode(cbNode, (<IfStatement>node).expression) ||\n                    visitNode(cbNode, (<IfStatement>node).thenStatement) ||\n                    visitNode(cbNode, (<IfStatement>node).elseStatement);\n\n            // .... lots more\n```"}
{"id": "docs\\compiler\\ast-tip-children.md#1", "content": "Basically, it checks `node.kind` and based on that assumes an interface offered by the `node` and calls the `cbNode` on the children. However, note that this function doesn't call `visitNode` for *all* children (e.g. SyntaxKind.SemicolonToken). If you want *all* the children of a node in the AST just call `.getChildren` member function of the `Node`.\n\nE.g. here is a function that prints the verbose `AST` of a node:\n\n```ts\nfunction printAllChildren(node: ts.Node, depth = 0) {\n    console.log(new Array(depth+1).join('----'), ts.syntaxKindToName(node.kind), node.pos, node.end);\n    depth++;\n    node.getChildren().forEach(c=> printAllChildren(c, depth));\n}\n```\n\nWe will see a sample usage of this function when we discuss the parser further."}
{"id": "docs\\compiler\\ast-tip-syntaxkind.md#0", "content": "### AST Tip: SyntaxKind\n\n`SyntaxKind` is defined as a `const enum`, here is a sample:\n\n```ts\nexport const enum SyntaxKind {\n    Unknown,\n    EndOfFileToken,\n    SingleLineCommentTrivia,\n    // ... LOTS more\n```\n\nIt's a `const enum` (a concept [we covered previously](../enums.md)) so that it gets *inlined* (e.g. `ts.SyntaxKind.EndOfFileToken` becomes `1`) and we don't get a dereferencing cost when working with the AST. However, the compiler is compiled with `--preserveConstEnums` compiler flag so that the enum *is still available at runtime*. So in JavaScript you can use `ts.SyntaxKind.EndOfFileToken` if you want. Additionally you can convert these enum members to display strings using the following function:\n\n```ts\nexport function syntaxKindToName(kind: ts.SyntaxKind) {\n    return (<any>ts).SyntaxKind[kind];\n}\n```"}
{"id": "docs\\compiler\\ast-trivia.md#0", "content": "### Trivia\nTrivia (called that because it's `trivial`) represent the parts of the source text that are largely insignificant for normal understanding of the code. For example; whitespace, comments, and even conflict markers. Trivia is *not stored* in the AST (to keep it lightweight). However, it can be fetched *on demand* using a few `ts.*` APIs. \n\nBefore we show them you need to understand the following:\n\n#### Trivia Ownership\nIn General:\n* A token owns any trivia after it on the *same* line *upto* the next token.\n* Any comment *after that line* is associated with the following token.\n\nFor leading and ending comments in a file:\n* The first token in the source file gets all the initial trivia.\n* The last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.\n\n#### Trivia APIs\nFor most basic uses, comments are the \"interesting\" trivia. The comments that belong to a Node can be fetched through the following functions:"}
{"id": "docs\\compiler\\ast-trivia.md#1", "content": "Function | Description\n---------|------------\n`ts.getLeadingCommentRanges` | Given the source text and position within that text, returns ranges of comments between the first line break following the given position and the token itself (probably most useful with `ts.Node.getFullStart`).\n`ts.getTrailingCommentRanges` | Given the source text and position within that text, returns ranges of comments until the first line break following the given position (probably most useful with `ts.Node.getEnd`).\n\nAs an example, imagine this portion of a source file:\n\n```ts\ndebugger;/*hello*/\n    //bye\n  /*hi*/    function\n```\n\n`getLeadingCommentRanges` for the `function` will only return the last 2 comments `//bye` and `/*hi*/`.\n\nAppropriately, calling `getTrailingCommentRanges` on the end of the debugger statement will extract the `/*hello*/` comment.\n\n#### Token Start/Full Start\nNodes have what is called a \"token start\" and a \"full start\"."}
{"id": "docs\\compiler\\ast-trivia.md#2", "content": "* Token Start: the more natural version, which is the position in file where the text of a token begins\n* Full Start: the point at which the scanner began scanning since the last significant token\n\nAST nodes have an API for `getStart` and `getFullStart`. In the following example:\n\n```ts\ndebugger;/*hello*/\n    //bye\n  /*hi*/    function\n```\nfor `function` the token start is at `function` whereas *full* start is at `/*hello*/`. Note that full start even includes the trivia that would otherwise be owned by the previous node."}
{"id": "docs\\compiler\\ast.md#0", "content": "## Node\nThe basic building block of the Abstract Syntax Tree (AST). In general a `Node` represents non-terminals in the language grammar; however, some terminals are kept in the tree such as identifiers and literals.\n\nTwo key things make up an AST node's documentation. The node's `SyntaxKind` which identifies its type within the AST, and its `interface`, the API the node provides when instantiated into the AST.\n\nHere are a few key `interface Node` members:\n* `TextRange` members that identify the node's `start` and `end` in the source file.\n* `parent?: Node` the parent of the node in the AST.\n\nThere are other additional members for `Node` flags and modifiers etc. that you can lookup by searching `interface Node` in the source code but the ones we mentioned are vital for node traversal.\n\n## SourceFile\n\n* `SyntaxKind.SourceFile`\n* `interface SourceFile`.\n\nEach `SourceFile` is a top-level AST node that is contained in the `Program`."}
{"id": "docs\\compiler\\binder-container.md#0", "content": "### Container\n\nAn AST node can be a container. This determines the kinds of `SymbolTables` the Node and associated Symbol will have. Container is an abstract concept (i.e. has no associated data structure). The concept is driven by a few things, one being the `ContainerFlags` enum. The function `getContainerFlags` (in `binder.ts`) drives this flag and is presented below:\n\n```ts\nfunction getContainerFlags(node: Node): ContainerFlags {\n    switch (node.kind) {\n        case SyntaxKind.ClassExpression:\n        case SyntaxKind.ClassDeclaration:\n        case SyntaxKind.InterfaceDeclaration:\n        case SyntaxKind.EnumDeclaration:\n        case SyntaxKind.TypeLiteral:\n        case SyntaxKind.ObjectLiteralExpression:\n            return ContainerFlags.IsContainer;"}
{"id": "docs\\compiler\\binder-container.md#1", "content": "case SyntaxKind.CallSignature:\n        case SyntaxKind.ConstructSignature:\n        case SyntaxKind.IndexSignature:\n        case SyntaxKind.MethodDeclaration:\n        case SyntaxKind.MethodSignature:\n        case SyntaxKind.FunctionDeclaration:\n        case SyntaxKind.Constructor:\n        case SyntaxKind.GetAccessor:\n        case SyntaxKind.SetAccessor:\n        case SyntaxKind.FunctionType:\n        case SyntaxKind.ConstructorType:\n        case SyntaxKind.FunctionExpression:\n        case SyntaxKind.ArrowFunction:\n        case SyntaxKind.ModuleDeclaration:\n        case SyntaxKind.SourceFile:\n        case SyntaxKind.TypeAliasDeclaration:\n            return ContainerFlags.IsContainerWithLocals;\n\n        case SyntaxKind.CatchClause:\n        case SyntaxKind.ForStatement:\n        case SyntaxKind.ForInStatement:\n        case SyntaxKind.ForOfStatement:\n        case SyntaxKind.CaseBlock:\n            return ContainerFlags.IsBlockScopedContainer;"}
{"id": "docs\\compiler\\binder-container.md#2", "content": "case SyntaxKind.Block:\n            // do not treat blocks directly inside a function as a block-scoped-container.\n            // Locals that reside in this block should go to the function locals. Otherwise 'x'\n            // would not appear to be a redeclaration of a block scoped local in the following\n            // example:\n            //\n            //      function foo() {\n            //          var x;\n            //          let x;\n            //      }\n            //\n            // If we placed 'var x' into the function locals and 'let x' into the locals of\n            // the block, then there would be no collision.\n            //\n            // By not creating a new block-scoped-container here, we ensure that both 'var x'\n            // and 'let x' go into the Function-container's locals, and we do get a collision\n            // conflict.\n            return isFunctionLike(node.parent) ? ContainerFlags.None : ContainerFlags.IsBlockScopedContainer;\n    }"}
{"id": "docs\\compiler\\binder-container.md#3", "content": "return ContainerFlags.None;\n}\n```\n\nIt is *only* invoked from the binder's `bindChildren` function which sets up a node as a `container` and/or a `blockScopedContainer` depending upon the evaluation of the `getContainerFlags` function. The function `bindChildren` is presented below:\n\n```ts\n// All container nodes are kept on a linked list in declaration order. This list is used by\n// the getLocalNameOfContainer function in the type checker to validate that the local name\n// used for a container is unique.\nfunction bindChildren(node: Node) {\n    // Before we recurse into a node's children, we first save the existing parent, container\n    // and block-container.  Then after we pop out of processing the children, we restore\n    // these saved values.\n    let saveParent = parent;\n    let saveContainer = container;\n    let savedBlockScopeContainer = blockScopeContainer;\n\n    // This node will now be set as the parent of all of its children as we recurse into them.\n    parent = node;"}
{"id": "docs\\compiler\\binder-container.md#4", "content": "// Depending on what kind of node this is, we may have to adjust the current container\n    // and block-container.   If the current node is a container, then it is automatically\n    // considered the current block-container as well.  Also, for containers that we know\n    // may contain locals, we proactively initialize the .locals field. We do this because\n    // it's highly likely that the .locals will be needed to place some child in (for example,\n    // a parameter, or variable declaration).\n    //\n    // However, we do not proactively create the .locals for block-containers because it's\n    // totally normal and common for block-containers to never actually have a block-scoped\n    // variable in them.  We don't want to end up allocating an object for every 'block' we\n    // run into when most of them won't be necessary.\n    //\n    // Finally, if this is a block-container, then we clear out any existing .locals object\n    // it may contain within it.  This happens in incremental scenarios.  Because we can be\n    // reusing a node from a previous compilation, that node may have had 'locals' created\n    // for it.  We must clear this so we don't accidentally move any stale data forward from\n    // a previous compilation.\n    let containerFlags = getContainerFlags(node);\n    if (containerFlags & ContainerFlags.IsContainer) {\n        container = blockScopeContainer = node;"}
{"id": "docs\\compiler\\binder-container.md#5", "content": "if (containerFlags & ContainerFlags.HasLocals) {\n            container.locals = {};\n        }\n\n        addToContainerChain(container);\n    }\n\n    else if (containerFlags & ContainerFlags.IsBlockScopedContainer) {\n        blockScopeContainer = node;\n        blockScopeContainer.locals = undefined;\n    }\n\n    forEachChild(node, bind);\n\n    container = saveContainer;\n    parent = saveParent;\n    blockScopeContainer = savedBlockScopeContainer;\n}\n```\n\nAs you might recall from the section on binder functions : `bindChildren` is called from the `bind` function. So we have the recursive binding setup : `bind` calls `bindChildren` calls `bind` for each child."}
{"id": "docs\\compiler\\binder-declarations.md#0", "content": "### Symbols and Declarations\nLinking between a `node` and a `symbol` is performed by a few functions. One function that is used to bind the `SourceFile` node to the source file Symbol (in case of an external module) is the `addDeclarationToSymbol` function\n\nNote : the `Symbol` for an external module source file is setup as `flags : SymbolFlags.ValueModule` and `name: '\"' + removeFileExtension(file.fileName) + '\"'`).\n\n```ts\nfunction addDeclarationToSymbol(symbol: Symbol, node: Declaration, symbolFlags: SymbolFlags) {\n    symbol.flags |= symbolFlags;\n\n    node.symbol = symbol;\n\n    if (!symbol.declarations) {\n        symbol.declarations = [];\n    }\n    symbol.declarations.push(node);\n\n    if (symbolFlags & SymbolFlags.HasExports && !symbol.exports) {\n        symbol.exports = {};\n    }\n\n    if (symbolFlags & SymbolFlags.HasMembers && !symbol.members) {\n        symbol.members = {};\n    }"}
{"id": "docs\\compiler\\binder-declarations.md#1", "content": "if (symbolFlags & SymbolFlags.Value && !symbol.valueDeclaration) {\n        symbol.valueDeclaration = node;\n    }\n}\n```\n\nThe important linking portions:\n* Creates a link to the Symbol from the AST node (`node.symbol`).\n* Adds the node as *one of* the declarations of the Symbol (`symbol.declarations`).\n\n#### Declaration\nDeclaration is just a `node` with an optional name. In `types.ts`\n\n```ts\ninterface Declaration extends Node {\n    _declarationBrand: any;\n    name?: DeclarationName;\n}\n```"}
{"id": "docs\\compiler\\binder-diagnostics.md#0", "content": "### Binder Error Reporting\n\nBinding errors are added to the sourceFile's list of `bindDiagnostics`.\n\nAn example error detected during binding is the use of `eval` or `arguments` as a variable name in `use strict` scenario. The relevant code is presented in its entirety below (`checkStrictModeEvalOrArguments` is called from multiple places, call stacks originating from `bindWorker` which calls different functions for different node `SyntaxKind`):"}
{"id": "docs\\compiler\\binder-diagnostics.md#1", "content": "```ts\nfunction checkStrictModeEvalOrArguments(contextNode: Node, name: Node) {\n    if (name && name.kind === SyntaxKind.Identifier) {\n        let identifier = <Identifier>name;\n        if (isEvalOrArgumentsIdentifier(identifier)) {\n            // We check first if the name is inside class declaration or class expression; if so give explicit message\n            // otherwise report generic error message.\n            let span = getErrorSpanForNode(file, name);\n            file.bindDiagnostics.push(createFileDiagnostic(file, span.start, span.length,\n                getStrictModeEvalOrArgumentsMessage(contextNode), identifier.text));\n        }\n    }\n}\n\nfunction isEvalOrArgumentsIdentifier(node: Node): boolean {\n    return node.kind === SyntaxKind.Identifier &&\n        ((<Identifier>node).text === \"eval\" || (<Identifier>node).text === \"arguments\");\n}"}
{"id": "docs\\compiler\\binder-diagnostics.md#2", "content": "function getStrictModeEvalOrArgumentsMessage(node: Node) {\n    // Provide specialized messages to help the user understand why we think they're in\n    // strict mode.\n    if (getContainingClass(node)) {\n        return Diagnostics.Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode;\n    }\n\n    if (file.externalModuleIndicator) {\n        return Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode;\n    }\n\n    return Diagnostics.Invalid_use_of_0_in_strict_mode;\n}\n```"}
{"id": "docs\\compiler\\binder-functions.md#0", "content": "### Binder function\nTwo critical binder functions are `bindSourceFile` and `mergeSymbolTable`. We will take a look at these next.\n\n#### `bindSourceFile`\nBasically checks if `file.locals` is defined, if not it hands over to (a local function) `bind`.\n\nNote: `locals` is defined on `Node` and is of type `SymbolTable`. Note that `SourceFile` is also a `Node` (in fact a root node in the AST).\n\nTIP: local functions are used heavily within the TypeScript compiler. A local function very likely uses variables from the parent function (captured by closure). In the case of `bind` (a local function within `bindSourceFile`) it (or a function it calls) will setup the `symbolCount` and `classifiableNames` among others, that are then stored on the returned `SourceFile`."}
{"id": "docs\\compiler\\binder-functions.md#1", "content": "#### `bind`\nBind takes any `Node` (not just `SourceFile`). First thing it does is assign the `node.parent` (if `parent` variable has been setup ... which again is something the binder does during its processing within the `bindChildren` function), then hands off to `bindWorker` which does the *heavy* lifting. Finally it calls `bindChildren` (a function that simply stores the binder state e.g. current `parent` within its function local vars, then calls `bind` on each child, and then restores the binder state). Now let's look at `bindWorker` which is the more interesting function.\n\n#### `bindWorker`\nThis function switches on `node.kind` (of type `SyntaxKind`) and delegates work to the appropriate `bindFoo` function (also defined within `binder.ts`). For example if the `node` is a `SourceFile` it calls (eventually and only if its an external file module) `bindAnonymousDeclaration`"}
{"id": "docs\\compiler\\binder-functions.md#2", "content": "#### `bindFoo` functions\nThere are a few patterns common to `bindFoo` functions as well as some utility functions that these use. One function that is almost always used is the `createSymbol` function. It is presented in its entirety below:\n\n```ts\nfunction createSymbol(flags: SymbolFlags, name: string): Symbol {\n    symbolCount++;\n    return new Symbol(flags, name);\n}\n```\nAs you can see it is simply keeping the `symbolCount` (a local to `bindSourceFile`) up to date and creating the symbol with the specified parameters."}
{"id": "docs\\compiler\\binder-symbolflags.md#0", "content": "### SymbolFlags\nSymbols have `SymbolFlags`. Below we have them in their verbatim, as of TypeScript 2.2"}
{"id": "docs\\compiler\\binder-symbolflags.md#1", "content": "```ts\n    export const enum SymbolFlags {\n        None                    = 0,\n        FunctionScopedVariable  = 1 << 0,   // Variable (var) or parameter\n        BlockScopedVariable     = 1 << 1,   // A block-scoped variable (let or const)\n        Property                = 1 << 2,   // Property or enum member\n        EnumMember              = 1 << 3,   // Enum member\n        Function                = 1 << 4,   // Function\n        Class                   = 1 << 5,   // Class\n        Interface               = 1 << 6,   // Interface\n        ConstEnum               = 1 << 7,   // Const enum\n        RegularEnum             = 1 << 8,   // Enum\n        ValueModule             = 1 << 9,   // Instantiated module\n        NamespaceModule         = 1 << 10,  // Uninstantiated module\n        TypeLiteral             = 1 << 11,  // Type Literal or mapped type\n        ObjectLiteral           = 1 << 12,  // Object Literal\n        Method                  = 1 << 13,  // Method\n        Constructor             = 1 << 14,  // Constructor\n        GetAccessor             = 1 << 15,  // Get accessor\n        SetAccessor             = 1 << 16,  // Set accessor\n        Signature               = 1 << 17,  // Call, construct, or index signature\n        TypeParameter           = 1 << 18,  // Type parameter\n        TypeAlias               = 1 << 19,  // Type alias\n        ExportValue             = 1 << 20,  // Exported value marker (see comment in declareModuleMember in binder)\n        ExportType              = 1 << 21,  // Exported type marker (see comment in declareModuleMember in binder)\n        ExportNamespace         = 1 << 22,  // Exported namespace marker (see comment in declareModuleMember in binder)\n        Alias                   = 1 << 23,  // An alias for another symbol (see comment in isAliasSymbolDeclaration in checker)\n        Prototype               = 1 << 24,  // Prototype property (no source representation)\n        ExportStar              = 1 << 25,  // Export * declaration\n        Optional                = 1 << 26,  // Optional property\n        Transient               = 1 << 27,  // Transient symbol (created during type check)"}
{"id": "docs\\compiler\\binder-symbolflags.md#2", "content": "Enum = RegularEnum | ConstEnum,\n        Variable = FunctionScopedVariable | BlockScopedVariable,\n        Value = Variable | Property | EnumMember | Function | Class | Enum | ValueModule | Method | GetAccessor | SetAccessor,\n        Type = Class | Interface | Enum | EnumMember | TypeLiteral | ObjectLiteral | TypeParameter | TypeAlias,\n        Namespace = ValueModule | NamespaceModule | Enum,\n        Module = ValueModule | NamespaceModule,\n        Accessor = GetAccessor | SetAccessor,\n\n        // Variables can be redeclared, but can not redeclare a block-scoped declaration with the\n        // same name, or any other value that is not a variable, e.g. ValueModule or Class\n        FunctionScopedVariableExcludes = Value & ~FunctionScopedVariable,\n\n        // Block-scoped declarations are not allowed to be re-declared\n        // they can not merge with anything in the value space\n        BlockScopedVariableExcludes = Value,"}
{"id": "docs\\compiler\\binder-symbolflags.md#3", "content": "ParameterExcludes = Value,\n        PropertyExcludes = None,\n        EnumMemberExcludes = Value | Type,\n        FunctionExcludes = Value & ~(Function | ValueModule),\n        ClassExcludes = (Value | Type) & ~(ValueModule | Interface), // class-interface mergability done in checker.ts\n        InterfaceExcludes = Type & ~(Interface | Class),\n        RegularEnumExcludes = (Value | Type) & ~(RegularEnum | ValueModule), // regular enums merge only with regular enums and modules\n        ConstEnumExcludes = (Value | Type) & ~ConstEnum, // const enums merge only with const enums\n        ValueModuleExcludes = Value & ~(Function | Class | RegularEnum | ValueModule),\n        NamespaceModuleExcludes = 0,\n        MethodExcludes = Value & ~Method,\n        GetAccessorExcludes = Value & ~SetAccessor,\n        SetAccessorExcludes = Value & ~GetAccessor,\n        TypeParameterExcludes = Type & ~TypeParameter,\n        TypeAliasExcludes = Type,\n        AliasExcludes = Alias,"}
{"id": "docs\\compiler\\binder-symbolflags.md#4", "content": "ModuleMember = Variable | Function | Class | Interface | Enum | Module | TypeAlias | Alias,\n\n        ExportHasLocal = Function | Class | Enum | ValueModule,\n\n        HasExports = Class | Enum | Module,\n        HasMembers = Class | Interface | TypeLiteral | ObjectLiteral,\n\n        BlockScoped = BlockScopedVariable | Class | Enum,\n\n        PropertyOrAccessor = Property | Accessor,\n        Export = ExportNamespace | ExportType | ExportValue,\n\n        ClassMember = Method | Accessor | Property,\n\n        /* @internal */\n        // The set of things we consider semantically classifiable.  Used to speed up the LS during\n        // classification.\n        Classifiable = Class | Enum | TypeAlias | Interface | TypeParameter | Module,\n    }\n```\n\n#### ValueModule\n`ValueModule // Instantiated module` is the SymbolFlag used for `SourceFile` if it an external module."}
{"id": "docs\\compiler\\binder-symboltable.md#0", "content": "### SymbolTable\n\nSymbolTable is implemented as a simple HashMap. Here is the interface (`types.ts`):\n\n```ts\ninterface SymbolTable {\n    [index: string]: Symbol;\n}\n```\n\nSymbolTables are initialized by binding. There are a few SymbolTables used by the compiler:\n\nOn `Node`:\n```ts\nlocals?: SymbolTable;                   // Locals associated with node\n```\n\nOn `Symbol`:\n\n```ts\nmembers?: SymbolTable;                  // Class, interface or literal instance members\nexports?: SymbolTable;                  // Module exports\n```\n\nNote: We saw `locals` getting initialized (to `{}`) by `bindChildren` based on `ContainerFlags`.\n\n#### SymbolTable population\nSymbolTables are populated with `Symbols` primarily by a call to `declareSymbol`. This function is presented below in entirety:"}
{"id": "docs\\compiler\\binder-symboltable.md#1", "content": "```ts\n/**\n * Declares a Symbol for the node and adds it to symbols. Reports errors for conflicting identifier names.\n * @param symbolTable - The symbol table which node will be added to.\n * @param parent - node's parent declaration.\n * @param node - The declaration to be added to the symbol table\n * @param includes - The SymbolFlags that node has in addition to its declaration type (eg: export, ambient, etc.)\n * @param excludes - The flags which node cannot be declared alongside in a symbol table. Used to report forbidden declarations.\n */\nfunction declareSymbol(symbolTable: SymbolTable, parent: Symbol, node: Declaration, includes: SymbolFlags, excludes: SymbolFlags): Symbol {\n    Debug.assert(!hasDynamicName(node));\n\n    // The exported symbol for an export default function/class node is always named \"default\"\n    let name = node.flags & NodeFlags.Default && parent ? \"default\" : getDeclarationName(node);\n\n    let symbol: Symbol;\n    if (name !== undefined) {"}
{"id": "docs\\compiler\\binder-symboltable.md#2", "content": "// Check and see if the symbol table already has a symbol with this name.  If not,\n        // create a new symbol with this name and add it to the table.  Note that we don't\n        // give the new symbol any flags *yet*.  This ensures that it will not conflict\n        // with the 'excludes' flags we pass in.\n        //\n        // If we do get an existing symbol, see if it conflicts with the new symbol we're\n        // creating.  For example, a 'var' symbol and a 'class' symbol will conflict within\n        // the same symbol table.  If we have a conflict, report the issue on each\n        // declaration we have for this symbol, and then create a new symbol for this\n        // declaration.\n        //\n        // If we created a new symbol, either because we didn't have a symbol with this name\n        // in the symbol table, or we conflicted with an existing symbol, then just add this\n        // node as the sole declaration of the new symbol.\n        //\n        // Otherwise, we'll be merging into a compatible existing symbol (for example when\n        // you have multiple 'vars' with the same name in the same container).  In this case\n        // just add this node into the declarations list of the symbol.\n        symbol = hasProperty(symbolTable, name)\n            ? symbolTable[name]\n            : (symbolTable[name] = createSymbol(SymbolFlags.None, name));"}
{"id": "docs\\compiler\\binder-symboltable.md#3", "content": "if (name && (includes & SymbolFlags.Classifiable)) {\n            classifiableNames[name] = name;\n        }\n\n        if (symbol.flags & excludes) {\n            if (node.name) {\n                node.name.parent = node;\n            }\n\n            // Report errors every position with duplicate declaration\n            // Report errors on previous encountered declarations\n            let message = symbol.flags & SymbolFlags.BlockScopedVariable\n                ? Diagnostics.Cannot_redeclare_block_scoped_variable_0\n                : Diagnostics.Duplicate_identifier_0;\n            forEach(symbol.declarations, declaration => {\n                file.bindDiagnostics.push(createDiagnosticForNode(declaration.name || declaration, message, getDisplayName(declaration)));\n            });\n            file.bindDiagnostics.push(createDiagnosticForNode(node.name || node, message, getDisplayName(node)));"}
{"id": "docs\\compiler\\binder-symboltable.md#4", "content": "symbol = createSymbol(SymbolFlags.None, name);\n        }\n    }\n    else {\n        symbol = createSymbol(SymbolFlags.None, \"__missing\");\n    }\n\n    addDeclarationToSymbol(symbol, node, includes);\n    symbol.parent = parent;\n\n    return symbol;\n}\n```\n\nWhich SymbolTable is populated is driven by the first argument to this function. e.g. when adding a declaration to a *container* of kind `SyntaxKind.ClassDeclaration` or `SyntaxKind.ClassExpression` the function `declareClassMember` will get called which has the following code:\n\n```ts\nfunction declareClassMember(node: Declaration, symbolFlags: SymbolFlags, symbolExcludes: SymbolFlags) {\n    return node.flags & NodeFlags.Static\n        ? declareSymbol(container.symbol.exports, container.symbol, node, symbolFlags, symbolExcludes)\n        : declareSymbol(container.symbol.members, container.symbol, node, symbolFlags, symbolExcludes);\n}\n```"}
{"id": "docs\\compiler\\binder.md#0", "content": "## Binder\nMost JavaScript transpilers out there are simpler than TypeScript because they provide little in the way of code analysis. The typical JavaScript transpilers only have the following flow:\n\n```ts\nSourceCode ~~Scanner~~> Tokens ~~Parser~~> AST ~~Emitter~~> JavaScript\n```\n\nWhile the above architecture is true as a simplified understanding of TypeScript js generation, a key feature of TypeScript is its *Semantic* system. In order to assist type checking (performed by the `checker`), the `binder` (in `binder.ts`) is used to connect the various parts of the source code into a coherent type system that can then be used by the `checker`. The main responsibility of the binder is to create _Symbols_."}
{"id": "docs\\compiler\\binder.md#1", "content": "### Symbol\nSymbols connect declaration nodes in the AST to other declarations contributing to the same entity. Symbols are the basic building blocks of the Semantic system. The symbol constructor is defined in `core.ts` (and `binder` actually uses the `objectAllocator.getSymbolConstructor` to get its hands on it). Here is the symbol constructor:\n\n```ts\nfunction Symbol(flags: SymbolFlags, name: string) {\n    this.flags = flags;\n    this.name = name;\n    this.declarations = undefined;\n}\n```\n\n`SymbolFlags` is a flag enum and is really used to identify additional classifications of the symbol (e.g. variable scope flags `FunctionScopedVariable` or `BlockScopedVariable` among others)"}
{"id": "docs\\compiler\\binder.md#2", "content": "### Usage by Checker\nThe `binder` is actually used internally by the type `checker` which in turn is used by the `program`. The simplified call stack looks like:\n```\nprogram.getTypeChecker ->\n    ts.createTypeChecker (in checker)->\n        initializeTypeChecker (in checker) ->\n            for each SourceFile `ts.bindSourceFile` (in binder)\n            // followed by\n            for each SourceFile `ts.mergeSymbolTable` (in checker)\n```\nThe unit of work for the binder is a SourceFile. The `binder.ts` is driven by `checker.ts`."}
{"id": "docs\\compiler\\checker-diagnostics.md#0", "content": "### Checker error reporting\nThe checker uses the local `error` function to report errors. Here is the function:\n\n```ts\nfunction error(location: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): void {\n    let diagnostic = location\n        ? createDiagnosticForNode(location, message, arg0, arg1, arg2)\n        : createCompilerDiagnostic(message, arg0, arg1, arg2);\n    diagnostics.add(diagnostic);\n}\n```"}
{"id": "docs\\compiler\\checker-global.md#0", "content": "### Global Namespace Merging\nWithin `initializeTypeChecker` the following code exists:\n\n```ts\n// Initialize global symbol table\nforEach(host.getSourceFiles(), file => {\n    if (!isExternalModule(file)) {\n        mergeSymbolTable(globals, file.locals);\n    }\n});\n```\n\nWhich basically merges all the `global` symbols into the `let globals: SymbolTable = {};` (in `createTypeChecker`) SymbolTable. `mergeSymbolTable` primarily calls `mergeSymbol`."}
{"id": "docs\\compiler\\checker.md#0", "content": "## Checker\nLike we mentioned before *checker* is the thing that makes TypeScript uniquely more powerful than *just another JavaScript transpiler*. The checker is located in `checker.ts` and at this moment it is 23k+ lines of TypeScript (largest part of the compiler).\n\n### Usage by Program\nThe `checker` is initialized by `program`. The following is a sampling of the call stack (we showed the same one when looking at `binder`):\n\n```\nprogram.getTypeChecker ->\n    ts.createTypeChecker (in checker)->\n        initializeTypeChecker (in checker) ->\n            for each SourceFile `ts.bindSourceFile` (in binder)\n            // followed by\n            for each SourceFile `ts.mergeSymbolTable` (in checker)\n```"}
{"id": "docs\\compiler\\checker.md#1", "content": "### Association with Emitter\nTrue type checking happens once a call is made to `getDiagnostics`. This function is called e.g. once a request is made to `Program.emit`, in which case the checker returns an `EmitResolver` (program calls the checkers `getEmitResolver` function) which is just a set of functions local to `createTypeChecker`. We will mention this again when we look at the emitter.\n\nHere is the call stack right down to `checkSourceFile` (a function local to `createTypeChecker`).\n\n```\nprogram.emit ->\n    emitWorker (program local) ->\n        createTypeChecker.getEmitResolver ->\n            // First call the following functions local to createTypeChecker\n            call getDiagnostics ->\n                getDiagnosticsWorker ->\n                    checkSourceFile\n\n            // then\n            return resolver\n            (already initialized in createTypeChecker using a call to local createResolver())\n```"}
{"id": "docs\\compiler\\contributing.md#0", "content": "## Contributing\n\nTypeScript is [OSS and on GitHub](https://github.com/Microsoft/TypeScript) and the team welcomes community input.\n\n### Setup\nSuper easy:\n\n```bash\ngit clone https://github.com/Microsoft/TypeScript.git\ncd TypeScript\nnpm install -g jake\nnpm install\n```\n\n### Setup Fork\nYou would obviously need to setup Microsoft/TypeScript as an `upstream` remote and your own *fork* (use the GitHub *fork* button) as `origin`:\n\n```bash\ngit remote rm origin\ngit remote rm upstream\ngit remote add upstream https://github.com/Microsoft/TypeScript.git\ngit remote add origin https://github.com/basarat/TypeScript.git\n```\nAdditionally I like to work off branches like `bas/` to have it show up cleaner in the branch listings.\n\n### Running Tests\nThere are lots of `test` and `build` options in their JakeFile. You can run *all* tests with `jake runtests`"}
{"id": "docs\\compiler\\contributing.md#1", "content": "### Baselines\nBaselines are used to manage if there are any changes in the *expected* output of the TypeScript compiler. Baselines are located in `tests/baselines`.\n\n* Reference (*expected*) baselines: `tests/baselines/reference`\n* Generated (*in this test run*) baselines : `tests/baselines/local` (this folder is in **.gitignore**)\n\n> If there are any differences between these folders tests will fail. You can diff the two folders with tools like BeyondCompare or KDiff3.\n\nIf you think these changes in generated files are valid then accept baselines using `jake baseline-accept`. The changes to `reference` baselines will now show as a git diff you can commit.\n\n> Note that if you don't run *all* tests then use `jake baseline-accept[soft]` which will only copy over the new files and not delete the whole `reference` directory.\n\n### Test Categories\n\nThere are different categories for different scenarios and even different test infrastructures. Here are a few of these explained."}
{"id": "docs\\compiler\\contributing.md#2", "content": "#### Compiler Tests\n\nThese ensure that compiling a file :\n\n* generates errors as expected\n* generated JS as expected\n* types are identified as expected\n* symbols are identified as expected\n\nThese expectations are validated using the baselines infrastructure.\n\n##### Creating a Compiler Test\nTest can be created by adding a new file `yourtest.ts` to `tests/cases/compiler`. As soon as you do so and run the tests you should get baseline failure. Accept these baselines (to get them to show up in git), and tweak them to be what you *expect* them to be ... now get the tests to pass.\n\nRun all of these in isolation using `jake runtests tests=compiler`, or just your new file using `jake runtests tests=compiler/yourtest`\n\nI will even often do `jake runtests tests=compiler/yourtest || jake baseline-accept[soft]` and get the diff in `git`.\n\n### Debugging Tests\n\n`jake runtests-browser tests=theNameOfYourTest` and debugging in-browser usually works pretty well."}
{"id": "docs\\compiler\\contributing.md#3", "content": "### More \n* An article by Remo : https://dev.to/remojansen/learn-how-to-contribute-to-the-typescript-compiler-on-github-through-a-real-world-example-4df0 \ud83c\udf39"}
{"id": "docs\\compiler\\emitter-functions.md#0", "content": "### `emitFiles`\nDefined in `emitter.ts` here is the function signature:\n```ts\n// targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature\nexport function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFile?: SourceFile): EmitResult {\n```\n\n`EmitHost` is just a simplified (as in narrowed down) version of `CompilerHost` (and is at runtime actually a `CompilerHost` for many use cases).\n\nThe most interesting call stack from `emitFiles` is the following:\n\n```\nemitFiles ->\n    emitFile(jsFilePath, targetSourceFile) ->\n        emitJavaScript(jsFilePath, targetSourceFile);\n```\n\n### `emitJavaScript`\nThere is a lot of good comments in this function so we present it below :"}
{"id": "docs\\compiler\\emitter-functions.md#1", "content": "```ts\nfunction emitJavaScript(jsFilePath: string, root?: SourceFile) {\n    let writer = createTextWriter(newLine);\n    let write = writer.write;\n    let writeTextOfNode = writer.writeTextOfNode;\n    let writeLine = writer.writeLine;\n    let increaseIndent = writer.increaseIndent;\n    let decreaseIndent = writer.decreaseIndent;\n\n    let currentSourceFile: SourceFile;\n    // name of an exporter function if file is a System external module\n    // System.register([...], function (<exporter>) {...})\n    // exporting in System modules looks like:\n    // export var x; ... x = 1\n    // =>\n    // var x;... exporter(\"x\", x = 1)\n    let exportFunctionForFile: string;\n\n    let generatedNameSet: Map<string> = {};\n    let nodeToGeneratedName: string[] = [];\n    let computedPropertyNamesToGeneratedNames: string[];"}
{"id": "docs\\compiler\\emitter-functions.md#2", "content": "let extendsEmitted = false;\n    let decorateEmitted = false;\n    let paramEmitted = false;\n    let awaiterEmitted = false;\n    let tempFlags = 0;\n    let tempVariables: Identifier[];\n    let tempParameters: Identifier[];\n    let externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];\n    let exportSpecifiers: Map<ExportSpecifier[]>;\n    let exportEquals: ExportAssignment;\n    let hasExportStars: boolean;\n\n    /** Write emitted output to disk */\n    let writeEmittedFiles = writeJavaScriptFile;\n\n    let detachedCommentsInfo: { nodePos: number; detachedCommentEndPos: number }[];\n\n    let writeComment = writeCommentRange;\n\n    /** Emit a node */\n    let emit = emitNodeWithoutSourceMap;\n\n    /** Called just before starting emit of a node */\n    let emitStart = function (node: Node) { };\n\n    /** Called once the emit of the node is done */\n    let emitEnd = function (node: Node) { };"}
{"id": "docs\\compiler\\emitter-functions.md#3", "content": "/** Emit the text for the given token that comes after startPos\n      * This by default writes the text provided with the given tokenKind\n      * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\n      * @param tokenKind the kind of the token to search and emit\n      * @param startPos the position in the source to start searching for the token\n      * @param emitFn if given will be invoked to emit the text instead of actual token emit */\n    let emitToken = emitTokenText;\n\n    /** Called to before starting the lexical scopes as in function/class in the emitted code because of node\n      * @param scopeDeclaration node that starts the lexical scope\n      * @param scopeName Optional name of this scope instead of deducing one from the declaration node */\n    let scopeEmitStart = function(scopeDeclaration: Node, scopeName?: string) { };\n\n    /** Called after coming out of the scope */\n    let scopeEmitEnd = function() { };"}
{"id": "docs\\compiler\\emitter-functions.md#4", "content": "/** Sourcemap data that will get encoded */\n    let sourceMapData: SourceMapData;\n\n    if (compilerOptions.sourceMap || compilerOptions.inlineSourceMap) {\n        initializeEmitterWithSourceMaps();\n    }\n\n    if (root) {\n        // Do not call emit directly. It does not set the currentSourceFile.\n        emitSourceFile(root);\n    }\n    else {\n        forEach(host.getSourceFiles(), sourceFile => {\n            if (!isExternalModuleOrDeclarationFile(sourceFile)) {\n                emitSourceFile(sourceFile);\n            }\n        });\n    }\n\n    writeLine();\n    writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);\n    return;\n\n    /// BUNCH OF LOCAL FUNCTIONS\n}\n```\n\nBasically it sets up a bunch of locals (these functions form the *bulk* of `emitter.ts`) and then hands off to a local function `emitSourceFile` which kicks off the emit. The `emitSourceFile` function just sets up the `currentSourceFile` and in turn hands off to a local `emit` function."}
{"id": "docs\\compiler\\emitter-functions.md#5", "content": "```ts\nfunction emitSourceFile(sourceFile: SourceFile): void {\n    currentSourceFile = sourceFile;\n    exportFunctionForFile = undefined;\n    emit(sourceFile);\n}\n```\n\nThe `emit` function handles *comment* emit + *actual JavaScript* emit. The *actual JavaScript* emit is the job of `emitJavaScriptWorker` function.\n\n### `emitJavaScriptWorker`"}
{"id": "docs\\compiler\\emitter-functions.md#6", "content": "The complete function:\n```ts\nfunction emitJavaScriptWorker(node: Node) {\n    // Check if the node can be emitted regardless of the ScriptTarget\n    switch (node.kind) {\n        case SyntaxKind.Identifier:\n            return emitIdentifier(<Identifier>node);\n        case SyntaxKind.Parameter:\n            return emitParameter(<ParameterDeclaration>node);\n        case SyntaxKind.MethodDeclaration:\n        case SyntaxKind.MethodSignature:\n            return emitMethod(<MethodDeclaration>node);\n        case SyntaxKind.GetAccessor:\n        case SyntaxKind.SetAccessor:\n            return emitAccessor(<AccessorDeclaration>node);\n        case SyntaxKind.ThisKeyword:\n            return emitThis(node);\n        case SyntaxKind.SuperKeyword:\n            return emitSuper(node);\n        case SyntaxKind.NullKeyword:\n            return write(\"null\");\n        case SyntaxKind.TrueKeyword:\n            return write(\"true\");\n        case SyntaxKind.FalseKeyword:\n            return write(\"false\");\n        case SyntaxKind.NumericLiteral:\n        case SyntaxKind.StringLiteral:\n        case SyntaxKind.RegularExpressionLiteral:\n        case SyntaxKind.NoSubstitutionTemplateLiteral:\n        case SyntaxKind.TemplateHead:\n        case SyntaxKind.TemplateMiddle:\n        case SyntaxKind.TemplateTail:\n            return emitLiteral(<LiteralExpression>node);\n        case SyntaxKind.TemplateExpression:\n            return emitTemplateExpression(<TemplateExpression>node);\n        case SyntaxKind.TemplateSpan:\n            return emitTemplateSpan(<TemplateSpan>node);\n        case SyntaxKind.JsxElement:\n        case SyntaxKind.JsxSelfClosingElement:\n            return emitJsxElement(<JsxElement|JsxSelfClosingElement>node);\n        case SyntaxKind.JsxText:\n            return emitJsxText(<JsxText>node);\n        case SyntaxKind.JsxExpression:\n            return emitJsxExpression(<JsxExpression>node);\n        case SyntaxKind.QualifiedName:\n            return emitQualifiedName(<QualifiedName>node);\n        case SyntaxKind.ObjectBindingPattern:\n            return emitObjectBindingPattern(<BindingPattern>node);\n        case SyntaxKind.ArrayBindingPattern:\n            return emitArrayBindingPattern(<BindingPattern>node);\n        case SyntaxKind.BindingElement:\n            return emitBindingElement(<BindingElement>node);\n        case SyntaxKind.ArrayLiteralExpression:\n            return emitArrayLiteral(<ArrayLiteralExpression>node);\n        case SyntaxKind.ObjectLiteralExpression:\n            return emitObjectLiteral(<ObjectLiteralExpression>node);\n        case SyntaxKind.PropertyAssignment:\n            return emitPropertyAssignment(<PropertyDeclaration>node);\n        case SyntaxKind.ShorthandPropertyAssignment:\n            return emitShorthandPropertyAssignment(<ShorthandPropertyAssignment>node);\n        case SyntaxKind.ComputedPropertyName:\n            return emitComputedPropertyName(<ComputedPropertyName>node);\n        case SyntaxKind.PropertyAccessExpression:\n            return emitPropertyAccess(<PropertyAccessExpression>node);\n        case SyntaxKind.ElementAccessExpression:\n            return emitIndexedAccess(<ElementAccessExpression>node);\n        case SyntaxKind.CallExpression:\n            return emitCallExpression(<CallExpression>node);\n        case SyntaxKind.NewExpression:\n            return emitNewExpression(<NewExpression>node);\n        case SyntaxKind.TaggedTemplateExpression:\n            return emitTaggedTemplateExpression(<TaggedTemplateExpression>node);\n        case SyntaxKind.TypeAssertionExpression:\n            return emit((<TypeAssertion>node).expression);\n        case SyntaxKind.AsExpression:\n            return emit((<AsExpression>node).expression);\n        case SyntaxKind.ParenthesizedExpression:\n            return emitParenExpression(<ParenthesizedExpression>node);\n        case SyntaxKind.FunctionDeclaration:\n        case SyntaxKind.FunctionExpression:\n        case SyntaxKind.ArrowFunction:\n            return emitFunctionDeclaration(<FunctionLikeDeclaration>node);\n        case SyntaxKind.DeleteExpression:\n            return emitDeleteExpression(<DeleteExpression>node);\n        case SyntaxKind.TypeOfExpression:\n            return emitTypeOfExpression(<TypeOfExpression>node);\n        case SyntaxKind.VoidExpression:\n            return emitVoidExpression(<VoidExpression>node);\n        case SyntaxKind.AwaitExpression:\n            return emitAwaitExpression(<AwaitExpression>node);\n        case SyntaxKind.PrefixUnaryExpression:\n            return emitPrefixUnaryExpression(<PrefixUnaryExpression>node);\n        case SyntaxKind.PostfixUnaryExpression:\n            return emitPostfixUnaryExpression(<PostfixUnaryExpression>node);\n        case SyntaxKind.BinaryExpression:\n            return emitBinaryExpression(<BinaryExpression>node);\n        case SyntaxKind.ConditionalExpression:\n            return emitConditionalExpression(<ConditionalExpression>node);\n        case SyntaxKind.SpreadElementExpression:\n            return emitSpreadElementExpression(<SpreadElementExpression>node);\n        case SyntaxKind.YieldExpression:\n            return emitYieldExpression(<YieldExpression>node);\n        case SyntaxKind.OmittedExpression:\n            return;\n        case SyntaxKind.Block:\n        case SyntaxKind.ModuleBlock:\n            return emitBlock(<Block>node);\n        case SyntaxKind.VariableStatement:\n            return emitVariableStatement(<VariableStatement>node);\n        case SyntaxKind.EmptyStatement:\n            return write(\";\");\n        case SyntaxKind.ExpressionStatement:\n            return emitExpressionStatement(<ExpressionStatement>node);\n        case SyntaxKind.IfStatement:\n            return emitIfStatement(<IfStatement>node);\n        case SyntaxKind.DoStatement:\n            return emitDoStatement(<DoStatement>node);\n        case SyntaxKind.WhileStatement:\n            return emitWhileStatement(<WhileStatement>node);\n        case SyntaxKind.ForStatement:\n            return emitForStatement(<ForStatement>node);\n        case SyntaxKind.ForOfStatement:\n        case SyntaxKind.ForInStatement:\n            return emitForInOrForOfStatement(<ForInStatement>node);\n        case SyntaxKind.ContinueStatement:\n        case SyntaxKind.BreakStatement:\n            return emitBreakOrContinueStatement(<BreakOrContinueStatement>node);\n        case SyntaxKind.ReturnStatement:\n            return emitReturnStatement(<ReturnStatement>node);\n        case SyntaxKind.WithStatement:\n            return emitWithStatement(<WithStatement>node);\n        case SyntaxKind.SwitchStatement:\n            return emitSwitchStatement(<SwitchStatement>node);\n        case SyntaxKind.CaseClause:\n        case SyntaxKind.DefaultClause:\n            return emitCaseOrDefaultClause(<CaseOrDefaultClause>node);\n        case SyntaxKind.LabeledStatement:\n            return emitLabelledStatement(<LabeledStatement>node);\n        case SyntaxKind.ThrowStatement:\n            return emitThrowStatement(<ThrowStatement>node);\n        case SyntaxKind.TryStatement:\n            return emitTryStatement(<TryStatement>node);\n        case SyntaxKind.CatchClause:\n            return emitCatchClause(<CatchClause>node);\n        case SyntaxKind.DebuggerStatement:\n            return emitDebuggerStatement(node);\n        case SyntaxKind.VariableDeclaration:\n            return emitVariableDeclaration(<VariableDeclaration>node);\n        case SyntaxKind.ClassExpression:\n            return emitClassExpression(<ClassExpression>node);\n        case SyntaxKind.ClassDeclaration:\n            return emitClassDeclaration(<ClassDeclaration>node);\n        case SyntaxKind.InterfaceDeclaration:\n            return emitInterfaceDeclaration(<InterfaceDeclaration>node);\n        case SyntaxKind.EnumDeclaration:\n            return emitEnumDeclaration(<EnumDeclaration>node);\n        case SyntaxKind.EnumMember:\n            return emitEnumMember(<EnumMember>node);\n        case SyntaxKind.ModuleDeclaration:\n            return emitModuleDeclaration(<ModuleDeclaration>node);\n        case SyntaxKind.ImportDeclaration:\n            return emitImportDeclaration(<ImportDeclaration>node);\n        case SyntaxKind.ImportEqualsDeclaration:\n            return emitImportEqualsDeclaration(<ImportEqualsDeclaration>node);\n        case SyntaxKind.ExportDeclaration:\n            return emitExportDeclaration(<ExportDeclaration>node);\n        case SyntaxKind.ExportAssignment:\n            return emitExportAssignment(<ExportAssignment>node);\n        case SyntaxKind.SourceFile:\n            return emitSourceFileNode(<SourceFile>node);\n    }\n}\n```"}
{"id": "docs\\compiler\\emitter-functions.md#7", "content": "Recursion is done by simply calling other `emitFoo` function from these functions as needed e.g. from `emitFunctionDeclaration` :\n```ts\nfunction emitFunctionDeclaration(node: FunctionLikeDeclaration) {\n    if (nodeIsMissing(node.body)) {\n        return emitOnlyPinnedOrTripleSlashComments(node);\n    }\n\n    if (node.kind !== SyntaxKind.MethodDeclaration && node.kind !== SyntaxKind.MethodSignature) {\n        // Methods will emit the comments as part of emitting method declaration\n        emitLeadingComments(node);\n    }\n\n    // For targeting below es6, emit functions-like declaration including arrow function using function keyword.\n    // When targeting ES6, emit arrow function natively in ES6 by omitting function keyword and using fat arrow instead\n    if (!shouldEmitAsArrowFunction(node)) {\n        if (isES6ExportedDeclaration(node)) {\n            write(\"export \");\n            if (node.flags & NodeFlags.Default) {\n                write(\"default \");\n            }\n        }"}
{"id": "docs\\compiler\\emitter-functions.md#8", "content": "write(\"function\");\n        if (languageVersion >= ScriptTarget.ES6 && node.asteriskToken) {\n            write(\"*\");\n        }\n        write(\" \");\n    }\n\n    if (shouldEmitFunctionName(node)) {\n        emitDeclarationName(node);\n    }\n\n    emitSignatureAndBody(node);\n    if (languageVersion < ScriptTarget.ES6 && node.kind === SyntaxKind.FunctionDeclaration && node.parent === currentSourceFile && node.name) {\n        emitExportMemberAssignments((<FunctionDeclaration>node).name);\n    }\n    if (node.kind !== SyntaxKind.MethodDeclaration && node.kind !== SyntaxKind.MethodSignature) {\n        emitTrailingComments(node);\n    }\n}\n```"}
{"id": "docs\\compiler\\emitter-sourcemaps.md#0", "content": "### Emitter SourceMaps\n\nWe said that the bulk of the `emitter.ts` is the local function `emitJavaScript` (we showed the initialization routine of this function before). It basically sets up a bunch of locals and hits off to `emitSourceFile`. The following is a revisiting of the function, this time focusing on `SourceMap` stuff:\n\n```ts\nfunction emitJavaScript(jsFilePath: string, root?: SourceFile) {\n\n    // STUFF ........... removed\n\n    let writeComment = writeCommentRange;\n\n    /** Write emitted output to disk */\n    let writeEmittedFiles = writeJavaScriptFile;\n\n    /** Emit a node */\n    let emit = emitNodeWithoutSourceMap;\n\n    /** Called just before starting emit of a node */\n    let emitStart = function (node: Node) { };\n\n    /** Called once the emit of the node is done */\n    let emitEnd = function (node: Node) { };"}
{"id": "docs\\compiler\\emitter-sourcemaps.md#1", "content": "/** Emit the text for the given token that comes after startPos\n      * This by default writes the text provided with the given tokenKind\n      * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\n      * @param tokenKind the kind of the token to search and emit\n      * @param startPos the position in the source to start searching for the token\n      * @param emitFn if given will be invoked to emit the text instead of actual token emit */\n    let emitToken = emitTokenText;\n\n    /** Called to before starting the lexical scopes as in function/class in the emitted code because of node\n      * @param scopeDeclaration node that starts the lexical scope\n      * @param scopeName Optional name of this scope instead of deducing one from the declaration node */\n    let scopeEmitStart = function(scopeDeclaration: Node, scopeName?: string) { };\n\n    /** Called after coming out of the scope */\n    let scopeEmitEnd = function() { };"}
{"id": "docs\\compiler\\emitter-sourcemaps.md#2", "content": "/** Sourcemap data that will get encoded */\n    let sourceMapData: SourceMapData;\n\n    if (compilerOptions.sourceMap || compilerOptions.inlineSourceMap) {\n        initializeEmitterWithSourceMaps();\n    }\n\n    if (root) {\n        // Do not call emit directly. It does not set the currentSourceFile.\n        emitSourceFile(root);\n    }\n    else {\n        forEach(host.getSourceFiles(), sourceFile => {\n            if (!isExternalModuleOrDeclarationFile(sourceFile)) {\n                emitSourceFile(sourceFile);\n            }\n        });\n    }\n\n    writeLine();\n    writeEmittedFiles(writer.getText(), /*writeByteOrderMark*/ compilerOptions.emitBOM);\n    return;\n\n    /// BUNCH OF LOCAL FUNCTIONS\n```\n\nThe important function call here : `initializeEmitterWithSourceMaps` which is a function local to `emitJavaScript` that overrides some locals that were already defined here. At the bottom of `initializeEmitterWithSourceMaps` you will notice the overriding:"}
{"id": "docs\\compiler\\emitter-sourcemaps.md#3", "content": "```ts\n    // end of `initializeEmitterWithSourceMaps`\n\n    writeEmittedFiles = writeJavaScriptAndSourceMapFile;\n    emit = emitNodeWithSourceMap;\n    emitStart = recordEmitNodeStartSpan;\n    emitEnd = recordEmitNodeEndSpan;\n    emitToken = writeTextWithSpanRecord;\n    scopeEmitStart = recordScopeNameOfNode;\n    scopeEmitEnd = recordScopeNameEnd;\n    writeComment = writeCommentRangeWithMap;\n```\n\nThis means that the bulk of emitter code can not care about `SourceMap` and just use these local functions the same way with or without SourceMaps."}
{"id": "docs\\compiler\\emitter.md#0", "content": "## Emitter\nThere are two `emitters` provided with the TypeScript compiler:\n\n* `emitter.ts`: this is the emitter you are most likely to be interested in. Its the TS -> JavaScript emitter.\n* `declarationEmitter.ts`: this is the emitter used to create a *declaration file* (a `.d.ts`) for a *TypeScript source file* (a `.ts` file).\n\nWe will look at `emitter.ts` in this section.\n\n### Usage by `program`\nProgram provides an `emit` function. This function primarily delegates to `emitFiles` function in `emitter.ts`. Here is the call stack:\n\n```\nProgram.emit ->\n    `emitWorker` (local in program.ts createProgram) ->\n        `emitFiles` (function in emitter.ts)\n```\nOne thing that the `emitWorker` provides to the emitter (via an argument to `emitFiles`) is an `EmitResolver`. `EmitResolver` is provided by the program's TypeChecker, basically it is a subset of *local* functions from `createChecker`."}
{"id": "docs\\compiler\\make-global.md#0", "content": "## Make TypeScript Global\n\nTypeScript is written using a `namespace ts`. And then the whole compiler is compiled into a single `typescript.js` file. If you want to copy over parts of the source code for exploration a great way to do that is to copy over the portions that you are exploring and then expose them to the global variable `ts`.\n\nA great way to play around with the TypeScript compiler is just to copy the TypeScript compiler source into a folder and then reference it as a `global` variable."}
{"id": "docs\\compiler\\overview.md#0", "content": "# Compiler\nThe TypeScript compiler source is located under the [`src/compiler`](https://github.com/Microsoft/TypeScript/tree/master/src/compiler) folder.\n\nIt is split into the follow key parts:\n* Scanner (`scanner.ts`)\n* Parser (`parser.ts`)\n* Binder (`binder.ts`)\n* Checker (`checker.ts`)\n* Emitter (`emitter.ts`)\n\nEach of these get their own unique files in the source. These parts will be explained later on in this chapter. \n\n## Syntax vs. Semantics\nJust because something is *syntactically* correct doesn't mean it is *semantically* correct. Consider the following piece of TypeScript code which although *syntactically* valid is *semantically* wrong\n\n```ts\nvar foo: number = \"not a number\";\n```\n\n`Semantic` means \"meaning\" in English. This concept is useful to have in your head.\n\n## Processing Overview\nThe following is a quick review of how these key parts of the TypeScript compiler compose:\n\n```code\nSourceCode ~~ scanner ~~> Token Stream\n```\n\n```code\nToken Stream ~~ parser ~~> AST\n```"}
{"id": "docs\\compiler\\overview.md#1", "content": "```code\nAST ~~ binder ~~> Symbols\n```\n`Symbol` is the primary building block of the TypeScript *semantic* system. As shown the symbols are created as a result of binding. Symbols connect declaration nodes in the AST to other declarations contributing to the same entity.\n\nSymbols + AST are what is used by the checker to *semantically* validate the source code\n```code\nAST + Symbols ~~ checker ~~> Type Validation\n```\n\nFinally When a JS output is requested:\n```code\nAST + Checker ~~ emitter ~~> JS\n```\n\nThere are a few additional files in the TypeScript compiler that provide utilities to many of these key portions which we cover next.\n\n## File: Utilities\n`core.ts` : core utilities used by the TypeScript compiler. A few important ones:"}
{"id": "docs\\compiler\\overview.md#2", "content": "* `let objectAllocator: ObjectAllocator` : is a variable defined as a singleton global. It provides the definitions for `getNodeConstructor` (Nodes are covered when we look at `parser` / `AST`), `getSymbolConstructor` (Symbols are covered in `binder`), `getTypeConstructor` (Types are covered in `checker`), `getSignatureConstructor` (Signatures are the index, call and construct signatures).\n\n## File: Key Data Structures\n`types.ts` contains key data structures and interfaces uses throughout the compiler. Here is a sampling of a few key ones:\n* `SyntaxKind`\nThe AST node type is identified by the `SyntaxKind` enum.\n* `TypeChecker`\nThis is the interface provided by the TypeChecker.\n* `CompilerHost`\nThis is used by the `Program` to interact with the `System`.\n* `Node`\nAn AST node."}
{"id": "docs\\compiler\\overview.md#3", "content": "## File: System\n`system.ts`. All interaction of the TypeScript compiler with the operating system goes through a `System` interface. Both the interface and its implementations (`WScript` and `Node`) are defined in `system.ts`. You can think of it as the *Operating Environment* (OE).\n\nNow that you have an overview of the major files, we can look at the concept of `Program`"}
{"id": "docs\\compiler\\parser-functions.md#0", "content": "### Parser Functions\n\nAs mentioned `parseSourceFile` sets up the initial state and passes the work onto `parseSourceFileWorker` function.\n\n#### `parseSourceFileWorker`\n\nStarts by creating a `SourceFile` AST node. Then it goes into parsing source code starting from the `parseStatements` function. Once that returns, it then completes the `SourceFile` node with additional information such as its `nodeCount`, `identifierCount` and such.\n\n#### `parseStatements`\nOne of the most significant `parseFoo` style functions (a concept we cover next). It switches by the current `token` returned from the scanner. E.g. if the current token is a `SemicolonToken` it will call out to `parseEmptyStatement` to create an AST node for an empty statement.\n\n### Node creation"}
{"id": "docs\\compiler\\parser-functions.md#1", "content": "The parser has a bunch of `parserFoo` functions with bodies that create `Foo` nodes. These are generally called (from other parser functions) at a time where a `Foo` node is expected. A typical sample of this process is the `parseEmptyStatement()` function which is used to parse out empty statements like `;;;;;;`. Here is the function in its entirety\n\n```ts\nfunction parseEmptyStatement(): Statement {\n    let node = <Statement>createNode(SyntaxKind.EmptyStatement);\n    parseExpected(SyntaxKind.SemicolonToken);\n    return finishNode(node);\n}\n```\n\nIt shows three critical functions `createNode`, `parseExpected` and `finishNode`.\n\n#### `createNode`\nThe parser's `createNode` function `function createNode(kind: SyntaxKind, pos?: number): Node` is responsible for creating a Node, setting up its `SyntaxKind` as passed in, and set the initial position if passed in (or use the position from the current scanner state)."}
{"id": "docs\\compiler\\parser-functions.md#2", "content": "#### `parseExpected`\nThe parser's `parseExpected` function `function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage): boolean` will check that the current token in the parser state matches the desired `SyntaxKind`. If not it will either report the `diagnosticMessage` sent in or create a generic one of the form `foo expected`. It internally uses the `parseErrorAtPosition` function (which uses the scanning positions) to give good error reporting.\n\n### `finishNode`\nThe parser's `finishNode` function `function finishNode<T extends Node>(node: T, end?: number): T` sets up the `end` position for the node and additional useful stuff like the `parserContextFlags` it was parsed under as well as if there were any errors before parsing this node (if there were then we cannot reuse this AST node in incremental parsing)."}
{"id": "docs\\compiler\\parser.md#0", "content": "## Parser\nThe sourcecode for the TypeScript parser is located entirely in `parser.ts`. Scanner is *controlled* internally by the `Parser` to convert the source code to an AST. Here is a review of what the desired outcome is.\n\n```\nSourceCode ~~ scanner ~~> Token Stream ~~ parser ~~> AST\n```\n\nThe parser is implemented as a singleton (similar reasons to `scanner`, don't want to recreate it if we can reinit it). It is actually implemented as `namespace Parser` which contains *state* variables for the Parser as well as a singleton `scanner`. As mentioned before it contains a `const scanner`. The parser functions manage this scanner.\n\n### Usage by program\nParser is driven indirectly by Program (indirectly as its actually by `CompilerHost` which we mentioned previously). Basically this is the simplified call stack:\n\n```\nProgram ->\n    CompilerHost.getSourceFile ->\n        (global function parser.ts).createSourceFile ->\n            Parser.parseSourceFile\n```"}
{"id": "docs\\compiler\\parser.md#1", "content": "The `parseSourceFile` not only primes the state for the Parser but also primes the state for the `scanner` by calling `initializeState`. It then goes on to parse the source file using `parseSourceFileWorker`.\n\n### Sample Usage\nBefore we dig too deep into the parser internals, here is a sample code that uses the TypeScript's parser to get the AST of a source file (using `ts.createSourceFile`), and then print it.\n\n`code/compiler/parser/runParser.ts`\n```ts\nimport * as ts from \"ntypescript\";\n\nfunction printAllChildren(node: ts.Node, depth = 0) {\n    console.log(new Array(depth + 1).join('----'), ts.formatSyntaxKind(node.kind), node.pos, node.end);\n    depth++;\n    node.getChildren().forEach(c=> printAllChildren(c, depth));\n}\n\nvar sourceCode = `\nvar foo = 123;\n`.trim();\n\nvar sourceFile = ts.createSourceFile('foo.ts', sourceCode, ts.ScriptTarget.ES5, true);\nprintAllChildren(sourceFile);\n```\n\nThis will print out the following:"}
{"id": "docs\\compiler\\parser.md#2", "content": "```ts\nSourceFile 0 14\n---- SyntaxList 0 14\n-------- VariableStatement 0 14\n------------ VariableDeclarationList 0 13\n---------------- VarKeyword 0 3\n---------------- SyntaxList 3 13\n-------------------- VariableDeclaration 3 13\n------------------------ Identifier 3 7\n------------------------ FirstAssignment 7 9\n------------------------ FirstLiteralToken 9 13\n------------ SemicolonToken 13 14\n---- EndOfFileToken 14 14\n```\nThis looks like a (very right sided) tree if you tilt your head to the left."}
{"id": "docs\\compiler\\program.md#0", "content": "## Program\n\nDefined in `program.ts`. The compilation context ([a concept we covered previously](../project/compilation-context.md)) is represented within the TypeScript compiler as a `Program`. It consists of `SourceFile`s and compiler options.\n\n\n### Usage of `CompilerHost`\nIts interaction mechanism with the OE:\n\n`Program` *-uses->* `CompilerHost` *-uses->* `System`\n\nThe reason for having a `CompilerHost` as a point of indirection is that it allows its interface to be more finely tuned for `Program` needs and not bother with OE needs (e.g. the `Program` doesn't care about `fileExists` a function provided by `System`).\n\nThere are other users of `System` as well (e.g. tests).\n\n### SourceFile\n\nThe program provides an API to get the Source Files `getSourceFiles(): SourceFile[];`. Each is represented as a root-level node for an AST (called `SourceFile`)."}
{"id": "docs\\compiler\\scanner.md#0", "content": "## Scanner\nThe source code for the TypeScript scanner is located entirely in `scanner.ts`. Scanner is *controlled* internally by the `Parser` to convert the source code to an AST. Here is what the desired outcome is.\n\n```\nSourceCode ~~ scanner ~~> Token Stream ~~ parser ~~> AST\n```\n\n### Usage by Parser\nThere is a *singleton* `scanner` created in `parser.ts` to avoid the cost of creating scanners over and over again. This scanner is then *primed* by the parser on demand using the `initializeState` function.\n\nHere is a *simplied* version of the actual code in the parser that you can run demonstrating this concept:\n\n`code/compiler/scanner/runScanner.ts`\n```ts\nimport * as ts from \"ntypescript\";\n\n// TypeScript has a singleton scanner\nconst scanner = ts.createScanner(ts.ScriptTarget.Latest, /*skipTrivia*/ true);"}
{"id": "docs\\compiler\\scanner.md#1", "content": "// That is initialized using a function `initializeState` similar to\nfunction initializeState(text: string) {\n    scanner.setText(text);\n    scanner.setOnError((message: ts.DiagnosticMessage, length: number) => {\n        console.error(message);\n    });\n    scanner.setScriptTarget(ts.ScriptTarget.ES5);\n    scanner.setLanguageVariant(ts.LanguageVariant.Standard);\n}\n\n// Sample usage\ninitializeState(`\nvar foo = 123;\n`.trim());\n\n// Start the scanning\nvar token = scanner.scan();\nwhile (token != ts.SyntaxKind.EndOfFileToken) {\n    console.log(ts.formatSyntaxKind(token));\n    token = scanner.scan();\n}\n```\n\nThis will print out the following :\n\n```\nVarKeyword\nIdentifier\nFirstAssignment\nFirstLiteralToken\nSemicolonToken\n```"}
{"id": "docs\\compiler\\scanner.md#2", "content": "### Scanner State\nAfter you call `scan` the scanner updates its local state (position in the scan, current token details etc). The scanner provides a bunch of utility functions to get the current scanner state. In the below sample we create a scanner and then use it to identify the tokens as well as their positions in the code.\n\n`code/compiler/scanner/runScannerWithPosition.ts`\n```ts\n// Sample usage\ninitializeState(`\nvar foo = 123;\n`.trim());\n\n// Start the scanning\nvar token = scanner.scan();\nwhile (token != ts.SyntaxKind.EndOfFileToken) {\n    let currentToken = ts.formatSyntaxKind(token);\n    let tokenStart = scanner.getStartPos();\n    token = scanner.scan();\n    let tokenEnd = scanner.getStartPos();\n    console.log(currentToken, tokenStart, tokenEnd);\n}\n```\n\nThis will print out the following:\n```\nVarKeyword 0 3\nIdentifier 3 7\nFirstAssignment 7 9\nFirstLiteralToken 9 13\nSemicolonToken 13 14\n```"}
{"id": "docs\\compiler\\scanner.md#3", "content": "### Standalone scanner\nEven though the TypeScript parser has a singleton scanner you can create a standalone scanner using `createScanner` and use its `setText`/`setTextPos` to scan at different points in a file for your amusement."}
{"id": "docs\\errors\\common-errors.md#0", "content": "# Common Errors\nIn this section we explain a number of common error codes that users experience in the real world.\n\n## TS2304\nSamples:\n> `Cannot find name ga`\n> `Cannot find name $`\n> `Cannot find module jquery`\n\nYou are probably using a third party library (e.g. google analytics) and don't have it `declare`d. TypeScript tries to save you from *spelling mistakes* and *using variables without declaring them* so you need to be explicit on anything that is *available at runtime* because of you including some external library ([more on how to fix it][ambient]).\n\n## TS2307\nSamples:\n> `Cannot find module 'underscore'`\n\nYou are probably using a third party library (e.g. underscore) as a *module* ([more on modules][modules]) and don't have the ambient declaration file for it ([more on ambient declarations][ambient]).\n\n## TS1148\nSample:\n> Cannot compile modules unless the '--module' flag is provided\n\nCheckout the [section on modules][modules]."}
{"id": "docs\\errors\\common-errors.md#1", "content": "## Catch clause variable cannot have a type annotation\nSample:\n```js\ntry { something(); }\ncatch (e: Error) { // Catch clause variable cannot have a type annotation\n}\n```\nTypeScript is protecting you from JavaScript code in the wild being wrong. Use a type guard instead:\n```js\ntry { something(); }\ncatch (e) {\n  if (e instanceof Error){\n    // Here you go.\n  }\n}\n```\n\n## Interface `ElementClass` cannot simultaneously extend types `Component` and `Component`\nThis happens when you have two `react.d.ts` (`@types/react/index.d.ts`) in the compilation context.\n\n**Fix**:\n* Delete `node_modules` and any `package-lock` (or yarn lock) and `npm install` again.\n* If it doesn't work, find the invalid module (all modules used by your project should have `react.d.ts` as a `peerDependency` and not a hard `dependency`) and report it on their project.\n\n\n[ambient]: ../types/ambient/d.ts.md\n[modules]: ../project/modules.md"}
{"id": "docs\\errors\\interpreting-errors.md#0", "content": "# Interpreting Errors \nSince TypeScript is a heavily focused *Developer Help* oriented programming language, its errors messages try to be super helpful when something goes wrong. This can lead to a slight information overload for unsuspecting users of compilers that aren't so helpful. \n\nLets look at an example in an IDE to break apart the process of reading an error message. \n\n```ts\ntype SomethingComplex = {\n  foo: number,\n  bar: string\n}\nfunction takeSomethingComplex(arg: SomethingComplex) {\n}\nfunction getBar(): string {\n  return 'some bar';\n}\n\n//////////////////////////////////\n// Example error production\n//////////////////////////////////\nconst fail = {\n  foo: 123,\n  bar: getBar\n};\n\ntakeSomethingComplex(fail); // TS ERROR HAPPENS HERE \n```\n\nThis example demonstrates a common programmer error where they *fail* to call a function (`bar: getBar` should be `bar: getBar()`). Fortunately this mistake is caught by TypeScript as soon as it doesn't meet the type requirements."}
{"id": "docs\\errors\\interpreting-errors.md#1", "content": "## Error Categories\nThere are two categories of TypeScript Error messages (succinct and detailed). \n\n### Succinct\nThe objective of the succinct error message is to provide an example *conventional compiler* description of the error number and message. For this example the succinct message looks like: \n\n```\nTS2345: Argument of type '{ foo: number; bar: () => string; }' is not assignable to parameter of type 'SomethingComplex'.\n```\nIt is fairly self explanatory. However, it doesn't provide a deeper breakdown of *why* the error is happening. That is what the *detailed* error message is for.\n\n### Detailed\nFor this example the detailed version looks like:"}
{"id": "docs\\errors\\interpreting-errors.md#2", "content": "```\n[ts]\nArgument of type '{ foo: number; bar: () => string; }' is not assignable to parameter of type 'SomethingComplex'.\n  Types of property 'bar' are incompatible.\n    Type '() => string' is not assignable to type 'string'.\n```\nThe objective of the detailed error message is to *guide* the user to the reason why some error (type incompatibility in this case) is happening. The first line is same as the succinct, followed by a chain. You should read this chain as a series of responses to the developer question `WHY?` between lines i.e \n\n```\nERROR: Argument of type '{ foo: number; bar: () => string; }' is not assignable to parameter of type 'SomethingComplex'.\n\nWHY? \nCAUSE ERROR: Types of property 'bar' are incompatible.\n\nWHY? \nCAUSE ERROR: Type '() => string' is not assignable to type 'string'.\n```\n\nSo the root cause is,\n* for property `bar`\n* there is a function `() => string` while it was expected as a `string`."}
{"id": "docs\\errors\\interpreting-errors.md#3", "content": "This should help the developer fix the bug for the `bar` property (they forgot to invoke `()` the function).\n\n## How it shows up in an IDE Tooltip \n\nThe IDE normally shows the `detailed` followed by the `succinct` version in a tooltip as shown below: \n\n![IDE error message example](https://raw.githubusercontent.com/basarat/typescript-book/master/images/errors/interpreting-errors/ide.png)\n\n* You normally just read the `detailed` version forming the `WHY?` chain in your head. \n* You use the succinct version if you want to search for similar errors (using the `TSXXXX` error code or portions of the error message)"}
{"id": "docs\\errors\\main.md#0", "content": "# Errors \nIn this section we discuss how to read and understand TypeScript errors. We follow this with common errors and their solutions."}
{"id": "docs\\javascript\\closure.md#0", "content": "## Closure\n\nThe best thing that JavaScript ever got was closures. A function in JavaScript has access to any variables defined in the outer scope. Closures are best explained with examples:\n\n```ts\nfunction outerFunction(arg) {\n    var variableInOuterFunction = arg;\n\n    function bar() {\n        console.log(variableInOuterFunction); // Access a variable from the outer scope\n    }\n\n    // Call the local function to demonstrate that it has access to arg\n    bar();\n}\n\nouterFunction(\"hello closure\"); // logs hello closure!\n```\n\nYou can see that the inner function has access to a variable (variableInOuterFunction) from the outer scope. The variables in the outer function have been closed by (or bound in) the inner function. Hence the term **closure**. The concept in itself is simple enough and pretty intuitive."}
{"id": "docs\\javascript\\closure.md#1", "content": "Now the awesome part: The inner function can access the variables from the outer scope *even after the outer function has returned*. This is because the variables are still bound in the inner function and not dependent on the outer function. Again let's look at an example:\n\n```ts\nfunction outerFunction(arg) {\n    var variableInOuterFunction = arg;\n    return function() {\n        console.log(variableInOuterFunction);\n    }\n}\n\nvar innerFunction = outerFunction(\"hello closure!\");\n\n// Note the outerFunction has returned\ninnerFunction(); // logs hello closure!\n```\n\n### Reason why it's awesome\nIt allows you to compose objects easily e.g. the revealing module pattern:\n\n```ts\nfunction createCounter() {\n    let val = 0;\n    return {\n        increment() { val++ },\n        getVal() { return val }\n    }\n}\n\nlet counter = createCounter();\ncounter.increment();\nconsole.log(counter.getVal()); // 1\ncounter.increment();\nconsole.log(counter.getVal()); // 2\n```"}
{"id": "docs\\javascript\\closure.md#2", "content": "At a high level it is also what makes something like Node.js possible (don't worry if it doesn't click in your brain right now. It will eventually \ud83c\udf39):\n\n```ts\n// Pseudo code to explain the concept\nserver.on(function handler(req, res) {\n    loadData(req.id).then(function(data) {\n        // the `res` has been closed over and is available\n        res.send(data);\n    })\n});\n```"}
{"id": "docs\\javascript\\equality.md#0", "content": "## Equality\n\nOne thing to be careful about in JavaScript is the difference between `==` and `===`. As JavaScript tries to\nbe resilient against programming errors `==` tries to do type coercion between two variables e.g. converts a\nstring to a number so that you can compare with a number as shown below:\n\n```js\nconsole.log(5 == \"5\"); // true   , TS Error\nconsole.log(5 === \"5\"); // false , TS Error\n```\n\nHowever, the choices JavaScript makes are not always ideal. For example, in the below example the first statement is false\nbecause `\"\"` and `\"0\"` are both strings and are clearly not equal. However, in the second case both `0` and the\nempty string (`\"\"`) are falsy (i.e. behave like `false`) and are therefore equal with respect to `==`. Both statements\nare false when you use `===`.\n\n```js\nconsole.log(\"\" == \"0\"); // false\nconsole.log(0 == \"\"); // true\n\nconsole.log(\"\" === \"0\"); // false\nconsole.log(0 === \"\"); // false\n```"}
{"id": "docs\\javascript\\equality.md#1", "content": "> Note that `string == number` and `string === number` are both compile time errors in TypeScript, so you don't normally need to worry about this.\n\nSimilar to `==` vs. `===`, there is `!=` vs. `!==`\n\nSo ProTip: Always use `===` and `!==` except for null checks, which we cover later.\n\n## Structural Equality \nIf you want to compare two objects for structural equality `==`/`===` are ***not*** sufficient. e.g. \n\n```js\nconsole.log({a:123} == {a:123}); // False\nconsole.log({a:123} === {a:123}); // False\n```\nTo do such checks use the [deep-equal](https://www.npmjs.com/package/deep-equal) npm package e.g. \n\n```js\nimport * as deepEqual from \"deep-equal\";\n\nconsole.log(deepEqual({a:123},{a:123})); // True\n```\n\nHowever, quite commonly you don't need deep checks and all you really need is to check by some `id` e.g."}
{"id": "docs\\javascript\\equality.md#2", "content": "```ts\ntype IdDisplay = {\n  id: string,\n  display: string\n}\nconst list: IdDisplay[] = [\n  {\n    id: 'foo',\n    display: 'Foo Select'\n  },\n  {\n    id: 'bar',\n    display: 'Bar Select'\n  },\n]\n\nconst fooIndex = list.map(i => i.id).indexOf('foo');\nconsole.log(fooIndex); // 0\n```"}
{"id": "docs\\javascript\\null-undefined.md#0", "content": "## Null and Undefined\n\n> [Free youtube video on the subject](https://www.youtube.com/watch?v=kaUfBNzuUAI)\n\nJavaScript (and by extension TypeScript) has two bottom types : `null` and `undefined`. They are *intended* to mean different things:\n\n* Something hasn't been initialized : `undefined`.\n* Something is currently unavailable: `null`.\n\n\n### Checking for either\n\nFact is you will need to deal with both. Interestingly in JavaScript with `==`, `null` and `undefined` are only equal to each other:\n\n```ts\n// Both null and undefined are only `==` to themselves and each other:\nconsole.log(null == null); // true (of course)\nconsole.log(undefined == undefined); // true (of course)\nconsole.log(null == undefined); // true"}
{"id": "docs\\javascript\\null-undefined.md#1", "content": "// You don't have to worry about falsy values making through this check\nconsole.log(0 == undefined); // false\nconsole.log('' == undefined); // false\nconsole.log(false == undefined); // false\n```\nRecommend `== null` to check for both `undefined` or `null`. You generally don't want to make a distinction between the two.\n\n```ts\nfunction foo(arg: string | null | undefined) {\n  if (arg != null) {\n    // arg must be a string as `!=` rules out both null and undefined. \n  }\n}\n```\n\n> You could also do `== undefined`, but `== null` is more conventional/shorter.\n\nOne exception, root level `undefined` values which we discuss next.\n\n### Checking for root level undefined\n\nRemember how I said you should use `== null`? Of course you do (cause I just said it ^). Don't use it for root level things. In strict mode if you use `foo` and `foo` is undefined you get a `ReferenceError` **exception** and the whole call stack unwinds."}
{"id": "docs\\javascript\\null-undefined.md#2", "content": "> You should use strict mode ... and in fact the TS compiler will insert it for you if you use modules ... more on those later in the book so you don't have to be explicit about it :)\n\nSo to check if a variable is defined or not at a *global* level you normally use `typeof`:\n\n```ts\nif (typeof someglobal !== 'undefined') {\n  // someglobal is now safe to use\n  console.log(someglobal);\n}\n```\n\n### Limit explicit use of `undefined`\nBecause TypeScript gives you the opportunity to *document* your structures separately from values instead of stuff like:\n```ts\nfunction foo(){\n  // if Something\n  return {a:1,b:2};\n  // else\n  return {a:1,b:undefined};\n}\n```\nyou should use a type annotation:\n```ts\nfunction foo():{a:number,b?:number}{\n  // if Something\n  return {a:1,b:2};\n  // else\n  return {a:1};\n}\n```"}
{"id": "docs\\javascript\\null-undefined.md#3", "content": "### Node style callbacks\nNode style callback functions (e.g. `(err,somethingElse)=>{ /* something */ }`) are generally called with `err` set to `null` if there isn't an error. You generally just use a truthy check for this anyways:\n\n```ts\nfs.readFile('someFile', 'utf8', (err,data) => {\n  if (err) {\n    // do something\n  } else {\n    // no error\n  }\n});\n```\nWhen creating your own APIs it's *okay* to use `null` in this case for consistency. In all sincerity for your own APIs you should look at promises, in that case you actually don't need to bother with absent error values (you handle them with `.then` vs. `.catch`).\n\n### Don't use `undefined` as a means of denoting *validity*\n\nFor example an awful function like this:"}
{"id": "docs\\javascript\\null-undefined.md#4", "content": "```ts\nfunction toInt(str: string) {\n  return str ? parseInt(str) : undefined;\n}\n```\ncan be much better written like this:\n```ts\nfunction toInt(str: string): { valid: boolean, int?: number } {\n  const int = parseInt(str);\n  if (isNaN(int)) {\n    return { valid: false };\n  }\n  else {\n    return { valid: true, int };\n  }\n}\n```\n\n### JSON and serialization\n\nThe JSON standard has support for encoding `null` but not `undefined`. When JSON-encoding an object with an attribute that is `null`, the attribute will be included with its null value, whereas an attribute with an `undefined` value will be excluded entirely.\n\n```ts\nJSON.stringify({willStay: null, willBeGone: undefined}); // {\"willStay\":null}\n```\n\nAs a result, JSON-based databases may support `null` values but not `undefined` values. Since attributes set to `null` are encoded, you can transmit the intent to clear an attribute by setting its value to `null` before encoding and transmitting the object to a remote store."}
{"id": "docs\\javascript\\null-undefined.md#5", "content": "Setting attribute values to undefined can save on storage and transmission costs, as the attribute names will not be encoded. However, this can complicate the semantics of clearing values vs. absent values.\n\n### Final thoughts\nTypeScript team doesn't use `null` : [TypeScript coding guidelines](https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#null-and-undefined) and it hasn't caused any problems. Douglas Crockford thinks [`null` is a bad idea](https://www.youtube.com/watch?v=PSGEjv3Tqo0&feature=youtu.be&t=9m21s) and we should all just use `undefined`.\n\nHowever, NodeJS style code bases uses `null` for Error arguments as standard as it denotes `Something is currently unavailable`. I personally don't care to distinguish between the two as most projects use libraries with differing opinions and just rule out both with `== null`."}
{"id": "docs\\javascript\\number.md#0", "content": "## Number\nWhenever you are handling numbers in any programming language you need to be aware of the idiosyncrasies of how the language handles numbers. Here are a few critical pieces of information about numbers in JavaScript that you should be aware of.\n\n### Core Type\nJavaScript has only one number type. It is a double-precision 64-bit `Number`. Below we discuss its limitations along with a recommended solution.\n\n### Decimal\nFor those familiar with doubles / float in other languages, you would know that binary floating point numbers *do not* map correctly to Decimal numbers. A trivial (and famous) example with JavaScript's built in numbers is shown below:\n\n```js\nconsole.log(.1 + .2); // 0.30000000000000004\n```\n\n> For true decimal math use `big.js` mentioned below.\n\n### Integer\nThe integer limits represented by the built in number type are `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER`."}
{"id": "docs\\javascript\\number.md#1", "content": "```js\nconsole.log({max: Number.MAX_SAFE_INTEGER, min: Number.MIN_SAFE_INTEGER});\n// {max: 9007199254740991, min: -9007199254740991}\n```\n\n**Safe** in this context refers to the fact that the value *cannot be the result of a rounding error*.\n\nThe unsafe values are `+1 / -1` away from these safe values and any amount of addition / subtraction will *round* the result.\n\n```js\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true!\nconsole.log(Number.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2); // true!\n\nconsole.log(Number.MAX_SAFE_INTEGER);      // 9007199254740991\nconsole.log(Number.MAX_SAFE_INTEGER + 1);  // 9007199254740992 - Correct\nconsole.log(Number.MAX_SAFE_INTEGER + 2);  // 9007199254740992 - Rounded!\nconsole.log(Number.MAX_SAFE_INTEGER + 3);  // 9007199254740994 - Rounded - correct by luck\nconsole.log(Number.MAX_SAFE_INTEGER + 4);  // 9007199254740996 - Rounded!\n```\n\nTo check safety you can use ES6 `Number.isSafeInteger`:"}
{"id": "docs\\javascript\\number.md#2", "content": "```js\n// Safe value\nconsole.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER)); // true\n\n// Unsafe value\nconsole.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1)); // false\n\n// Because it might have been rounded to it due to overflow\nconsole.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 10)); // false\n```\n\n> JavaScript will eventually get [BigInt](https://developers.google.com/web/updates/2018/05/bigint) support. For now, if you want arbitrary precision integer math use `big.js` mentioned below.\n\n### big.js\nWhenever you use math for financial calculations (e.g. GST calculation, money with cents, addition etc) use a library like [big.js](https://github.com/MikeMcl/big.js/) which is designed for\n* Perfect decimal math\n* Safe out of bound integer values\n\nInstallation is simple:\n```bash\nnpm install big.js @types/big.js\n```\n\nQuick Usage example:\n\n```js\nimport { Big } from 'big.js';"}
{"id": "docs\\javascript\\number.md#3", "content": "export const foo = new Big('111.11111111111111111111');\nexport const bar = foo.plus(new Big('0.00000000000000000001'));\n\n// To get a number:\nconst x: number = Number(bar.toString()); // Loses the precision\n```\n\n> Do not use this library for math used for UI / performance intensive purposes e.g charts, canvas drawing etc.\n\n### NaN\nWhen some number calculation is not representable by a valid number, JavaScript returns a special `NaN` value. A  classic example is imaginary numbers:\n\n```js\nconsole.log(Math.sqrt(-1)); // NaN\n```\n\nNote: Equality checks **don't** work on `NaN` values. Use `Number.isNaN` instead:\n\n```js\n// Don't do this\nconsole.log(NaN === NaN); // false!!\n\n// Do this\nconsole.log(Number.isNaN(NaN)); // true\n```\n\n### Infinity\nThe outer bounds of values representable in Number are available as static `Number.MAX_VALUE` and `-Number.MAX_VALUE` values.\n\n```js\nconsole.log(Number.MAX_VALUE);  // 1.7976931348623157e+308\nconsole.log(-Number.MAX_VALUE); // -1.7976931348623157e+308\n```"}
{"id": "docs\\javascript\\number.md#4", "content": "Values outside the range where precision isn't changed are clamped to these limits e.g.\n\n```js\nconsole.log(Number.MAX_VALUE + 1 == Number.MAX_VALUE);   // true!\nconsole.log(-Number.MAX_VALUE - 1 == -Number.MAX_VALUE); // true!\n```\n\nValues outside the range where precision is changed resolve to special values `Infinity`/`-Infinity` e.g.\n\n```js\nconsole.log(Number.MAX_VALUE + 1e292);  // Infinity\nconsole.log(-Number.MAX_VALUE - 1e292); // -Infinity\n```\n\nOf-course, these special infinity values also show up with arithmetic that requires it e.g.\n\n```js\nconsole.log( 1 / 0); // Infinity\nconsole.log(-1 / 0); // -Infinity\n```\n\nYou can use these `Infinity` values manually or using static members of the `Number` class as shown below:\n\n```js\nconsole.log(Number.POSITIVE_INFINITY === Infinity);  // true\nconsole.log(Number.NEGATIVE_INFINITY === -Infinity); // true\n```\n\nFortunately comparison operators (`<` / `>`) work reliably on infinity values:"}
{"id": "docs\\javascript\\number.md#5", "content": "```js\nconsole.log( Infinity >  1); // true\nconsole.log(-Infinity < -1); // true\n```\n\n### Infinitesimal\n\nThe smallest non-zero value representable in Number is available as static `Number.MIN_VALUE`\n\n```js\nconsole.log(Number.MIN_VALUE);  // 5e-324\n```\n\nValues smaller than `MIN_VALUE` (\"underflow values\") are converted to 0.\n\n```js\nconsole.log(Number.MIN_VALUE / 10);  // 0\n```\n\n> Further intuition: Just like values bigger than `Number.MAX_VALUE` get clamped to INFINITY, values smaller than `Number.MIN_VALUE` get clamped to `0`."}
{"id": "docs\\javascript\\recap.md#0", "content": "# Your JavaScript is TypeScript\n\nThere were (and will continue to be) a lot of competitors in *Some syntax* to *JavaScript* compilers. TypeScript is different from them in that *Your JavaScript is TypeScript*. Here's a diagram:\n\n![JavaScript is TypeScript](https://raw.githubusercontent.com/basarat/typescript-book/master/images/venn.png)\n\nHowever, it does mean that *you need to learn JavaScript* (the good news is *you **only** need to learn JavaScript*). TypeScript is just standardizing all the ways you provide *good documentation* on JavaScript.\n\n* Just giving you a new syntax doesn't help catch bugs - but might help you write cleaner / less bugs (e.g. CoffeeScript).\n* Creating a new language abstracts you too far from your runtimes and communities - but might help on-board you easier if its an already familiar flavour (e.g. Dart - closer for Java / C# devs).\n\nTypeScript is just JavaScript with docs."}
{"id": "docs\\javascript\\recap.md#1", "content": "> JSNext is open to interpretation - not everything proposed for the next version of JS actually makes it to browsers. TypeScript only adds support for proposals once they reach [stage 3](https://tc39.es/process-document/).\n\n## Making JavaScript Better\n\nTypeScript will try to protect you from portions of JavaScript that never worked (so you don't need to remember this stuff):\n\n```ts\n[] + []; // JavaScript will give you \"\" (which makes little sense), TypeScript will error\n\n//\n// other things that are nonsensical in JavaScript\n// - don't give a runtime error (making debugging hard)\n// - but TypeScript will give a compile time error (making debugging unnecessary)\n//\n{} + []; // JS : 0, TS Error\n[] + {}; // JS : \"[object Object]\", TS Error\n{} + {}; // JS : NaN or [object Object][object Object] depending upon browser, TS Error\n\"hello\" - 1; // JS : NaN, TS Error\n\nfunction add(a,b) {\n  return\n    a + b; // JS : undefined, TS Error 'unreachable code detected'\n}\n```"}
{"id": "docs\\javascript\\recap.md#2", "content": "Essentially TypeScript is linting JavaScript. Just doing a better job at it than other linters that don't have *type information*.\n\n## You still need to learn JavaScript\n\nThat said TypeScript is very pragmatic about the fact that *you do write JavaScript* so there are some things about JavaScript that you still need to know in order to not be caught off-guard. Let's discuss them next.\n\n> Note: TypeScript is a superset of JavaScript. Just with documentation that can actually be used by compilers / IDEs ;)"}
{"id": "docs\\javascript\\references.md#0", "content": "## References\n\nBeyond literals, any Object in JavaScript (including functions, arrays, regexp etc) are references. This means the following\n\n### Mutations are across all references\n\n```js\nvar foo = {};\nvar bar = foo; // bar is a reference to the same object\n\nfoo.baz = 123;\nconsole.log(bar.baz); // 123\n```\n\n### Equality is for references\n\n```js\nvar foo = {};\nvar bar = foo; // bar is a reference\nvar baz = {}; // baz is a *new object* distinct from `foo`\n\nconsole.log(foo === bar); // true\nconsole.log(foo === baz); // false\n```"}
{"id": "docs\\javascript\\this.md#0", "content": "## this\n\nAny access to `this` keyword within a function is controlled by how the function is actually called. It is commonly referred to as the \u201ccalling context.\u201d\n\nHere is an example:\n\n```ts\nfunction foo() {\n  console.log(this);\n}\n\nfoo(); // logs out the global e.g. `window` in browsers\nlet bar = {\n  foo\n}\nbar.foo(); // Logs out `bar` as `foo` was called on `bar`\n```\n\nSo be mindful of your usage of `this`. If you want to disconnect `this` in a class from the calling context use an arrow function, [more on that later][arrow].\n\n[arrow]:../arrow-functions.md"}
{"id": "docs\\javascript\\truthy.md#0", "content": "## Truthy\n\nJavaScript has a concept of `truthy` i.e. things that evaluate like `true` would in certain positions (e.g. `if` conditions and the boolean `&&` `||` operators). The following things are truthy in JavaScript. An example is any number other than `0` e.g.\n\n```ts\nif (123) { // Will be treated like `true`\n  console.log('Any number other than 0 is truthy');\n}\n```\n\nSomething that isn't truthy is called `falsy`.\n\nHere's a handy table for your reference."}
{"id": "docs\\javascript\\truthy.md#1", "content": "| Variable Type   | When it is *falsy*       | When it is *truthy*      |\n|-----------------|--------------------------|--------------------------|\n| `boolean`       | `false`                  | `true`                   |\n| `string`        | `''` (empty string)      | any other string         |\n| `number`        | `0`  `NaN`               | any other number         |\n| `null`          | always                   | never                    |\n| `undefined`     | always                   | never                    |\n| Any other Object including empty ones like `{}`,`[]` | never | always |\n\n\n### Being explicit\n\n> The `!!` pattern"}
{"id": "docs\\javascript\\truthy.md#2", "content": "Quite commonly it helps to be explicit that the intent is to treat the value as a `boolean` and convert it into a *true boolean* (one of `true`|`false`). You can easily convert values to a true boolean by prefixing it with `!!` e.g. `!!foo`. Its just `!` used *twice*. The first `!` converts the variable (in this case `foo`) to a boolean but inverts the logic (*truthy* -`!`> `false`, *falsy* -`!`> `true`). The second one toggles it again to match the nature of the original object (e.g. *truthy* -`!`> `false` -`!`> `true`).\n\nIt is common to use this pattern in lots of places e.g.\n\n```js\n// Direct variables\nconst hasName = !!name;\n\n// As members of objects\nconst someObj = {\n  hasName: !!name\n}\n\n// e.g. in ReactJS JSX\n{!!someName && <div>{someName}</div>}\n```"}
{"id": "docs\\jsx\\others.md#0", "content": "# Non React JSX\n\n[![DesignTSX](https://raw.githubusercontent.com/basarat/typescript-book/master/images/designtsx-banner.png)](https://designtsx.com)\n\nTypeScript provides you with the ability to use something other than React with JSX in a type safe manner. The following lists the customizability points, but note that this is for advanced UI framework authors:"}
{"id": "docs\\jsx\\others.md#1", "content": "* You can disable `react` style emit by using `\"jsx\" : \"preserve\"` option. This means that JSX is emitted *as is* and then you can use your own custom transpiler to transpile the JSX portions.\n* Using the `JSX` global module:\n    * You can control what HTML tags are available and how they are type checked by customizing the `JSX.IntrinsicElements` interface members.\n    * When using components:\n        * You can control which `class` must be inherited by components by customizing the default `interface ElementClass extends React.Component<any, any> { }` declaration.\n        * You can control which property is used to type check the attributes (the default is `props`) by customizing the `declare module JSX { interface ElementAttributesProperty { props: {}; } }` declaration.\n\n## `jsxFactory`\n\nPassing `--jsxFactory <JSX factory Name>` along with `--jsx react` allows for using a different JSX factory from the default `React`."}
{"id": "docs\\jsx\\others.md#2", "content": "The new factory name will be used to call `createElement` functions.\n\n### Example\n\n```ts\nimport {jsxFactory} from \"jsxFactory\";\n\nvar div = <div>Hello JSX!</div>\n```\n\nCompiled with:\n\n```shell\ntsc --jsx react --reactNamespace jsxFactory --m commonJS\n```\n\nResults in:\n\n```js\n\"use strict\";\nvar jsxFactory_1 = require(\"jsxFactory\");\nvar div = jsxFactory_1.jsxFactory.createElement(\"div\", null, \"Hello JSX!\");\n```\n\n## `jsx` pragma\n\nYou can even specify a different `jsxFactory` per file using `jsxPragma` e.g. \n\n\n```js\n/** @jsx jsxFactory */\nimport {jsxFactory} from \"jsxFactory\";\n\nvar div = <div>Hello JSX!</div>\n```\n\nWith `--jsx react` this file will emit to use the factory specfied in the jsx pragma: \n```js\n\"use strict\";\nvar jsxFactory_1 = require(\"jsxFactory\");\nvar div = jsxFactory_1.jsxFactory.createElement(\"div\", null, \"Hello JSX!\");\n```"}
{"id": "docs\\jsx\\react.md#0", "content": "# React JSX\n\n> [Free series of youtube videos on React / TypeScript best practices](https://www.youtube.com/watch?v=7EW67MqgJvs&list=PLYvdvJlnTOjHNayH7MukKbSJ6PueUNkkG)\n\n> [PRO Egghead course on TypeScript and React](https://egghead.io/courses/use-typescript-to-develop-react-applications)\n\n[![DesignTSX](https://raw.githubusercontent.com/basarat/typescript-book/master/images/designtsx-banner.png)](https://designtsx.com)\n\n## Setup\n\nOur [browser quickstart already sets you up to develop react applications](../quick/browser.md). Here are the key highlights.\n\n* Use files with the extension `.tsx` (instead of `.ts`).\n* Use `\"jsx\" : \"react\"` in your `tsconfig.json`'s `compilerOptions`.\n* Install the definitions for JSX and React into your project : (`npm i -D @types/react @types/react-dom`).\n* Import react into your `.tsx` files (`import * as React from \"react\"`).\n\n## HTML Tags vs. Components"}
{"id": "docs\\jsx\\react.md#1", "content": "React can either render HTML tags (strings) or React components. The JavaScript emit for these elements is different (`React.createElement('div')` vs. `React.createElement(MyComponent)`). The way this is determined is by the *case* of the *first* letter. `foo` is treated as an HTML tag and `Foo` is treated as a component.\n\n## Type Checking\n\n### HTML Tags\n\nAn HTML Tag `foo` is to be of the type `JSX.IntrinsicElements.foo`. These types are already defined for all the major tags in a file `react-jsx.d.ts` which we had you install as a part of the setup. Here is a sample of the  the contents of the file:\n\n```ts\ndeclare module JSX {\n    interface IntrinsicElements {\n        a: React.HTMLAttributes;\n        abbr: React.HTMLAttributes;\n        div: React.HTMLAttributes;\n        span: React.HTMLAttributes;\n\n        /// so on ...\n    }\n}\n```\n\n### Function Components\n\nYou can define function components simply with the `React.FunctionComponent` interface e.g."}
{"id": "docs\\jsx\\react.md#2", "content": "```ts\ntype Props = {\n  foo: string;\n}\nconst MyComponent: React.FunctionComponent<Props> = (props) => {\n    return <span>{props.foo}</span>\n}\n\n<MyComponent foo=\"bar\" />\n```\n\n### Void Function Components\n\nAs of [@types/react PR #46643](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46643), you can use a new `React.VoidFunctionComponent` or `React.VFC` type if you wish to declare that a component does not take `children`. This is an interim solution until the next major version of the type defs (where VoidFunctionComponent will be deprecated and FunctionComponent will by default accept no children)."}
{"id": "docs\\jsx\\react.md#3", "content": "```ts\ntype Props = { \n  foo: string \n}\n// OK now, in future, error\nconst FunctionComponent: React.FunctionComponent<Props> = ({ foo, children }: Props) => {\n    return <div>{foo} {children}</div>; // OK\n};\n// Error now (children not support), in future, deprecated\nconst VoidFunctionComponent: React.VoidFunctionComponent<Props> = ({ foo, children }) => {\n    return <div>{foo}{children}</div>; \n};\n```\n\n### Class Components\n\nComponents are type checked based on the `props` property of the component. This is modeled after how JSX is transformed i.e. the attributes become the `props` of the component.\n\nThe `react.d.ts` file defines the `React.Component<Props,State>` class which you should extend in your own class providing your own `Props` and `State` interfaces. This is demonstrated below:\n\n```ts\ntype Props = {\n  foo: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n    render() {\n        return <span>{this.props.foo}</span>\n    }\n}\n\n<MyComponent foo=\"bar\" />\n```"}
{"id": "docs\\jsx\\react.md#4", "content": "### React JSX Tip: Interface for renderable\n\nReact can render a few things like `JSX` or `string`. These are all consolidated into the type `React.ReactNode` so use it for when you want to accept renderables e.g.\n\n```ts\ntype Props = {\n  header: React.ReactNode;\n  body: React.ReactNode;\n}\nclass MyComponent extends React.Component<Props, {}> {\n    render() {\n        return <div>\n            {this.props.header}\n            {this.props.body}\n        </div>;\n    }\n}\n\n<MyComponent header={<h1>Header</h1>} body={<i>body</i>} />\n```\n\n### React JSX Tip: Accept an instance of a Component\n\nThe react type definitions provide `React.ReactElement<T>` to allow you to annotate the result of a `<T/>` class component instantiation. e.g.\n\n```js\nclass MyAwesomeComponent extends React.Component {\n  render() {\n    return <div>Hello</div>;\n  }\n}"}
{"id": "docs\\jsx\\react.md#5", "content": "const foo: React.ReactElement<MyAwesomeComponent> = <MyAwesomeComponent />; // Okay\nconst bar: React.ReactElement<MyAwesomeComponent> = <NotMyAwesomeComponent />; // Error!\n```\n\n> Of course you can use this as a function argument annotation and even React component prop member.\n\n### React JSX Tip: Accept a *component* that can act on props and be rendered using JSX\n\nThe type `React.Component<Props>` consolidates `React.ComponentClass<P> | React.StatelessComponent<P>` so you can accept *something* that takes type `Props` and renders it using JSX e.g.\n\n```ts\nconst X: React.Component<Props> = foo; // from somewhere\n\n// Render X with some props:\n<X {...props}/>;\n```\n\n### React JSX Tip: Generic components\n\nIt works exactly as expected. Here is an example:\n\n```ts\n/** A generic component */\ntype SelectProps<T> = { items: T[] }\nclass Select<T> extends React.Component<SelectProps<T>, any> { }\n\n/** Usage */\nconst Form = () => <Select<string> items={['a','b']} />;\n```\n\n### Generic functions"}
{"id": "docs\\jsx\\react.md#6", "content": "Something like the following works fine:\n\n```ts\nfunction foo<T>(x: T): T { return x; }\n```\n\nHowever, using an arrow generic function will not:\n\n```ts\nconst foo = <T>(x: T) => x; // ERROR : unclosed `T` tag\n```\n\n**Workaround**: Use `extends` on the generic parameter to hint the compiler that it's a generic, e.g.:\n\n```ts\nconst foo = <T extends unknown>(x: T) => x;\n```\n\n### React Tip: Strongly Typed Refs \nYou basically initialize a variable as a union of the ref and `null` and then initialize it as as callback  e.g. \n\n```ts\nclass Example extends React.Component {\n  example() {\n    // ... something\n  }\n  \n  render() { return <div>Foo</div> }\n}\n\n\nclass Use {\n  exampleRef: Example | null = null; \n  \n  render() {\n    return <Example ref={exampleRef => this.exampleRef = exampleRef } />\n  }\n}\n```\n\nAnd the same with ref's for native elements e.g."}
{"id": "docs\\jsx\\react.md#7", "content": "```ts\nclass FocusingInput extends React.Component<{ value: string, onChange: (value: string) => any }, {}>{\n  input: HTMLInputElement | null = null;\n    \n  render() {\n    return (\n      <input\n        ref={(input) => this.input = input}\n        value={this.props.value}\n        onChange={(e) => { this.props.onChange(e.target.value) } }\n        />\n      );\n    }\n    focus() {\n      if (this.input != null) { this.input.focus() }\n    }\n}\n```\n\n### Type Assertions\n\nUse `as Foo` syntax for type assertions as we [mentioned before](../types/type-assertion.md#as-foo-vs-foo).\n\n## Default Props\n\n* Stateful components with default props: You can tell TypeScript that a property will be provided externally (by React) by using a *null assertion* operator (this isn't ideal but is the simplest minimum *extra code* solution I could think of)."}
{"id": "docs\\jsx\\react.md#8", "content": "```tsx\nclass Hello extends React.Component<{\n  /**\n   * @default 'TypeScript'\n   */\n  compiler?: string,\n  framework: string\n}> {\n  static defaultProps = {\n    compiler: 'TypeScript'\n  }\n  render() {\n    const compiler = this.props.compiler!;\n    return (\n      <div>\n        <div>{compiler}</div>\n        <div>{this.props.framework}</div>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Hello framework=\"React\" />, // TypeScript React\n  document.getElementById(\"root\")\n);\n```\n\n* SFC with default props: Recommend leveraging simple JavaScript patterns as they work well with TypeScript's type system e.g.\n\n```tsx\nconst Hello: React.SFC<{\n  /**\n   * @default 'TypeScript'\n   */\n  compiler?: string,\n  framework: string\n}> = ({\n  compiler = 'TypeScript', // Default prop\n  framework\n}) => {\n    return (\n      <div>\n        <div>{compiler}</div>\n        <div>{framework}</div>\n      </div>\n    );\n  };"}
{"id": "docs\\jsx\\react.md#9", "content": "ReactDOM.render(\n  <Hello framework=\"React\" />, // TypeScript React\n  document.getElementById(\"root\")\n);\n```\n\n## Declaring a webcomponent\n\nIf you are using a web component the default React type definitions (`@types/react`) will not know about it. But you can declare it easily e.g. to declare a webcomponent called `my-awesome-slider` that takes Props `MyAwesomeSliderProps` you would: \n\n```tsx\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      'my-awesome-slider': MyAwesomeSliderProps;\n    }\n\n    interface MyAwesomeSliderProps extends React.Attributes {\n      name: string;\n    }\n  }\n}\n```\n\nNow you can use it in TSX:\n\n```tsx\n<my-awesome-slider name='amazing'/>\n```"}
{"id": "docs\\jsx\\tsx.md#0", "content": "# JSX Support\n\n[![DesignTSX](https://raw.githubusercontent.com/basarat/typescript-book/master/images/designtsx-banner.png)](https://designtsx.com)\n\nTypeScript supports JSX transpilation and code analysis. If you are unfamiliar with JSX here is an excerpt from the [official website](https://facebook.github.io/jsx/):\n\n> JSX is an XML-like syntax extension to ECMAScript without any defined semantics. It's NOT intended to be implemented by engines or browsers. It's NOT a proposal to incorporate JSX into the ECMAScript spec itself. It's intended to be used by various preprocessors (transpilers) to transform these tokens into standard ECMAScript.\n\nThe motivation behind JSX is to allow users to write HTML like views *in JavaScript* so that you can:"}
{"id": "docs\\jsx\\tsx.md#1", "content": "* Have the view Type Checked by the same code that is going to check your JavaScript\n* Have the view be aware of the context it is going to operate under (i.e. strengthen the *controller-view* connection in traditional MVC).\n* Reuse JavaScript patterns for HTML maintenance e.g. `Array.prototype.map`, `?:`, `switch` etc instead of creating new (and probably poorly typed) alternatives.\n\nThis decreases the chances of errors and increases the maintainability of your user interfaces. The main consumer of JSX at this point is [ReactJS from facebook](http://facebook.github.io/react/). This is the usage of JSX that we will discuss here."}
{"id": "docs\\npm\\index.md#0", "content": "# NPM \n\n> Fun fact `npm` is [not an acronym](https://twitter.com/npmjs/status/347057301401763840) so it doesn't expand to anything, but among friends it is commonly called `node package manager`.\n\n`npm` is a binary that comes with default `node` installations used to manage community shared JavaScript / TypeScript packages.\n\n\n* NPM packages are hosted at (and installed from) https://www.npmjs.com/ (the \u2601\ufe0f).\n\n## Quick common setup\n\n* npm packages are configured using `package.json` file. You can generate a quick file using `npm init -y`.\n* packages get installed into a `./node_modules` folder. You normally have this folder in your `.gitignore`.\n\n> Even though you might be building an application, having a `package.json` essentially makes your project a package as well. So the terms your `project | package` can be used interchangeably."}
{"id": "docs\\npm\\index.md#1", "content": "When you checkout someone's (your team's) package, it will have a `package.json` that will list the dependencies you need to run the project. You simply run `npm install` and npm will bring them down from the cloud \u2601\ufe0f.\n \n## Installing a package\nYou can run `npm install <something>`. Most people will use the shorthand `npm i <something>` e.g. \n\n```ts\n// Install react\nnpm i react\n```\n\n> This will also automatically add `react` into your `package.json`'s `dependencies`.\n\n## Installing a devDependency\n`devDependencies` are dependencies that are only required during *development* if your project and not required after deployment. \n\n`typescript` is common in `devDependencies` as its only required to build `.ts -> .js`. You normally deploy the built `.js` files:\n\n* into production  \n* OR for consumption by other other npm packages"}
{"id": "docs\\npm\\index.md#2", "content": "## Security\nThe public `npm` packages are scanned by security team worldwide and issues get reported to npm team. They then release security advisories detailing the issue and potential fixes. Commonly the fix is simply updating the package. \n\nYou can run an audit on your node project by simply running `npm audit`. This will highlight any vulnerabilities that might exist in the package / dependencies of the package. e.g."}
{"id": "docs\\npm\\index.md#3", "content": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Low           \u2502 Regular Expression Denial of Service                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Package       \u2502 debug                                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Dependency of \u2502 jest [dev]                                                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Path          \u2502 jest > jest-cli > istanbul-lib-source-maps > debug           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 More info     \u2502 https://nodesecurity.io/advisories/534                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"}
{"id": "docs\\npm\\index.md#4", "content": "Note that commonly the issues are found in *development* dependencies (e.g. jest in this case). Since these aren't are a part of your production deployments, most likely your production application is not vulnerable. But still good practice to keep vulnerabilities to `0`.\n\nSimply add `npm audit` (the command exist with error code `1` in case of error) as a part of your deployment to ensure the projects stay up to date.\n\n## NPM Scripts \n\n### What is with `--` in scripts \nYou can build a base script with a limited set of command line arguments e.g. here is a script target that runs `tsc` for the TypeScript compiler: \n\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsc -p .\"\n  }\n}\n```\n\nYou can create a `build:watch` target to run `tsc -p . -w` or alternatively asking npm to run `build` with the additional `-w` flag like so:"}
{"id": "docs\\npm\\index.md#5", "content": "```json\n{\n  \"scripts\": {\n    \"build\": \"tsc -p .\",\n    \"build:watch\": \"npm run build -- -w\"\n  }\n}\n```\nYou can pass in as many flags as you want after `--` e.g. in the following example `build:more` has the same effect as `something --foo -f -d --bar`\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"something --foo\",\n    \"build:more\": \"npm run build -- -f -d --bar\"\n  }\n}\n```\n\n## Public vs. Private packages\nYou don't need this when *using* any of the common public npm packages. Just know its there for enterprise / commercial customers.\n\n### Public packages\n* Packages are public by default. \n* Anyone can deploy a package to npm. \n* You just need an account (which you can get for free).\n \nNo one needs an account to download a public package. \n\nThis free sharing of packages is one of the key reasons of success for npm \ud83c\udf39.\n\n### Private packages \n\nIf you want a private package for your company / team / enterprise you need to sign up to a paid plan, details here : https://www.npmjs.com/pricing"}
{"id": "docs\\npm\\index.md#6", "content": "Of-course you need an account with the right permissions to download a private package."}
{"id": "docs\\options\\intro.md#0", "content": "# Convenience vs. Soundness\n\nThere are a few things that TypeScript prevents you from doing out of the box e.g. using a variable that *isn't ever declared* (of course you can use a *declaration file* for external systems).\n\nThat said, traditionally programming languages have a hard boundary between what is and isn't allowed by the type system. TypeScript is different in that it gives you control over where you put the slider. This is really to allow you to use the JavaScript you know and love with as much safety as **you** want. There are lots of compiler options to control exactly this slider so let's have a look.\n\n## Boolean Options\n\n`compilerOptions` that are `boolean` can be specified as `compilerOptions` in `tsconfig.json`:\n\n```json\n{\n    \"compilerOptions\": {\n        \"someBooleanOption\": true\n    }\n}\n```\n\nor on the command line\n\n```sh\ntsc --someBooleanOption\n```\n\n> All of these are `false` by default."}
{"id": "docs\\options\\intro.md#1", "content": "Click [here](https://www.typescriptlang.org/docs/handbook/compiler-options.html) to see all compiler options."}
{"id": "docs\\options\\noImplicitAny.md#0", "content": "# noImplicitAny\n\nThere are some things that cannot be inferred or inferring them might result in unexpected errors. A fine example is function arguments. If you don't annotate them, its unclear what should and shouldn't be valid e.g.\n\n```ts\nfunction log(someArg) {\n  sendDataToServer(someArg);\n}\n\n// What arg is valid and what isn't?\nlog(123);\nlog('hello world');\n```\n\nSo if you don't annotate some function argument, TypeScript assumes `any` and moves on. This essentially turns off type checking for such cases, which is what a JavaScript dev would expect. But this can catch people that want high safety off guard. Hence there is an option, `noImplicitAny`, that when switched on will flag the cases where the type cannot be inferred e.g.\n\n```ts\nfunction log(someArg) { // Error : someArg has an implicit `any` type\n  sendDataToServer(someArg);\n}\n```\n\nOf course you can then go ahead and annotate:\n\n```ts\nfunction log(someArg: number) {\n  sendDataToServer(someArg);\n}\n```"}
{"id": "docs\\options\\noImplicitAny.md#1", "content": "And if you truly want *zero safety* you can mark it *explicitly* as `any`:\n\n```ts\nfunction log(someArg: any) {\n  sendDataToServer(someArg);\n}\n```"}
{"id": "docs\\options\\strictNullChecks.md#0", "content": "# `strictNullChecks`\n\nBy default `null` and `undefined` are assignable to all types in TypeScript e.g.\n\n```ts\nlet foo: number = 123;\nfoo = null; // Okay\nfoo = undefined; // Okay\n```\n\nThis is modelled after how a lot of people write JavaScript. However, like all things, TypeScript allows you to be *explicit* about what *can and cannot be* assigned a `null` or `undefined`.\n\nIn strict null checking mode, `null` and `undefined` are different:\n\n```ts\nlet foo = undefined;\nfoo = null; // NOT Okay\n```\n\nLet's say we have a `Member` interface:\n\n```ts\ninterface Member {\n  name: string,\n  age?: number\n}\n```\n\nNot every `Member` will provide their age, so `age` is an optional property, meaning the value of `age` may or may not be `undefined`.\n\n`undefined` is the root of all evil. It often leads to runtime errors. It is easy to write code that will throw `Error` at runtime:"}
{"id": "docs\\options\\strictNullChecks.md#1", "content": "```ts\ngetMember()\n  .then(member: Member => {\n    const stringifyAge = member.age.toString() // Cannot read property 'toString' of undefined\n  })\n```\n\nBut in strict null checking mode, this error will be caught at compile time:\n\n```ts\ngetMember()\n  .then(member: Member => {\n    const stringifyAge = member.age.toString() // Object is possibly 'undefined'\n  })\n```\n\n## Non-Null Assertion Operator\n\nA new `!` post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. For example:\n\n```ts\n// Compiled with --strictNullChecks\nfunction validateEntity(e?: Entity) {\n    // Throw exception if e is null or invalid entity\n}\n\nfunction processEntity(e?: Entity) {\n    validateEntity(e);\n    let a = e.name;  // TS ERROR: e may be null.\n    let b = e!.name;  // OKAY. We are asserting that e is non-null.\n}\n```"}
{"id": "docs\\options\\strictNullChecks.md#2", "content": "> Note that it is just an assertion, and just like type assertions *you are responsible* for making sure the value is not null. A non-null assertion is essentially you telling the compiler \"I know it's not null so let me use it as though it's not null\".\n\n### Definite Assignment Assertion Operator\n\nTypeScript will also complain about properties in classes not being initialized e.g.:\n\n```ts\nclass C {\n  foo: number; // OKAY as assigned in constructor\n  bar: string = \"hello\"; // OKAY as has property initializer\n  baz: boolean; // TS ERROR: Property 'baz' has no initializer and is not assigned directly in the constructor.\n  constructor() {\n    this.foo = 42;\n  }\n}\n```\n\nYou can use the definite assignment assertion postfixed to the property name to tell TypeScript that you are initializing it somewhere other than the constructor e.g."}
{"id": "docs\\options\\strictNullChecks.md#3", "content": "```ts\nclass C {\n  foo!: number;\n  // ^\n  // Notice this exclamation point!\n  // This is the \"definite assignment assertion\" modifier.\n  \n  constructor() {\n    this.initialize();\n  }\n  initialize() {\n    this.foo = 0;\n  }\n}\n```\n\nYou can also use this assertion with simple variable declarations e.g.:\n\n```ts\nlet a: number[]; // No assertion\nlet b!: number[]; // Assert\n\ninitialize();\n\na.push(4); // TS ERROR: variable used before assignment\nb.push(4); // OKAY: because of the assertion\n\nfunction initialize() {\n  a = [0, 1, 2, 3];\n  b = [0, 1, 2, 3];\n}\n```\n\n> Like all assertions, you are telling the compiler to trust you. The compiler will not complain even if the code doesn't actually always assign the property."}
{"id": "docs\\project\\compilation-context.md#0", "content": "## Compilation Context\nThe compilation context is basically just a fancy term for grouping of the files that TypeScript will parse and analyze to determine what is valid and what isn't. Along with the information about which files, the compilation context contains information about *which compiler options* are in use. A great way to define this logical grouping (we also like to use the term *project*) is using a `tsconfig.json` file."}
{"id": "docs\\project\\declarationspaces.md#0", "content": "## Declaration Spaces\n\nThere are two declaration spaces in TypeScript: the *variable* declaration space and the *type* declaration space. These concepts are explored below.\n\n### Type Declaration Space\nThe type declaration space contains stuff that can be used as a type annotation. E.g. the following are a few type declarations:\n\n```ts\nclass Foo {};\ninterface Bar {};\ntype Bas = {};\n```\nThis means that you can use `Foo`, `Bar`, `Bas`, etc. as a type annotation. E.g.:\n\n```ts\nvar foo: Foo;\nvar bar: Bar;\nvar bas: Bas;\n```\n\nNotice that even though you have `interface Bar`, *you can't use it as a variable* because it doesn't contribute to the *variable declaration space*. This is shown below:\n\n```ts\ninterface Bar {};\nvar bar = Bar; // ERROR: \"cannot find name 'Bar'\"\n```\n\nThe reason why it says `cannot find name` is because the name `Bar` *is not defined* in the *variable* declaration space. That brings us to the next topic \"Variable Declaration Space\"."}
{"id": "docs\\project\\declarationspaces.md#1", "content": "### Variable Declaration Space\nThe variable declaration space contains stuff that you can use as a variable. We saw that having `class Foo` contributes a type `Foo` to the *type* declaration space. Guess what? It also contributes a *variable* `Foo` to the *variable* declaration space as shown below:\n\n```ts\nclass Foo {};\nvar someVar = Foo;\nvar someOtherVar = 123;\n```\nThis is great as sometimes you want to pass classes around as variables. Remember that:\n\n* we couldn't use something like an `interface` that is *only* in the *type* declaration space as a variable.\n\nSimilarly something that you declare with `var`, is *only* in the *variable* declaration space and cannot be used as a type annotation:\n\n```ts\nvar foo = 123;\nvar bar: foo; // ERROR: \"cannot find name 'foo'\"\n```\nThe reason why it says `cannot find name` is because the name `foo` *is not defined* in the *type* declaration space."}
{"id": "docs\\project\\dynamic-import-expressions.md#0", "content": "## Dynamic import expressions \n\n**Dynamic import expressions** are a new feature and part of **ECMAScript** that allows users to asynchronously request a module at any arbitrary point in your program.\n**TC39** JavaScript committee has it\u2019s own proposal which is in stage 3, and it\u2019s called [import() proposal for JavaScript](https://github.com/tc39/proposal-dynamic-import).\n\nAlternatively, **webpack** bundler has a feature called [**Code Splitting**](https://webpack.js.org/guides/code-splitting/) which allows you to split your bundle into chunks which can be downloaded asynchronously at a later time. For instance, this allows to serve a minimal bootstrap bundle first and to asynchronously load additional features later."}
{"id": "docs\\project\\dynamic-import-expressions.md#1", "content": "It\u2019s natural to think (if we are using webpack in our dev workflow) that [TypeScript 2.4 dynamic import expressions](https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#dynamic-import-expressions) will **automatically produce** bundle chunks and automatically code-split your JS final bundle. BUT, that is not as easy as it seems, because it depends on the **tsconfig.json configuration** we are working with.\n\nThe thing is that webpack code splitting supports two similar techniques to achieve this goal: using **import()** (preferred, ECMAScript proposal) and **require.ensure()** (legacy, webpack specific). And what that means is the expected TypeScript output is **leave the import() statement as it is** instead of transpile it to anything else.\n\nLet\u2019s see an example to figure out how to configure webpack + TypeScript 2.4."}
{"id": "docs\\project\\dynamic-import-expressions.md#2", "content": "In the following code I want to **lazy load the library _moment_** but I am interested in code splitting as well, which means, having the moment library in a separate chunk of JS (JavaScript file) that will be loaded only when required.\n\n```ts\nimport(/* webpackChunkName: \"momentjs\" */ \"moment\")\n  .then((moment) => {\n      // lazyModule has all of the proper types, autocomplete works,\n      // type checking works, code references work \\o/\n      const time = moment().format();\n      console.log(\"TypeScript >= 2.4.0 Dynamic Import Expression:\");\n      console.log(time);\n  })\n  .catch((err) => {\n      console.log(\"Failed to load moment\", err);\n  });\n```\n\nHere is the tsconfig.json:"}
{"id": "docs\\project\\dynamic-import-expressions.md#3", "content": "```json\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\",                          \n        \"module\": \"esnext\",                     \n        \"lib\": [\n            \"dom\",\n            \"es5\",\n            \"scripthost\",\n            \"es2015.promise\"\n        ],                                        \n        \"jsx\": \"react\",                           \n        \"declaration\": false,                     \n        \"sourceMap\": true,                        \n        \"outDir\": \"./dist/js\",                    \n        \"strict\": true,                           \n        \"moduleResolution\": \"node\",               \n        \"typeRoots\": [\n            \"./node_modules/@types\"\n        ],                                        \n        \"types\": [\n            \"node\",\n            \"react\",\n            \"react-dom\"\n        ]                                       \n    }\n}\n```\n\n\n**Important notes**:"}
{"id": "docs\\project\\dynamic-import-expressions.md#4", "content": "- Using **\"module\": \"esnext\"** TypeScript produces the mimic import() statement to be input for Webpack Code Splitting.\n- For further information read this article: [Dynamic Import Expressions and webpack 2 Code Splitting integration with TypeScript 2.4](https://blog.josequinto.com/2017/06/29/dynamic-import-expressions-and-webpack-code-splitting-integration-with-typescript-2-4/).\n\n\nYou can see full example [here][dynamicimportcode].\n\n[dynamicimportcode]:https://cdn.rawgit.com/basarat/typescript-book/705e4496/code/dynamic-import-expressions/dynamicImportExpression.js"}
{"id": "docs\\project\\external-modules.md#0", "content": "## External modules\nThere is a lot of power and usability packed into the TypeScript external module pattern. Here we discuss its power and some patterns needed to reflect real world usages.\n\n### Clarification: commonjs, amd, es modules, others\n\nFirst up we need to clarify the (awful) inconsistency of the module systems out there. I'll just give you my *current* recommendation and remove the noise i.e. not show you all the *other* ways things can work.\n\nFrom the *same TypeScript* you can generate different *JavaScript* depending upon the `module` option. Here are things you can ignore (I am not interested in explaining dead tech):\n\n* AMD: Do not use. Was browser only.\n* SystemJS: Was a good experiment. Superseded by ES modules.\n* ES Modules: Not ready yet.\n\nNow these are just the options for *generating the JavaScript*. Instead of these options use `module:commonjs`\n\nHow you *write* TypeScript modules is also a bit of a mess. Again here is how not to do it *today*:"}
{"id": "docs\\project\\external-modules.md#1", "content": "* `import foo = require('foo')`. i.e. `import/require`. Use ES module syntax instead.\n\nCool, with that out of the way, lets look at the ES module syntax.\n\n> Summary: Use `module:commonjs` and use the ES module syntax to import / export / author modules.\n\n### ES Module syntax\n\n* Exporting a variable (or type) is as easy as prefixing the keyword `export` e.g.\n\n```js\n// file `foo.ts`\nexport let someVar = 123;\nexport type SomeType = {\n  foo: string;\n};\n```\n\n* Exporting a variable or type in a dedicated `export` statement e.g.\n\n```js\n// file `foo.ts`\nlet someVar = 123;\ntype SomeType = {\n  foo: string;\n};\nexport {\n  someVar,\n  SomeType\n};\n```\n* Exporting a variable or type in a dedicated `export` statement *with renaming* e.g.\n\n```js\n// file `foo.ts`\nlet someVar = 123;\nexport { someVar as aDifferentName };\n```\n\n* Import a variable or a type using `import` e.g.\n\n```js\n// file `bar.ts`\nimport { someVar, SomeType } from './foo';\n```"}
{"id": "docs\\project\\external-modules.md#2", "content": "* Import a variable or a type using `import` *with renaming* e.g.\n\n```js\n// file `bar.ts`\nimport { someVar as aDifferentName } from './foo';\n```\n\n* Import everything from a module into a name with `import * as` e.g.\n\n```js\n// file `bar.ts`\nimport * as foo from './foo';\n// you can use `foo.someVar` and `foo.SomeType` and anything else that foo might export.\n```\n\n* Import a file *only* for its side effect with a single import statement:\n\n```js\nimport 'core-js'; // a common polyfill library\n```\n\n* Re-Exporting all the items from another module\n\n```js\nexport * from './foo';\n```\n\n* Re-Exporting only some items from another module\n\n```js\nexport { someVar } from './foo';\n```\n\n* Re-Exporting only some items from another module *with renaming*\n\n```js\nexport { someVar as aDifferentName } from './foo';\n```\n\n### Default exports/imports\nAs you will learn later, I am not a fan of default exports. Nevertheless here is syntax for export and using default exports"}
{"id": "docs\\project\\external-modules.md#3", "content": "* Export using `export default`\n  * before a variable (no `let / const / var` needed)\n  * before a function\n  * before a class\n\n```js\n// some var\nexport default someVar = 123;\n// OR Some function\nexport default function someFunction() { }\n// OR Some class\nexport default class SomeClass { }\n```\n\n* Import using the `import someName from \"someModule\"` syntax (you can name the import whatever you want) e.g.\n\n```js\nimport someLocalNameForThisFile from \"../foo\";\n```\n\n### Module paths\n\n> I am just going to assume `moduleResolution: \"Node\"`. This is the option you should have in your TypeScript config. This setting is implied automatically by `module:commonjs`.\n\nThere are two distinct kinds of modules. The distinction is driven by the path section of the import statement (e.g. `import foo from 'THIS IS THE PATH SECTION'`)."}
{"id": "docs\\project\\external-modules.md#4", "content": "* Relative path modules (where path starts with `.` e.g. `./someFile` or `../../someFolder/someFile` etc.)\n* Other dynamic lookup modules (e.g. `'core-js'` or `'typestyle'` or `'react'` or even `'react/core'` etc.)\n\nThe main difference is *how the module is resolved on the file system*.\n\n> I will use a conceptual term *place* that I will explain after mentioning the lookup pattern.\n\n#### Relative path modules\nEasy, just follow the relative path :) e.g.\n\n* if file `bar.ts` does `import * as foo from './foo';` then place `foo` must exist in the same folder.\n* if file `bar.ts` does `import * as foo from '../foo';` then place `foo` must exist in a folder up.\n* if file `bar.ts` does `import * as foo from '../someFolder/foo';` then one folder up, there must be a folder `someFolder` with a place `foo`\n\nOr any other relative path you can think of :)\n\n#### Dynamic lookup"}
{"id": "docs\\project\\external-modules.md#5", "content": "When the import path is *not* relative, lookup is driven by [*node style resolution*](https://nodejs.org/api/modules.html#modules_all_together). Here I only give a simple example:\n\n* You have `import * as foo from 'foo'`, the following are the places that are checked *in order*\n  * `./node_modules/foo`\n  * `../node_modules/foo`\n  * `../../node_modules/foo`\n  * Till root of file system\n\n* You have `import * as foo from 'something/foo'`, the following are the places that are checked *in order*\n  * `./node_modules/something/foo`\n  * `../node_modules/something/foo`\n  * `../../node_modules/something/foo`\n  * Till root of file system\n\n\n### What is *place*\nWhen I say *places that are checked* I mean that the following things are checked in that place. e.g. for a place `foo`:"}
{"id": "docs\\project\\external-modules.md#6", "content": "* If the place is a file, e.g. `foo.ts`, hurray!\n* else if the place is a folder and there is a file `foo/index.ts`, hurray!\n* else if the place is a folder and there is a `foo/package.json` and a file specified in the `types` key in the package.json that exists, then hurray!\n* else if the place is a folder and there is a `package.json` and a file specified in the `main` key in the package.json that exists, then hurray!\n\nBy file I actually mean `.ts` / `.d.ts` and `.js`.\n\nAnd that's it. You are now module lookup experts (not a small feat!).\n\n### Overturning dynamic lookup *just for types*\nYou can declare a module *globally* for your project by using `declare module 'somePath'` and then imports will resolve *magically* to that path\n\ne.g.\n```ts\n// global.d.ts\ndeclare module 'foo' {\n  // Some variable declarations\n  export var bar: number; /*sample*/\n}\n```"}
{"id": "docs\\project\\external-modules.md#7", "content": "and then:\n```ts\n// anyOtherTsFileInYourProject.ts\nimport * as foo from 'foo';\n// TypeScript assumes (without doing any lookup) that\n// foo is {bar:number}\n\n```\n\n### `import/require` for importing type only\nThe following statement:\n\n```ts\nimport foo = require('foo');\n```\n\nactually does *two* things:\n\n* Imports the type information of the foo module.\n* Specifies a runtime dependency on the foo module.\n\nYou can pick and choose so that only *the type information* is loaded and no runtime dependency occurs. Before continuing you might want to recap the [*declaration spaces*](../project/declarationspaces.md) section of the book.\n\nIf you do not use the imported name in the variable declaration space then the import is completely removed from the generated JavaScript. This is best explained with examples. Once you understand this we will present you with use cases.\n\n#### Example 1\n```ts\nimport foo = require('foo');\n```\nwill generate the JavaScript:\n\n```js"}
{"id": "docs\\project\\external-modules.md#8", "content": "```\nThat's right. An *empty* file as foo is not used.\n\n#### Example 2\n```ts\nimport foo = require('foo');\nvar bar: foo;\n```\nwill generate the JavaScript:\n```js\nvar bar;\n```\nThis is because `foo` (or any of its properties e.g. `foo.bas`) is never used as a variable.\n\n#### Example 3\n```ts\nimport foo = require('foo');\nvar bar = foo;\n```\nwill generate the JavaScript (assuming commonjs):\n```js\nvar foo = require('foo');\nvar bar = foo;\n```\nThis is because `foo` is used as a variable.\n\n\n### Use case: Lazy loading\nType inference needs to be done *upfront*. This means that if you want to use some type from a file `foo` in a file `bar` you will have to do:"}
{"id": "docs\\project\\external-modules.md#9", "content": "```ts\nimport foo = require('foo');\nvar bar: foo.SomeType;\n```\nHowever, you might want to only load the file `foo` at runtime under certain conditions. For such cases you should use the `import`ed name only in *type annotations* and **not** as a *variable*. This removes any *upfront* runtime dependency code being injected by TypeScript. Then *manually import* the actual module using code that is specific to your module loader.\n\nAs an example, consider the following `commonjs` based code where we only load a module `'foo'` on a certain function call:\n\n```ts\nimport foo = require('foo');\n\nexport function loadFoo() {\n    // This is lazy loading `foo` and using the original module *only* as a type annotation\n    var _foo: typeof foo = require('foo');\n    // Now use `_foo` as a variable instead of `foo`.\n}\n```\n\nA similar sample in `amd` (using requirejs) would be:\n```ts\nimport foo = require('foo');"}
{"id": "docs\\project\\external-modules.md#10", "content": "export function loadFoo() {\n    // This is lazy loading `foo` and using the original module *only* as a type annotation\n    require(['foo'], (_foo: typeof foo) => {\n        // Now use `_foo` as a variable instead of `foo`.\n    });\n}\n```\n\nThis pattern is commonly used:\n* in web apps where you load certain JavaScript on particular routes,\n* in node applications where you only load certain modules if needed to speed up application bootup.\n\n### Use case: Breaking Circular dependencies\n\nSimilar to the lazy loading use case certain module loaders (commonjs/node and amd/requirejs) don't work well with circular dependencies. In such cases it is useful to have *lazy loading* code in one direction and loading the modules upfront in the other direction.\n\n### Use case: Ensure Import"}
{"id": "docs\\project\\external-modules.md#11", "content": "Sometimes you want to load a file just for the side effect (e.g. the module might register itself with some library like [CodeMirror addons](https://codemirror.net/doc/manual.html#addons) etc.). However, if you just do a `import/require` the transpiled JavaScript will not contain a dependency on the module and your module loader (e.g. webpack) might completely ignore the import. In such cases you can use a `ensureImport` variable to ensure that the compiled JavaScript takes a dependency on the module e.g.:\n\n```ts\nimport foo = require('./foo');\nimport bar = require('./bar');\nimport bas = require('./bas');\nconst ensureImport: any =\n    foo\n    && bar\n    && bas;\n```"}
{"id": "docs\\project\\files.md#0", "content": "## Which files?\n\nUse `include` and `exclude` to specify files / folders / globs. E.g.:\n\n\n```json\n{\n    \"include\":[\n        \"./folder\"\n    ],\n    \"exclude\":[\n        \"./folder/**/*.spec.ts\",\n        \"./folder/someSubFolder\"\n    ]\n}\n```\n\n### Globs\n\n* For globs : `**/*` (e.g. sample usage `somefolder/**/*`) means all folder and any files (the extensions `.ts`/`.tsx` will be assumed and if `allowJs:true` so will `.js`/`.jsx`)\n\n### `files` option\nAlternatively, you can use `files` to be explicit: \n\n```json\n{\n    \"files\":[\n        \"./some/file.ts\"\n    ]\n}\n```\n\nBut it is not recommended as you have to keep updating it. Instead use `include` to just add the containing folder."}
{"id": "docs\\project\\globals.md#0", "content": "# global.d.ts\n\nWe discussed *global* vs. *file* modules when covering [projects](./modules.md) and recommended using file based modules and not polluting the global namespace.\n\nNevertheless, if you have beginner TypeScript developers you can give them a `global.d.ts` file to put interfaces / types in the global namespace to make it easy to have some *types* just *magically* available for consumption in *all* your TypeScript code.\n\nAnother use case for a `global.d.ts` file is to declare compile-time constants that are being injected into the source code by Webpack via the standard [DefinePlugin](https://webpack.js.org/plugins/define-plugin/) plugin.\n\n```ts\ndeclare const BUILD_MODE_PRODUCTION: boolean; // can be used for conditional compiling\ndeclare const BUILD_VERSION: string;\n```"}
{"id": "docs\\project\\globals.md#1", "content": "> For any code that is going to generate *JavaScript* we highly recommend using *file modules*, and only use `global.d.ts` to declare compile-time constants and/or to extend standard type declarations declared in `lib.d.ts`.\n\n* Bonus: The `global.d.ts` file is also good for quick `declare module \"some-library-you-dont-care-to-get-defs-for\";` when doing JS to TS migrations."}
{"id": "docs\\project\\module-resolution.md#0", "content": "# TypeScript Module Resolution\n\nTypeScript's module resolution tries to model and support the real world modules systems / loaders there (commonjs/nodejs, amd/requirejs, ES6/systemjs etc.). The most simplest lookup is relative file path lookup. After that things become a bit complex *because of the nature of magical module loading done by various module loaders*.\n\n## File Extensions\n\nYou import modules like `foo` or `./foo`. For any file path lookup TypeScript automatically checks for a `.ts` or `.d.ts` or `.tsx` or `.js` (optionally) or `.jsx` (optionally) file in the right order depending upon context. You should **not** provide a file extension with the module name (no `foo.ts`, just `foo`).\n\n## Relative File Module\n\nAn import with a relative path e.g.:\n\n```ts\nimport foo = require('./foo');\n```"}
{"id": "docs\\project\\module-resolution.md#1", "content": "Tells the TypeScript compiler to look for a TypeScript file at the relative location e.g. `./foo.ts` with respect to the current file. There is no further magic to this kind of import. Of course it can be a longer path e.g. `./foo/bar/bas` or `../../../foo/bar/bas` just like any other *relative paths* you are used to on disk.\n\n## Named Module\n\nThe following statement:\n\n```ts\nimport foo = require('foo');\n```\n\nTells the TypeScript compiler to look for an external module in the following order:\n\n* A named [module declaration](#module-declaration) from a file already in the compilation context.\n* If still not resolved and you are compiling with `--module commonjs`  or have set `--moduleResolution node` then its looked up using the [*node modules*](#node-modules) resolution algorithm.\n* If still not resolved and you provided `baseUrl` (and optionally `paths`) then the [*path substitutions*](#path-substitutions) resolution algorithm kicks in."}
{"id": "docs\\project\\module-resolution.md#2", "content": "Note that `\"foo\"` can be a longer path string e.g. `\"foo/bar/bas\"`. The key here is that *it does not start with `./` or `../`*.\n\n## Module Declaration\n\nA module declaration looks like:\n\n```ts\ndeclare module \"foo\" {\n\n    /// Some variable declarations\n\n    export var bar:number; /*sample*/\n}\n```\n\nThis makes the module `\"foo\"`, *importable*.\n\n## Node Modules\nThe node module resolution is actually pretty much the same one used by Node.js / NPM ([official nodejs docs](https://nodejs.org/api/modules.html#modules_all_together)). Here is a simple mental model I have:\n\n* module `foo/bar` will resolve to some file : `node_modules/foo` (the module) + `foo/bar`\n\n## Path Substitutions\n\nTODO."}
{"id": "docs\\project\\module-resolution.md#3", "content": "[//Comment1]:https://github.com/Microsoft/TypeScript/issues/2338\n[//Comment2]:https://github.com/Microsoft/TypeScript/issues/5039\n[//Comment3ExampleRedirectOfPackageJson]:https://github.com/Microsoft/TypeScript/issues/8528#issuecomment-219172026\n[//Coment4ModuleResolutionInHandbook]:https://github.com/Microsoft/TypeScript-Handbook/blob/release-2.0/pages/Module%20Resolution.md#base-url"}
{"id": "docs\\project\\modules.md#0", "content": "## Modules\n\n### Global Module\n\nBy default when you start typing code in a new TypeScript file your code is in a *global* namespace. As a demo consider a file `foo.ts`:\n\n```ts\nvar foo = 123;\n```\n\nIf you now create a *new* file `bar.ts` in the same project, you will be *allowed* by the TypeScript type system to use the variable `foo` as if it was available globally:\n\n```ts\nvar bar = foo; // allowed\n```\nNeedless to say having a global namespace is dangerous as it opens your code up for naming conflicts. We recommend using file modules which are presented next.\n\n### File Module\nAlso called *external modules*. If you have an `import` or an `export` at the root level of a TypeScript file then it creates a *local* scope within that file. So if we were to change the previous `foo.ts` to the following (note the `export` usage):\n\n```ts\nexport var foo = 123;\n```\n\nWe will no longer have `foo` in the global namespace. This can be demonstrated by creating a new file `bar.ts` as follows:"}
{"id": "docs\\project\\modules.md#1", "content": "```ts\nvar bar = foo; // ERROR: \"cannot find name 'foo'\"\n```\n\nIf you want to use stuff from `foo.ts` in `bar.ts` *you need to explicitly import it*. This is shown in an updated `bar.ts` below:\n\n```ts\nimport { foo } from \"./foo\";\nvar bar = foo; // allowed\n```\nUsing an `import` in `bar.ts` not only allows you to bring in stuff from other files, but also marks the file `bar.ts` as a *module* and therefore, declarations in `bar.ts` don't pollute the global namespace either.\n\nWhat JavaScript is generated from a given TypeScript file that uses external modules is driven by the compiler flag called `module`."}
{"id": "docs\\project\\namespaces.md#0", "content": "## Namespaces\nNamespaces provide you with a convenient syntax around a common pattern used in JavaScript:\n\n```ts\n(function(something) {\n\n    something.foo = 123;\n\n})(something || (something = {}))\n```\n\nBasically `something || (something = {})` allows an anonymous function `function(something) {}` to *add stuff to an existing object* (the `something ||` portion) or *start a new object then add stuff to that object* (the `|| (something = {})` portion). This means that you can have two such blocks split by some execution boundary:\n\n```ts\n(function(something) {\n\n    something.foo = 123;\n\n})(something || (something = {}))\n\nconsole.log(something); // {foo:123}\n\n(function(something) {\n\n    something.bar = 456;\n\n})(something || (something = {}))\n\nconsole.log(something); // {foo:123, bar:456}\n\n```"}
{"id": "docs\\project\\namespaces.md#1", "content": "This is commonly used in  the JavaScript land for making sure that stuff doesn't leak into the global namespace. With file based modules you don't need to worry about this, but the pattern is still useful for *logical grouping* of a bunch of functions. Therefore TypeScript provides the `namespace` keyword to group these e.g.:\n\n```ts\nnamespace Utility {\n    export function log(msg) {\n        console.log(msg);\n    }\n    export function error(msg) {\n        console.error(msg);\n    }\n}\n\n// usage\nUtility.log('Call me');\nUtility.error('maybe!');\n```\n\nThe `namespace` keyword generates the same JavaScript that we saw earlier:\n\n```ts\n(function (Utility) {\n\n// Add stuff to Utility\n\n})(Utility || (Utility = {}));\n```\n\nOne thing to note is that namespaces can be nested so you can do stuff like `namespace Utility.Messaging` to nest a `Messaging` namespace under `Utility`.\n\nFor most projects we recommend using external modules and using `namespace` for quick demos and porting old JavaScript code."}
{"id": "docs\\project\\project.md#0", "content": "# Project\n\nTo create a successful project using TypeScript you need to understand the various project organization language features available. In this section we will cover \"compilation context\", declaration spaces and modules."}
{"id": "docs\\project\\tsconfig.md#0", "content": "### Basic\nIt is extremely easy to get started with tsconfig.json as the basic file you need is:\n```json\n{}\n```\ni.e. an empty JSON file at the *root* of your project. This way TypeScript will include *all* the `.ts` files in this directory (and sub directories) as a part of the compilation context. It will also select a few sane default compiler options.\n\n### compilerOptions\nYou can customize the compiler options using `compilerOptions`:\n\n```json\n{\n  \"compilerOptions\": {"}
{"id": "docs\\project\\tsconfig.md#1", "content": "/* Basic Options */                       \n    \"target\": \"es5\",                       /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. */\n    \"module\": \"commonjs\",                  /* Specify module code generation: 'commonjs', 'amd', 'system', 'umd' or 'es2015'. */\n    \"lib\": [],                             /* Specify library files to be included in the compilation:  */\n    \"allowJs\": true,                       /* Allow JavaScript files to be compiled. */\n    \"checkJs\": true,                       /* Report errors in .js files. */\n    \"jsx\": \"preserve\",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */\n    \"declaration\": true,                   /* Generates corresponding '.d.ts' file. */\n    \"sourceMap\": true,                     /* Generates corresponding '.map' file. */\n    \"outFile\": \"./\",                       /* Concatenate and emit output to single file. */\n    \"outDir\": \"./\",                        /* Redirect output structure to the directory. */\n    \"rootDir\": \"./\",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */\n    \"removeComments\": true,                /* Do not emit comments to output. */\n    \"noEmit\": true,                        /* Do not emit outputs. */\n    \"importHelpers\": true,                 /* Import emit helpers from 'tslib'. */\n    \"downlevelIteration\": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\n    \"isolatedModules\": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */\n                                              \n    /* Strict Type-Checking Options */        \n    \"strict\": true,                        /* Enable all strict type-checking options. */\n    \"noImplicitAny\": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */\n    \"strictNullChecks\": true,              /* Enable strict null checks. */\n    \"noImplicitThis\": true,                /* Raise error on 'this' expressions with an implied 'any' type. */\n    \"alwaysStrict\": true,                  /* Parse in strict mode and emit \"use strict\" for each source file. */\n                                              \n    /* Additional Checks */                   \n    \"noUnusedLocals\": true,                /* Report errors on unused locals. */\n    \"noUnusedParameters\": true,            /* Report errors on unused parameters. */\n    \"noImplicitReturns\": true,             /* Report error when not all code paths in function return a value. */\n    \"noFallthroughCasesInSwitch\": true,    /* Report errors for fallthrough cases in switch statement. */\n                                              \n    /* Module Resolution Options */           \n    \"moduleResolution\": \"node\",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    \"baseUrl\": \"./\",                       /* Base directory to resolve non-absolute module names. */\n    \"paths\": {},                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */\n    \"rootDirs\": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */\n    \"typeRoots\": [],                       /* List of folders to include type definitions from. */\n    \"types\": [],                           /* Type declaration files to be included in compilation. */\n    \"allowSyntheticDefaultImports\": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\n                                              \n    /* Source Map Options */                  \n    \"sourceRoot\": \"./\",                    /* Specify the location where debugger should locate TypeScript files instead of source locations. */\n    \"mapRoot\": \"./\",                       /* Specify the location where debugger should locate map files instead of generated locations. */\n    \"inlineSourceMap\": true,               /* Emit a single file with source maps instead of having a separate file. */\n    \"inlineSources\": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\n                                              \n    /* Experimental Options */                \n    \"experimentalDecorators\": true,        /* Enables experimental support for ES7 decorators. */\n    \"emitDecoratorMetadata\": true          /* Enables experimental support for emitting type metadata for decorators. */\n  }\n}\n```"}
{"id": "docs\\project\\tsconfig.md#2", "content": "These (and more) compiler options will be discussed later.\n\n### TypeScript compiler\nGood IDEs come with built in support for on the fly `ts` to `js` compilation. However, if you want to run the TypeScript compiler manually from the command line when using `tsconfig.json`, you can do it in a few ways:\n* Just run `tsc` and it will look for `tsconfig.json` in the current as well as all parent folders till it finds it.\n* Run `tsc -p ./path-to-project-directory`. Of course the path can be absolute or relative to the current directory.\n\nYou can even start the TypeScript compiler in *watch* mode using `tsc -w` and it will watch your TypeScript project files for changes."}
{"id": "docs\\quick\\browser.md#0", "content": "# TypeScript in the browser\n\n[![DesignTSX](https://raw.githubusercontent.com/basarat/typescript-book/master/images/designtsx-banner.png)](https://designtsx.com)\n\nIf you are using TypeScript to create a web application here are my recommendations to get a quick TypeScript + React (my UI framework of choice) project setup.\n\n## General Machine Setup\n\n* Install [Node.js](https://nodejs.org/en/download/)\n* Install [Git](https://git-scm.com/downloads)\n\n## Project Setup Quick\nUse [https://github.com/basarat/react-typescript](https://github.com/basarat/react-typescript) as a base. \n\n```\ngit clone https://github.com/basarat/react-typescript.git\ncd react-typescript\nnpm install\n```\n\nNow use it as a base and jump to [develop your amazing application](#develop-your-amazing-application)\n\n## Project Setup Detailed\nIf you want to learn more about the details of how that project is created (instead of using it as a base), here are the steps on how its setup from scratch:\n\n* Create a project dir:"}
{"id": "docs\\quick\\browser.md#1", "content": "```\nmkdir your-project\ncd your-project\n```\n\n* Create `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"module\": \"commonjs\",\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"experimentalDecorators\": true,\n    \"target\": \"es5\",\n    \"jsx\": \"react\",\n    \"lib\": [\n      \"dom\",\n      \"es6\"\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"compileOnSave\": false\n}\n```\n\n* Create `package.json`."}
{"id": "docs\\quick\\browser.md#2", "content": "```json\n{\n  \"name\": \"react-typescript\",\n  \"version\": \"0.0.0\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/basarat/react-typescript.git\"\n  },\n  \"scripts\": {\n    \"build\": \"webpack -p\",\n    \"start\": \"webpack-dev-server -d --content-base ./public\"\n  },\n  \"dependencies\": {\n    \"@types/react\": \"16.4.10\",\n    \"@types/react-dom\": \"16.0.7\",\n    \"clean-webpack-plugin\": \"0.1.19\",\n    \"html-webpack-plugin\": \"3.2.0\",\n    \"react\": \"16.4.2\",\n    \"react-dom\": \"16.4.2\",\n    \"ts-loader\": \"4.4.2\",\n    \"typescript\": \"3.0.1\",\n    \"webpack\": \"4.16.5\",\n    \"webpack-cli\": \"3.1.0\",\n    \"webpack-dev-server\": \"3.1.5\"\n  }\n}\n```\n\n* Create a `webpack.config.js` to bundle your modules into a single `app.js` file that contains all your resources:\n\n```js\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');"}
{"id": "docs\\quick\\browser.md#3", "content": "module.exports = {\n  entry: './src/app/app.tsx',\n  plugins: [\n    new CleanWebpackPlugin({\n      cleanAfterEveryBuildPatterns: ['public/build']\n    }),\n    new HtmlWebpackPlugin({\n      template: 'src/templates/index.html'\n    }),\n  ],\n  output: {\n    path: __dirname + '/public',\n    filename: 'build/[name].[contenthash].js'\n  },\n  resolve: {\n    extensions: ['.ts', '.tsx', '.js']\n  },\n  module: {\n    rules: [\n      { test: /\\.tsx?$/, loader: 'ts-loader' }\n    ]\n  }\n}\n```\n\n* `src/templates/index.html` file. It will be used as the template for the `index.html` generated by webpack. The generated file will be in the `public` folder and and then served from your webserver: \n\n```html\n<html>\n  <body>\n      <div id=\"root\"></div>\n  </body>\n</html>\n\n```\n\n* `src/app/app.tsx` that is your frontend application entry point: \n\n```js\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';"}
{"id": "docs\\quick\\browser.md#4", "content": "const Hello: React.FunctionComponent<{ compiler: string, framework: string }> = (props) => {\n  return (\n    <div>\n      <div>{props.compiler}</div>\n      <div>{props.framework}</div>\n    </div>\n  );\n}\n\nReactDOM.render(\n  <Hello compiler=\"TypeScript\" framework=\"React\" />,\n  document.getElementById(\"root\")\n);\n```\n\n# Develop your amazing application \n\n> You can get the latest packages using `npm install typescript@latest react@latest react-dom@latest @types/react@latest @types/react-dom@latest webpack@latest webpack-dev-server@latest webpack-cli@latest ts-loader@latest clean-webpack-plugin@latest html-webpack-plugin@latest --save-exact`"}
{"id": "docs\\quick\\browser.md#5", "content": "* Do live development by running `npm start`. \n    * Visit [http://localhost:8080](http://localhost:8080)\n    * Edit the `src/app/app.tsx` (or any ts/tsx file used in some way by `src/app/app.tsx`) and application live reloads. \n    * Edit the `src/templates/index.html` and the server live reloads.\n* Build production assets by running `npm run build`. \n    * Serve the `public` folder (which contains the built assets) from your server."}
{"id": "docs\\quick\\library.md#0", "content": "# Creating TypeScript node modules\n\n* [A lesson on creating TypeScript node modules](https://egghead.io/lessons/typescript-create-high-quality-npm-packages-using-typescript)\n\nUsing modules written in TypeScript is super fun as you get great compile time safety and autocomplete (essentially executable documentation).\n\nTypeScript modules can be consumed both in the nodejs (as is) browser (with something like webpack).\n\nCreating a high quality TypeScript module is simple. Assume the following desired folder structure for your package:\n\n```text\npackage\n\u251c\u2500 package.json\n\u251c\u2500 tsconfig.json\n\u251c\u2500 src\n\u2502  \u251c\u2500 index.ts\n\u2502  \u251c\u2500 foo.ts\n\u2502  \u2514\u2500 ...All your source files (Authored)\n\u2514\u2500 lib\n  \u251c\u2500 index.d.ts.map\n  \u251c\u2500 index.d.ts\n  \u251c\u2500 index.js\n  \u251c\u2500 foo.d.ts.map\n  \u251c\u2500 foo.d.ts\n  \u251c\u2500 foo.js\n  \u2514\u2500 ... All your compiled files (Generated)\n```"}
{"id": "docs\\quick\\library.md#1", "content": "* `src/index.ts`: Here you would export anything you expect to be consumed from your project. E.g `export { Foo } from './foo';`. Exporting from this file makes it available for consumption when someone does `import { /* Here */ } from 'example';`\n\n* In your `tsconfig.json`\n  * have `compilerOptions`: `\"outDir\": \"lib\"` + `\"declaration\": true` + `\"declarationMap\" : true` < This generates `.js` (JavaScript) `.d.ts` (declarations for TypeSafety) and `.d.ts.map` (enables `declaration .d.ts` => `source .ts` IDE navigation) in the lib folder.\n  * have `include: [\"src\"]` < This includes all the files from the `src` dir.\n\n* In your `package.json` have\n  * `\"main\": \"lib/index\"` < This tells to load `lib/index.js` for runtime code.\n  * `\"types\": \"lib/index\"` < This tells TypeScript to load `lib/index.d.ts` for type checking."}
{"id": "docs\\quick\\library.md#2", "content": "Example package:\n* `npm install typestyle` [for TypeStyle](https://www.npmjs.com/package/typestyle)\n* Usage: `import { style } from 'typestyle';` will be completely type safe."}
{"id": "docs\\quick\\library.md#3", "content": "### Managing Dependencies\n#### devDependencies\n* If your package depends on another package while you are developing it (e.g. `prettier`) you should install them as a `devDependency`. This way they will not pollute the `node_modules` of your module's consumers (as `npm i foo` does not install `devDependencies` of `foo`).\n* `typescript` is normally a `devDependency` as you only use it to build your package. The consumers can use your package with or without TypeScript.\n* If your package depends on other JavaScript authored packages and you want to use it with type safety in your project, put their types (e.g. `@types/foo`) in `devDependencies`. JavaScript types should be managed *out of bound* from the main NPM streams. The JavaScript ecosystem breaks types without semantic versioning too commonly, so if your users need types for these they should install the `@types/foo` version that works for them. If you want to guide users to install these types you can put them in `peerDependencies` mentioned next."}
{"id": "docs\\quick\\library.md#4", "content": "#### peerDependencies\nIf your package depends on a package that it heavily *works with* (as opposed to *works using*) e.g. `react`, put them in `peerDependencies` just like you would with raw JS packages. To test them locally you should also put them in `devDependencies`. \n\nNow: \n* When you are developing the package you will get the version of the dependency you specified in your `devDependencies`. \n* When someone installs your package they will *not* get this dependency (as `npm i foo` does not install `devDependencies` of `foo`) but they will get a warning that they should install the missing `peerDependencies` of your package. \n\n#### dependencies\nIf your package *wraps* another package (meant for internal use even after compilation) you should put them in `dependencies`. Now when someone installs your package they will get your package + any of its dependencies."}
{"id": "docs\\quick\\nodejs.md#0", "content": "# TypeScript with Node.js\nTypeScript has had *first class* support for Node.js since inception. Here's how to setup a quick Node.js project:\n\n> Note: many of these steps are actually just common practice Node.js setup steps\n\n1. Setup a Node.js project `package.json`. Quick one : `npm init -y`\n1. Add TypeScript (`npm install typescript --save-dev`)\n1. Add `node.d.ts` (`npm install @types/node --save-dev`)\n1. Init a `tsconfig.json` for TypeScript options with a few key options in your tsconfig.json (`npx tsc --init --rootDir src --outDir lib --esModuleInterop --resolveJsonModule --lib es6,dom  --module commonjs`)\n\nThat's it! Fire up your IDE (e.g. `code .`) and play around. Now you can use all the built in node modules (e.g. `import * as fs from 'fs';`) with all the safety and developer ergonomics of TypeScript! \n\nAll your TypeScript code goes in `src` and the generated JavaScript goes in `lib`."}
{"id": "docs\\quick\\nodejs.md#1", "content": "## Bonus: Live compile + run\n* Add `ts-node` which we will use for live compile + run in node (`npm install ts-node --save-dev`)\n* Add `nodemon` which will invoke `ts-node` whenever a file is changed (`npm install nodemon --save-dev`)\n\nNow just add a `script` target to your `package.json` based on your application entry e.g. assuming its `index.ts`:\n\n```json\n  \"scripts\": {\n    \"start\": \"npm run build:live\",\n    \"build\": \"tsc -p .\",\n    \"build:live\": \"nodemon --watch 'src/**/*.ts' --exec \\\"ts-node\\\" src/index.ts\"\n  },\n```\n\nSo you can now run `npm start` and as you edit `index.ts`:\n\n* nodemon reruns its command (ts-node)\n* ts-node transpiles automatically picking up tsconfig.json and the installed TypeScript version,\n* ts-node runs the output JavaScript through Node.js.\n\nAnd when you are ready to deploy your JavaScript application run `npm run build`.\n\n\n## Bonus points\n\nSuch NPM modules work just fine with browserify (using tsify) or webpack (using ts-loader)."}
{"id": "docs\\staging\\async-await.md#0", "content": "### Async - Await"}
{"id": "docs\\staging\\generators.md#0", "content": "### Generators\nAlso called `function *`, generators allow you to create functions whose execution can be paused and then later resumed maintaining the state between pause-resume transitions. The value returned from a generator is called an `iterator` and can be used to control this `pause-resume` transition.\n\nHere is a simple example of a generator function that generates an *infinite* list of whole numbers.\n\n```ts\nfunction* wholeNumbers() {\n    var current = 0;\n    while(true) {\n        yield current++;\n    }\n}\n```\n\nThe `yield` contextual keyword is used to return control from a generator (effectively pausing function execution) along with an optional value (here `current`). You can get access to this value using the `iterator`'s `.next()` member function, this is shown below:"}
{"id": "docs\\staging\\generators.md#1", "content": "```ts\nfunction* wholeNumbers() {\n    var current = 0;\n    while(true) {\n        yield current++;\n    }\n}\nvar iterator = wholeNumbers();\nconsole.log(iterator.next()); // 0\nconsole.log(iterator.next()); // 1\nconsole.log(iterator.next()); // 2\n// so on till infinity....\n```\n\nNow that you have seen `function*`, `yield` and `.next()` we can dig deeper.\n\n#### Catching Errors\nAny errors thrown (intentionally using `throw` or unintentionally due to error) from the generator can be caught using `try/catch` just like normal function executions. This is demonstrated below:"}
{"id": "docs\\staging\\generators.md#2", "content": "```ts\nfunction* wholeNumbers() {\n    var current = 0;\n    while(true) {\n      if (current === 3)\n        throw new Error('3 is the magic number');\n      else\n        yield current++;\n    }\n}\nvar iterator = wholeNumbers();\nconsole.log(iterator.next()); // 0\nconsole.log(iterator.next()); // 1\nconsole.log(iterator.next()); // 2\ntry {\n    console.log(iterator.next()); // Will throw an error\n}\ncatch(ex) {\n    console.log(ex.message); // 3 is the magic number\n}\n```\n\n#### Controlling function execution externally\nThe iterator returned from the generator function can be used to control the state *inside* the generator function as well.\n\n// TODO: example"}
{"id": "docs\\state\\mobx.md#0", "content": "## MobX \n\n> [PRO Egghead course on MobX TypeScript React](https://egghead.io/courses/develop-react-applications-with-mobx-and-typescript)"}
{"id": "docs\\styleguide\\styleguide.md#0", "content": "# TypeScript Style Guide and Coding Conventions\n\n> An unofficial TypeScript Style Guide\n\nPeople have asked me for my opinions on this. Personally I don't enforce these a lot on my teams and projects but it does help to have these mentioned as a tiebreaker when someone feels the need to have such strong consistency. There are other things that I feel much more strongly about and those are covered in the [tips chapter](../tips/main.md) (e.g. type assertion is bad, property setters are bad) \ud83c\udf39.\n\nKey Sections:\n\n* [Variable](#variable-and-function)\n* [Class](#class)\n* [Interface](#interface)\n* [Type](#type)\n* [Namespace](#namespace)\n* [Enum](#enum)\n* [`null` vs. `undefined`](#null-vs-undefined)\n* [Formatting](#formatting)\n* [Single vs. Double Quotes](#quotes)\n* [Tabs vs. Spaces](#spaces)\n* [Use semicolons](#semicolons)\n* [Annotate Arrays as `Type[]`](#array)\n* [File Names](#filename)\n* [`type` vs `interface`](#type-vs-interface)\n* [`==` or `===`](#-or-)"}
{"id": "docs\\styleguide\\styleguide.md#1", "content": "## Variable and Function\n* Use `camelCase` for variable and function names\n\n> Reason: Conventional JavaScript\n\n**Bad**\n```ts\nvar FooVar;\nfunction BarFunc() { }\n```\n**Good**\n```ts\nvar fooVar;\nfunction barFunc() { }\n```\n\n## Class\n* Use `PascalCase` for class names.\n\n> Reason: This is actually fairly conventional in standard JavaScript.\n\n**Bad**\n```ts\nclass foo { }\n```\n**Good**\n```ts\nclass Foo { }\n```\n* Use `camelCase` of class members and methods\n\n> Reason: Naturally follows from variable and function naming convention.\n\n**Bad**\n```ts\nclass Foo {\n    Bar: number;\n    Baz() { }\n}\n```\n**Good**\n```ts\nclass Foo {\n    bar: number;\n    baz() { }\n}\n```\n## Interface\n\n* Use `PascalCase` for name.\n\n> Reason: Similar to class\n\n* Use `camelCase` for members.\n\n> Reason: Similar to class\n\n* **Don't** prefix with `I`\n\n> Reason: Unconventional. `lib.d.ts` defines important interfaces without an `I` (e.g. Window, Document etc).\n\n**Bad**\n```ts\ninterface IFoo {\n}\n```\n**Good**\n```ts\ninterface Foo {\n}\n```"}
{"id": "docs\\styleguide\\styleguide.md#2", "content": "## Type\n\n* Use `PascalCase` for name.\n\n> Reason: Similar to class\n\n* Use `camelCase` for members.\n\n> Reason: Similar to class\n\n\n## Namespace\n\n* Use `PascalCase` for names\n\n> Reason: Convention followed by the TypeScript team. Namespaces are effectively just a class with static members. Class names are `PascalCase` => Namespace names are `PascalCase`\n\n**Bad**\n```ts\nnamespace foo {\n}\n```\n**Good**\n```ts\nnamespace Foo {\n}\n```\n\n## Enum\n\n* Use `PascalCase` for enum names\n\n> Reason: Similar to Class. Is a Type.\n\n**Bad**\n```ts\nenum color {\n}\n```\n**Good**\n```ts\nenum Color {\n}\n```\n\n* Use `PascalCase` for enum member\n\n> Reason: Convention followed by TypeScript team i.e. the language creators e.g `SyntaxKind.StringLiteral`. Also helps with translation (code generation) of other languages into TypeScript.\n\n**Bad**\n```ts\nenum Color {\n    red\n}\n```\n**Good**\n```ts\nenum Color {\n    Red\n}\n```\n\n## Null vs. Undefined\n\n* Prefer not to use either for explicit unavailability"}
{"id": "docs\\styleguide\\styleguide.md#3", "content": "> Reason: these values are commonly used to keep a consistent structure between values. In TypeScript you use *types* to denote the structure\n\n**Bad**\n```ts\nlet foo = { x: 123, y: undefined };\n```\n**Good**\n```ts\nlet foo: { x: number, y?: number } = { x:123 };\n```\n\n* Use `undefined` in general (do consider returning an object like `{valid:boolean, value?:Foo}` instead)\n\n**Bad**\n```ts\nreturn null;\n```\n**Good**\n```ts\nreturn undefined;\n```\n\n* Use `null` where it's a part of the API or conventional\n\n> Reason: It is conventional in Node.js e.g. `error` is `null` for NodeBack style callbacks.\n\n**Bad**\n```ts\ncb(undefined)\n```\n**Good**\n```ts\ncb(null)\n```\n\n* Use *truthy* check for **objects** being `null` or `undefined`\n\n**Bad**\n```ts\nif (error === null)\n```\n**Good**\n```ts\nif (error)\n```\n\n* Use `== null` / `!= null` (not `===` / `!==`) to check for `null` / `undefined` on primitives as it works for both `null`/`undefined` but not other falsy values (like `''`, `0`, `false`) e.g."}
{"id": "docs\\styleguide\\styleguide.md#4", "content": "**Bad**\n```ts\nif (error !== null) // does not rule out undefined\n```\n**Good**\n```ts\nif (error != null) // rules out both null and undefined\n```\n\n## Formatting\nThe TypeScript compiler ships with a very nice formatting language service. Whatever output it gives by default is good enough to reduce the cognitive overload on the team.\n\nUse [`tsfmt`](https://github.com/vvakame/typescript-formatter) to automatically format your code on the command line. Also, your IDE (atom/vscode/vs/sublime) already has formatting support built-in.\n\nExamples:\n```ts\n// Space before type i.e. foo:<space>string\nconst foo: string = \"hello\";\n```\n\n## Quotes\n\n* Prefer single quotes (`'`) unless escaping."}
{"id": "docs\\styleguide\\styleguide.md#5", "content": "> Reason: More JavaScript teams do this (e.g. [airbnb](https://github.com/airbnb/javascript), [standard](https://github.com/feross/standard), [npm](https://github.com/npm/npm), [node](https://github.com/nodejs/node), [google/angular](https://github.com/angular/angular/), [facebook/react](https://github.com/facebook/react)). It's easier to type (no shift needed on most keyboards). [Prettier team recommends single quotes as well](https://github.com/prettier/prettier/issues/1105)\n\n> Double quotes are not without merit: Allows easier copy paste of objects into JSON. Allows people to use other languages to work without changing their quote character. Allows you to use apostrophes e.g. `He's not going.`. But I'd rather not deviate from where the JS Community is fairly decided.\n\n* When you can't use double quotes, try using back ticks (\\`).\n\n> Reason: These generally represent the intent of complex enough strings.\n\n## Spaces\n\n* Use `2` spaces. Not tabs."}
{"id": "docs\\styleguide\\styleguide.md#6", "content": "> Reason: More JavaScript teams do this (e.g. [airbnb](https://github.com/airbnb/javascript), [idiomatic](https://github.com/rwaldron/idiomatic.js), [standard](https://github.com/feross/standard), [npm](https://github.com/npm/npm), [node](https://github.com/nodejs/node), [google/angular](https://github.com/angular/angular/), [facebook/react](https://github.com/facebook/react)). The TypeScript/VSCode teams use 4 spaces but are definitely the exception in the ecosystem.\n\n## Semicolons\n\n* Use semicolons."}
{"id": "docs\\styleguide\\styleguide.md#7", "content": "> Reasons: Explicit semicolons helps language formatting tools give consistent results. Missing ASI (automatic semicolon insertion) can trip new devs e.g. `foo() \\n (function(){})` will be a single statement (not two). TC39 [warning on this as well](https://github.com/tc39/ecma262/pull/1062). Example teams: [airbnb](https://github.com/airbnb/javascript), [idiomatic](https://github.com/rwaldron/idiomatic.js), [google/angular](https://github.com/angular/angular/), [facebook/react](https://github.com/facebook/react), [Microsoft/TypeScript](https://github.com/Microsoft/TypeScript/).\n\n## Array\n\n* Annotate arrays as `foos: Foo[]` instead of `foos: Array<Foo>`.\n\n> Reasons: It's easier to read. It's used by the TypeScript team. Makes easier to know something is an array as the mind is trained to detect `[]`.\n\n## Filename\nName files with `camelCase`. E.g. `utils.ts`, `map.ts` etc.\n\n> Reason: Conventional across many JS teams."}
{"id": "docs\\styleguide\\styleguide.md#8", "content": "When the file exports a component and your framework (like React) wants component to be PascalCased, use pascal case file name to match e.g. `Accordion.tsx`, `MyControl.tsx`. \n\n> Reason: Helps with consistency (little overthought required) and its what the ecosystem is doing.\n\n## type vs. interface\n\n* Use `type` when you *might* need a union or intersection:\n\n```\ntype Foo = number | { someProperty: number }\n```\n* Use `interface` when you want `extends` or `implements` e.g.\n\n```\ninterface Foo {\n  foo: string;\n}\ninterface FooBar extends Foo {\n  bar: string;\n}\nclass X implements FooBar {\n  foo: string;\n  bar: string;\n}\n```\n* Otherwise use whatever makes you happy that day. I use [type](https://www.youtube.com/watch?v=IXAT3If0pGI)\n\n## `==` or `===`\nBoth are [mostly safe for TypeScript users](https://www.youtube.com/watch?v=vBhRXMDlA18). I use `===` as that is what is used in the TypeScript codebase."}
{"id": "docs\\testing\\cypress.md#0", "content": "# Why Cypress\nCypress is a great E2E testing tool. Here are a few great reasons to consider it:\n\n* Isolated installation possible.\n* Ships with TypeScript support out of the box.\n* Provides a nice interactive google chrome debug experience. This is very similar to how UI devs mostly work manually.\n* Has command - execution separation which allows for more powerful debugging and test stability (more on this below).\n* Has implicit assertions to provide more meaningful debug experience with less brittle tests (more on this in the tips below).\n* Provides the ability to mock out and observe backend XHRs easily without changing your application code (more on this in the tips below).\n\n## Installation\nThe steps provided in this installation process will give you a nice `e2e` folder that you can copy/paste or as boiler plate for your organization.\n\n> Same steps presented in a video format over at my [youtube channel](https://www.youtube.com/watch?v=n3SvvZSWwfM)."}
{"id": "docs\\testing\\cypress.md#1", "content": "Create an e2e directory, install cypress, TypeScript and setup the typescript and cypress config files:\n\n```sh\nmkdir e2e\ncd e2e\nnpm init -y\nnpm install cypress typescript\nnpx tsc --init --types cypress --lib dom,es6\necho {} > cypress.json \n```\n\n> Here are a few reasons for creating a separate `e2e` folder especially for cypress:\n* Creating a separate directory or `e2e` makes it easier to isolate its `package.json` dependencies from the rest of your project. This results in less dependency conflicts.\n* Testing frameworks have a habit of polluting the global namespace with stuff like `describe` `it` `expect`. It is best to keep the e2e `tsconfig.json` and `node_modules` in this special `e2e` folder to prevent global type definition conflicts.\n\nAdd a few scripts to the `e2e/package.json` file:\n\n```json\n  \"scripts\": {\n    \"cypress:open\": \"cypress open\",\n    \"cypress:run\": \"cypress run\"\n  },\n```\n\nWrite your first test under `cypress/integration/basic.ts`:"}
{"id": "docs\\testing\\cypress.md#2", "content": "```ts\nit('should perform basic google search', () => {\n  cy.visit('https://google.com');\n  cy.get('[name=\"q\"]')\n    .type('subscribe')\n    .type('{enter}');\n});\n```\n\nNow run `npm run cypress:open` during development and `npm run cypress:run` on your build server \ud83c\udf39\n\n## More description of key Files\nUnder the `e2e` folder you now have these files:\n\n* `/cypress.json`: Configure cypress. The default is empty and that is all you need.\n* `/cypress` Subfolders:\n    * `/integration`: All your tests.\n        * Feel free to create tests under subfolders for better organization e.g. `/someFeatureFolder/something.spec.ts`.\n\n## First test\n* create a file `/cypress/integration/first.ts` with the following contents:\n\n```ts\ndescribe('google search', () => {\n  it('should work', () => {\n    cy.visit('http://www.google.com');\n    cy.get('#lst-ib').type('Hello world{enter}')\n  });\n});\n```\n\n## Running in development\nOpen the cypress IDE using the following command.\n\n```sh\nnpm run cypress:open\n```"}
{"id": "docs\\testing\\cypress.md#3", "content": "And select a test to run.\n\n## Running on a build server\n\nYou can run cypress tests in ci mode using the following command.\n\n```sh\nnpm run cypress:run\n```\n\n## Tip: Sharing code between UI and test\nCypress tests are compiled / packed and run in the browser. So feel free to import any project code into your test.\n\nFor example you can share Id values between UI and Tests to make sure the CSS selectors don't break:\n\n```js\nimport { Ids } from '../../../src/app/constants';\n\n// Later\ncy.get(`#${Ids.username}`)\n  .type('john')\n```\n\n## Tip: Creating Page Objects\nCreating objects that provide a convenient handle for all the interactions that various tests need to do with a page is a common testing convention. You can create page objects using TypeScript classes with getters and methods e.g.\n\n```js\nimport { Ids } from '../../../src/app/constants';\n\nclass LoginPage {\n  visit() {\n    cy.visit('/login');\n  }"}
{"id": "docs\\testing\\cypress.md#4", "content": "get username() {\n    return cy.get(`#${Ids.username}`);\n  }\n}\nconst page = new LoginPage();\n\n// Later\npage.visit();\n\npage.username.type('john');\n\n```\n\n## Tip: Explicit assertion\nCypress ships with (built in) chai and chai-query assertion libraries to help testing webpages. You use them with `.should` command passing in the chainer as a string, replacing `.to.foo` with `should('foo')` e.g. with chai-jquery you would `expect($(#foo)).to.have.text('something')`, with cypress you would `cy.get('#foo').should('have.text', 'something')`:\n\n```\ncy.get('#foo')\n  .should('have.text', 'something')\n```\n> You get intellisense for `should` chainers as cypress ships with correct TypeScript definitions \ud83d\udc4d\ud83c\udffb\n\nThe complete list of chainers is available here : https://docs.cypress.io/guides/references/assertions.html\n\nIf you want something complex you can even use `should(callback)` and e.g."}
{"id": "docs\\testing\\cypress.md#5", "content": "```\ncy.get('div')\n  .should(($div) => {\n    expect($div).to.have.length(1);\n    expect($div[0].className).to.contain('heading');\n  })\n// This is just an example. Normally you would `.should('have.class', 'heading')\n```\n\n> TIP: cypress with do automatic retries on the callback as well, so they are just as flake free as standard string chainers.\n\n## Tip: Commands and Chaining\nEvery function call in a cypress chain is a `command`. The `should` command is an assertion. It is conventional to start distinct *category* of chains and actions separately e.g.\n\n```ts\n// Don't do this\ncy.get(/**something*/)\n  .should(/**something*/)\n  .click()\n  .should(/**something*/)\n  .get(/**something else*/)\n  .should(/**something*/)\n\n// Prefer separating the two gets\ncy.get(/**something*/)\n  .should(/**something*/)\n  .click()\n  .should(/**something*/)\n\ncy.get(/**something else*/)\n  .should(/**something*/)\n```"}
{"id": "docs\\testing\\cypress.md#6", "content": "Some other libraries *evaluate and run* the code at the same time. Those libraries force you to have a single chain which can be nightmare to debug with selectors and assertions mingled in.\n\nCypress commands are essentially *declarations* to the cypress runtime to execute the commands later. Simple words: Cypress makes it easier.\n\n## Tip: Using `contains` for easier querying\n\nThe following shows an example:\n\n```\ncy.get('#foo')\n  // Once #foo is found the following:\n  .contains('Submit')\n  .click()\n  // ^ will continue to search for something that has text `Submit` and fail if it times out.\n  // ^ After it is found trigger a click on the HTML Node that contained the text `Submit`.\n```"}
{"id": "docs\\testing\\cypress.md#7", "content": "## Tip: Smart delays and retries\nCypress will automatically wait (and retry) for many async things e.g.\n```\n// If there is no request against the `foo` alias cypress will wait for 4 seconds automatically\ncy.wait('@foo')\n// If there is no element with id #foo cypress will wait for 4 seconds automatically and keep retrying\ncy.get('#foo')\n```\nThis keeps you from having to constantly add arbitrary timeout (and retry) logic in your test code flow.\n\n## Tip: Implicit assertion\nCypress has a concept of implicit assertion. These kick in if a future command is erroring because of a previous command. E.g. the following will error at `contains` (after automatic retries of course) as nothing found can get `click`ed:\n\n```ts\ncy.get('#foo')\n  // Once #foo is found the following:\n  .contains('Submit')\n  .click()\n  // ^ Error: #foo does not have anything that `contains` `'Submit'`\n```"}
{"id": "docs\\testing\\cypress.md#8", "content": "In traditional frameworks you would get a horrible error like `click` doesn't exist on `null`. In Cypress you get a nice error `#foo` does not contain `Submit`. This error is a form of an implicit assertion.\n\n## Tip: Waiting for an HTTP request\nA lot of tests have been traditionally brittle due to all the arbitrary timeouts needed for XHRs that an application makes. `cy.server` makes it easy to\n* create an alias for backend calls\n* wait for them to occur\n\ne.g.\n\n```ts\ncy.server()\n  .route('POST', 'https://example.com/api/application/load')\n  .as('load') // create an alias\n\n// Start test\ncy.visit('/')\n\n// wait for the call\ncy.wait('@load')\n\n// Now the data is loaded\n```\n\n## Tip: Mocking an HTTP request response\nYou can also easily mock out a request response using `route`:\n```ts\ncy.server()\n  .route('POST', 'https://example.com/api/application/load', /* Example payload response */{success:true});\n```"}
{"id": "docs\\testing\\cypress.md#9", "content": "### Tip: Asserting an Http request response\nYou can assert requests without mocking using `route` `onRequest` / `onResponse` e.g.\n\n```ts\ncy.route({\n  method: 'POST',\n  url: 'https://example.com/api/application/load',\n  onRequest: (xhr) => {\n    // Example assertion\n    expect(xhr.request.body.data).to.deep.equal({success:true});\n  }\n})\n```\n\n## Tip: Mocking time\nYou can use `wait` to pause a test for some time e.g. to test an automatic \"you are about to be logged out\" notification screen:\n\n```ts\ncy.visit('/');\ncy.wait(waitMilliseconds);\ncy.get('#logoutNotification').should('be.visible');\n```\n\nHowever, it is recommended to mock time using `cy.clock` and forwarding time using `cy.tick` e.g.\n\n```ts\ncy.clock();\n\ncy.visit('/');\ncy.tick(waitMilliseconds);\ncy.get('#logoutNotification').should('be.visible');\n```\n\n## Tip: Unit testing application code\nYou can also use cypress to unit test your application code in isolation e.g.\n\n```js\nimport { once } from '../../../src/app/utils';"}
{"id": "docs\\testing\\cypress.md#10", "content": "// Later\nit('should only call function once', () => {\n  let called = 0;\n  const callMe = once(()=>called++);\n  callMe();\n  callMe();\n  expect(called).to.equal(1);\n});\n```\n\n## Tip: Mocking in unit testing\nIf you are unit testing modules in your application you can provide mocks using `cy.stub` e.g. if you want to ensure that `navigate` is called in a function `foo`:\n\n* `foo.ts`\n\n```ts\nimport { navigate } from 'takeme';\n\nexport function foo() {\n  navigate('/foo');\n}\n```\n\n* You can do this as in `some.spec.ts`:\n\n```ts\n/// <reference types=\"cypress\"/>\n\nimport { foo } from '../../../src/app/foo';\nimport * as takeme from 'takeme';\n\ndescribe('should work', () => {\n  it('should stub it', () => {\n    cy.stub(takeme, 'navigate');\n    foo();\n    expect(takeme.navigate).to.have.been.calledWith('/foo');\n  });\n});\n```"}
{"id": "docs\\testing\\cypress.md#11", "content": "## Tip: Command - execution separation\nWhen you invoke a cypress command (or assertion) e.g. `cy.get('#something')`, the function immediately returns without actually carrying out the action. What it does do, is informs the cypress test runner that you will need to carry out (execute) an action (in this case a `get`) at some point.\n\nYou are basically building a command list that the runner will then go ahead and execute. You can verify this command - execution separation with a simple test, observe that you will see the `start / between / end` `console.log` statements execute immediately before the runner starts *executing* the commands:\n\n```ts\n/// <reference types=\"cypress\"/>\n\ndescribe('Hello world', () => {\n  it('demonstrate command - execution separation', () => {\n    console.log('start');\n    cy.visit('http://www.google.com');\n    console.log('between');\n    cy.get('.gLFyf').type('Hello world');\n    console.log('end');\n  });\n});\n```"}
{"id": "docs\\testing\\cypress.md#12", "content": "This command execution separation has two big benefits:\n* The runner can execute the commands in a *flake resistant* manner with automatic retries and implicit assertions.\n* Allows you to write asynchronous code in a synchronous fashion without having to do a constant *chaining* which results in difficult to maintain code.\n\n## Tip: Breakpoint\nThe automatic snapshots + command log generated by the cypress test are great for debugging. That said you can pause test execution if you want.\n\nFirst make sure you have chrome developer tools (lovingly called dev tools) open in the test runner (`CMD + ALT + i` on mac / `F12` on windows). Once the dev tools are open you can re-run the test and the dev tools will stay open. If you have the dev tools open, you can pause test execution in two ways:"}
{"id": "docs\\testing\\cypress.md#13", "content": "* Application code breakpoints: Use a `debugger` statement in your application code and the test runner will stop on that just like standard web development.\n* Test code breakpoints: You can use the `.debug()` command and cypress test execution will stop at it. Alternatively you can use a `debugger` statement in a `.then` command callback to cause a pause. e.g `.then(() => { debugger })`. You can even use it to grab some element `cy.get('#foo').then(($ /* a reference to the dom element */) => { debugger; })` or a network call e.g. `cy.request('https://someurl').then((res /* network response */) => { debugger });`. However idiomatic way is `cy.get('#foo').debug()` and then when the test runner is paused on `debug` you can click on the `get` in the command log to automatically `console.log` any information you might need about the `.get('#foo')` command (and similarly for any other commands you want to debug)."}
{"id": "docs\\testing\\cypress.md#14", "content": "## Tip: Start server and test\nIf you need to start a local server before your tests can run you can add `start-server-and-test` https://github.com/bahmutov/start-server-and-test as a dependency. It takes the following arguments\n* an npm script to *run* the server (aka server)\n* an endpoint to check if the server has booted up (aka start)\n* an npm script to initiate the testing (aka test)\n\nExample package.json:\n```json\n{\n    \"scripts\": {\n        \"start-server\": \"npm start\",\n        \"run-tests\": \"mocha e2e-spec.js\",\n        \"ci\": \"start-server-and-test start-server http://localhost:8080 run-tests\"\n    }\n}\n```"}
{"id": "docs\\testing\\cypress.md#15", "content": "## Resources\n* Website: https://www.cypress.io/\n* Write your first cypress test (gives a nice tour of the cypress IDE) : https://docs.cypress.io/guides/getting-started/writing-your-first-test.html\n* Setting up a CI environment (e.g. the provided docker image that works out of the box with `cypress run`): https://docs.cypress.io/guides/guides/continuous-integration.html\n* Recipes (Lists recipes with descriptions. Click on headings to navigate to the source code for the recipe): https://docs.cypress.io/examples/examples/recipes.html\n* Visual Testing : https://docs.cypress.io/guides/tooling/visual-testing.html\n* Optionally set a `baseUrl` in cypress.json to [prevent an initial reload that happens after first `visit`.](https://github.com/cypress-io/cypress/issues/2542)\n* Code coverage with cypress: [Webcast](https://www.youtube.com/watch?v=C8g5X4vCZJA)"}
{"id": "docs\\testing\\intro.md#0", "content": "# Testing\nTypeScript can be used with any JavaScript testing framework that you want. In the worst case you can always do a simple `TypeScript -> JavaScript` transform and go your merry way. \n\nThat said, in this section look at options that we have enjoyed greatly \ud83c\udf39"}
{"id": "docs\\testing\\jest.md#0", "content": "# Using Jest with TypeScript\n\n> [Pro egghead lesson on Jest / TypeScript](https://egghead.io/lessons/typescript-getting-started-with-jest-using-typescript)\n\nNo testing solution out there is perfect. That said, jest is an excellent unit testing option which provides great TypeScript support.\n\n> Note: We assume you start off with a simple node package.json setup. Also all TypeScript files should be in a `src` folder which is always recommended (even without Jest) for a clean project setup.\n\n## Step 1: Install\n\nInstall the following using npm:\n\n```shell\nnpm i jest @types/jest ts-jest typescript -D\n```\n\nExplanation:"}
{"id": "docs\\testing\\jest.md#1", "content": "* Install `jest` framework (`jest`)\n* Install the types for `jest` (`@types/jest`)\n* Install the TypeScript preprocessor for jest (`ts-jest`) which allows jest to transpile TypeScript on the fly and have source-map support built in.\n* Install the TypeScript compiler ('typescript') which is prerequisite for 'ts-jest'.\n* Save all of these to your dev dependencies (testing is almost always a npm dev-dependency)\n\n## Step 2: Configure Jest\n\nAdd the following `jest.config.js` file to the root of your project:\n\n```js\nmodule.exports = {\n  \"roots\": [\n    \"<rootDir>/src\"\n  ],\n  \"testMatch\": [\n    \"**/__tests__/**/*.+(ts|tsx|js)\",\n    \"**/?(*.)+(spec|test).+(ts|tsx|js)\"\n  ],\n  \"transform\": {\n    \"^.+\\\\.(ts|tsx)$\": \"ts-jest\"\n  },\n}\n```\n\n(If your `package.json` file contains `\"type\": \"module\"`, which causes Node to assume modules are in es6 format, you can convert the above to es6 format by replacing the top line to `export default { ` .)\n\nExplanation:"}
{"id": "docs\\testing\\jest.md#2", "content": "* We always recommend having *all* TypeScript files in a `src` folder in your project. We assume this is true and specify this using the `roots` option.\n* The `testMatch` config is a glob pattern matcher for discovering .test / .spec files in ts / tsx / js format.\n* The `transform` config just tells `jest` to use `ts-jest` for ts / tsx files.\n\n## Step 3: Run tests\n\nRun `npx jest` from your project root and jest will execute any tests you have.\n\n### Optional: Add script target for npm scripts\n\nAdd `package.json`:\n\n```json\n{\n  \"test\": \"jest\"\n}\n```\n\n* This allows you to run the tests with a simple `npm t`.\n* And even in watch mode with `npm t -- --watch`.\n\n### Optional: Run jest in watch mode\n\n* `npx jest --watch`\n\n### Example\n\n* For a file `foo.ts`:\n\n    ```js\n    export const sum\n      = (...a: number[]) =>\n        a.reduce((acc, val) => acc + val, 0);\n    ```\n\n* A simple `foo.test.ts`:\n\n    ```js\n    import { sum } from '../foo';"}
{"id": "docs\\testing\\jest.md#3", "content": "test('basic', () => {\n      expect(sum()).toBe(0);\n    });\n\n    test('basic again', () => {\n      expect(sum(1, 2)).toBe(3);\n    });\n    ```\n\nNotes:\n\n* Jest provides the global `test` function.\n* Jest comes prebuilt with assertions in the form of the global `expect`.\n\n### Example async\n\nJest has built-in async/await support. e.g.\n\n```js\ntest('basic',async () => {\n  expect(sum()).toBe(0);\n});\n\ntest('basic again', async () => {\n  expect(sum(1, 2)).toBe(3);\n}, 1000 /* optional timeout */);\n```\n\n### Example enzyme\n\n> [Pro egghead lesson on Enzyme / Jest / TypeScript](https://egghead.io/lessons/react-test-react-components-and-dom-using-enzyme)\n\nEnzyme allows you to test react components with dom support. There are three steps to setting up enzyme:"}
{"id": "docs\\testing\\jest.md#4", "content": "1. Install enzyme, types for enzyme, a better snapshot serializer for enzyme, enzyme-adapter-react for your react version `npm i enzyme @types/enzyme enzyme-to-json enzyme-adapter-react-16 -D`\n2. Add `\"snapshotSerializers\"` and `\"setupTestFrameworkScriptFile\"` to your `jest.config.js`:  \n\n    ```js\n    module.exports = {\n      // OTHER PORTIONS AS MENTIONED BEFORE\n\n      // Setup Enzyme\n      \"snapshotSerializers\": [\"enzyme-to-json/serializer\"],\n      \"setupFilesAfterEnv\": [\"<rootDir>/src/setupEnzyme.ts\"],\n    }\n    ```\n\n3. Create `src/setupEnzyme.ts` file.\n\n    ```js\n    import { configure } from 'enzyme';\n    import EnzymeAdapter from 'enzyme-adapter-react-16';\n    configure({ adapter: new EnzymeAdapter() });\n    ```\n\nNow here is an example react component and test:\n\n* `checkboxWithLabel.tsx`:\n\n    ```ts\n    import * as React from 'react';"}
{"id": "docs\\testing\\jest.md#5", "content": "export class CheckboxWithLabel extends React.Component<{\n      labelOn: string,\n      labelOff: string\n    }, {\n        isChecked: boolean\n      }> {\n      constructor(props) {\n        super(props);\n        this.state = { isChecked: false };\n      }\n\n      onChange = () => {\n        this.setState({ isChecked: !this.state.isChecked });\n      }\n\n      render() {\n        return (\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={this.state.isChecked}\n              onChange={this.onChange}\n            />\n            {this.state.isChecked ? this.props.labelOn : this.props.labelOff}\n          </label>\n        );\n      }\n    }\n\n    ```\n\n* `checkboxWithLabel.test.tsx`:\n\n    ```ts\n    import * as React from 'react';\n    import { shallow } from 'enzyme';\n    import { CheckboxWithLabel } from './checkboxWithLabel';"}
{"id": "docs\\testing\\jest.md#6", "content": "test('CheckboxWithLabel changes the text after click', () => {\n      const checkbox = shallow(<CheckboxWithLabel labelOn=\"On\" labelOff=\"Off\" />);\n\n      // Interaction demo\n      expect(checkbox.text()).toEqual('Off');\n      checkbox.find('input').simulate('change');\n      expect(checkbox.text()).toEqual('On');\n\n      // Snapshot demo\n      expect(checkbox).toMatchSnapshot();\n    });\n    ```\n\n## Reasons why we like jest\n\n> [For details on these features see jest website](http://facebook.github.io/jest/)\n\n* Built-in assertion library.\n* Great TypeScript support.\n* Very reliable test watcher.\n* Snapshot testing.\n* Built-in coverage reports.\n* Built-in async/await support."}
{"id": "docs\\tips\\barrel.md#0", "content": "## Barrel\n\nA barrel is a way to rollup exports from several modules into a single convenient module. The barrel itself is a module file that re-exports selected exports of other modules.\n\nImagine the following class structure in a library: \n\n```ts\n// demo/foo.ts\nexport class Foo {}\n\n// demo/bar.ts\nexport class Bar {}\n\n// demo/baz.ts\nexport class Baz {}\n```\n\nWithout a barrel, a consumer would need three import statements:\n\n```ts\nimport { Foo } from '../demo/foo';\nimport { Bar } from '../demo/bar';\nimport { Baz } from '../demo/baz';\n```\n\nYou can instead add a barrel `demo/index.ts` containing the following: \n\n```ts\n// demo/index.ts\nexport * from './foo'; // re-export all of its exports\nexport * from './bar'; // re-export all of its exports\nexport * from './baz'; // re-export all of its exports\n```\n\nNow the consumer can import what it needs from the barrel:\n\n```ts\nimport { Foo, Bar, Baz } from '../demo'; // demo/index.ts is implied\n```"}
{"id": "docs\\tips\\barrel.md#1", "content": "### Named exports\nInstead of exporting `*`, you can choose to export the module in a name. E.g., assume that `baz.ts` has functions:\n\n```ts\n// demo/foo.ts\nexport class Foo {}\n\n// demo/bar.ts\nexport class Bar {}\n\n// demo/baz.ts\nexport function getBaz() {}\nexport function setBaz() {}\n```\n\nIf you would rather not export `getBaz` / `setBaz` from demo you can instead put them in a variable by importing them in a name and exporting that name as shown below: \n\n```ts\n// demo/index.ts\nexport * from './foo'; // re-export all of its exports\nexport * from './bar'; // re-export all of its exports\n\nimport * as baz from './baz'; // import as a name\nexport { baz }; // export the name\n```\n\nAnd now the consumer would look like: \n\n```ts\nimport { Foo, Bar, baz } from '../demo'; // demo/index.ts is implied\n\n// usage\nbaz.getBaz();\nbaz.setBaz();\n// etc. ...\n```"}
{"id": "docs\\tips\\build-toggles.md#0", "content": "## Build Toggles\n\nIt is common to switch in JavaScript projects based on where they are being run. You can do this quite easily with webpack as it supports *dead code elimination* based on environment variables.\n\nAdd different targets in your `package.json` `scripts`:\n\n```json\n\"build:test\": \"webpack -p --config ./src/webpack.config.js\",\n\"build:prod\": \"webpack -p --define process.env.NODE_ENV='\\\"production\\\"' --config ./src/webpack.config.js\",\n```\n\nOf course I am assuming you have `npm install webpack --save-dev`. Now you can run `npm run build:test` etc.\n\nUsing this variable is super easy as well:\n\n```ts\n/**\n * This interface makes sure we don't miss adding a property to both `prod` and `test`\n */\ninterface Config {\n  someItem: string;\n}\n\n/**\n * We only export a single thing. The config.\n */\nexport let config: Config;"}
{"id": "docs\\tips\\build-toggles.md#1", "content": "/**\n * `process.env.NODE_ENV` definition is driven from webpack\n *\n * The whole `else` block will be removed in the emitted JavaScript\n *  for a production build\n */\nif (process.env.NODE_ENV === 'production') {\n  config = {\n    someItem: 'prod'\n  }\n  console.log('Running in prod');\n} else {\n  config = {\n    someItem: 'test'\n  }\n  console.log('Running in test');\n}\n```\n\n> We use `process.env.NODE_ENV` just because it is conventional in a lot of JavaScript libraries themselves e.g. `React`."}
{"id": "docs\\tips\\classesAreUseful.md#0", "content": "## Classes Are Useful\n\nIt is very common to have the following structure:\n\n```ts\nfunction foo() {\n    let someProperty;\n\n    // Some other initialization code\n\n    function someMethod() {\n        // Do some stuff with `someProperty`\n        // And potentially other things\n    }\n    // Maybe some other methods\n\n    return {\n        someMethod,\n        // Maybe some other methods\n    };\n}\n```\n\nThis is known as the *revealing module pattern* and quite common in JavaScript (taking advantage of JavaScript closure).\n\nIf you use [*file modules* (which you really should as global scope is bad)](../project/modules.md) then *your file is effectively the same*. However, there are too many cases where people will write code like the following:\n\n```ts\nlet someProperty;\n\nfunction foo() {\n   // Some initialization code\n}\nfoo(); // some initialization code\n\nsomeProperty = 123; // some more initialization\n\n// Some utility function not exported\n\n// later\nexport function someMethod() {\n\n}\n```"}
{"id": "docs\\tips\\classesAreUseful.md#1", "content": "Even though I am not a big fan of inheritance *I do find that letting people use classes helps them organize their code better*. The same developer would intuitively write the following:\n\n```ts\nclass Foo {\n    public someProperty;\n\n    constructor() {\n        // some initialization\n    }\n\n    public someMethod() {\n        // some code\n    }\n\n    private someUtility() {\n        // some code\n    }\n}\n\nexport = new Foo();\n```\n\nAnd its not just developers, creating dev tools that provide great visualizations over classes are much more common, and there is one less pattern your team needs to understand and maintain.\n\n> PS: There is nothing wrong in my opinion with *shallow* class hierarchies if they provide significant reuse and reduction in boiler plate."}
{"id": "docs\\tips\\create-arrays.md#0", "content": "## Creating arrays\n\nCreating an empty array is super easy: \n\n```ts\nconst foo: string[] = [];\n```\n\nIf you want an array to loop over: \n\n```ts\n[...new Array(6)]; \n```\n\nIf you want to create an array pre-filled with some content use the ES6 `Array.prototype.fill`: \n\n```ts\nconst foo: string[] = new Array(3).fill('');\nconsole.log(foo); // ['','',''];\n```\n\nIf you want to create an array of a predefined length with calls you can use the spread operator: \n\n```ts\nconst someNumbers = [...new Array(3)].map((_,i) => i * 10);\nconsole.log(someNumbers); // [0,10,20];\n```"}
{"id": "docs\\tips\\currying.md#0", "content": "## Currying\n\nJust use a chain of fat arrow functions:\n\n```ts\n// A curried function\nlet add = (x: number) => (y: number) => x + y;\n\n// Simple usage\nadd(123)(456);\n\n// partially applied\nlet add123 = add(123);\n\n// fully apply the function\nadd123(456);\n```"}
{"id": "docs\\tips\\defaultIsBad.md#0", "content": "## `export default` concerns\n\nConsider you have a file `foo.ts` with the following contents:\n\n```ts\nclass Foo {\n}\nexport default Foo;\n```\n\nYou would import it (in `bar.ts`) using ES6 syntax as follows:\n\n```ts\nimport Foo from \"./foo\";\n```\n\nThere are a few maintainability concerns here:\n* If you refactor `Foo` in `foo.ts` it will not rename it in `bar.ts`.\n* If you end up needing to export more stuff from `foo.ts` (which is what many of your files will have) then you have to juggle the import syntax.\n\nFor this reason I recommend simple exports + destructured import. E.g. `foo.ts`:\n\n```ts\nexport class Foo {\n}\n```\nAnd then:\n\n```ts\nimport { Foo } from \"./foo\";\n```\n\nBelow I also present a few more reasons.\n\n### Poor Discoverability\nDiscoverability is very poor for default exports. You cannot explore a module with intellisense to see if it has a default export or not."}
{"id": "docs\\tips\\defaultIsBad.md#1", "content": "With export default you get nothing here (maybe it does export default / maybe it doesn't `\u00af\\_(\u30c4)_/\u00af`):\n```\nimport /* here */ from 'something';\n```\n\nWithout export default you get a nice intellisense here: \n\n```\nimport { /* here */ } from 'something';\n```\n\n### Autocomplete \nIrrespective of if you know about the exports, you even autocomplete at this `import {/*here*/} from \"./foo\";` cursor location. Gives your developers a bit of wrist relief.\n\n### CommonJS interop\nWith `default` there is horrible experience for commonJS users who have to `const {default} = require('module/foo');` instead of `const {Foo} = require('module/foo')`. You will most likely want to rename the `default` export to something else when you import it.\n\n### Typo Protection\nYou don't get typos like one dev doing `import Foo from \"./foo\";` and another doing `import foo from \"./foo\";`"}
{"id": "docs\\tips\\defaultIsBad.md#2", "content": "### TypeScript auto-import\nAuto import quickfix works better. You use `Foo` and auto import will write down `import { Foo } from \"./foo\";` cause its a well defined name exported from a module. Some tools out there will try to magic read and *infer* a name for a default export but magic is flaky.\n\n### Re-exporting\nRe-exporting is common for the root `index` file in npm packages, and forces you to name the default export manually e.g. `export { default as Foo } from \"./foo\";` (with default) vs. `export * from \"./foo\"` (with named exports).\n\n### Dynamic Imports\nDefault exports expose themselves badly named as `default` in dynamic `import`s e.g. \n\n```ts\nconst HighCharts = await import('https://code.highcharts.com/js/es-modules/masters/highcharts.src.js');\nHighCharts.default.chart('container', { ... }); // Notice `.default`\n```\n\nMuch nicer with named exports:"}
{"id": "docs\\tips\\defaultIsBad.md#3", "content": "```ts\nconst {HighCharts} = await import('https://code.highcharts.com/js/es-modules/masters/highcharts.src.js');\nHighCharts.chart('container', { ... }); // Notice `.default`\n```\n\n\n### Needs two lines for non-class / non-function\n\nCan be one statement for function / class e.g. \n\n```ts\nexport default function foo() {\n}\n```\n\nCan be one statement for *non named / type annotated* objects e.g.: \n\n```ts\nexport default {\n  notAFunction: 'Yeah, I am not a function or a class',\n  soWhat: 'The export is now *removed* from the declaration'\n};\n```\n\nBut needs two statements otherwise:\n```ts\n// If you need to name it (here `foo`) for local use OR need to annotate type (here `Foo`)\nconst foo: Foo = {\n  notAFunction: 'Yeah, I am not a function or a class',\n  soWhat: 'The export is now *removed* from the declaration'\n};\nexport default foo;\n```"}
{"id": "docs\\tips\\functionParameters.md#0", "content": "# Function Parameters\n\nIf you have a function that takes too many parameters, or parameters of the same type, then you might want to consider changing the function to take an object instead. \n\nConsider the following function:\n\n```ts\nfunction foo(flagA: boolean, flagB: boolean) {\n  // your awesome function body \n}\n```\n\nWith such a function definition it's quite easy to invoke it incorrectly e.g. `foo(flagB, flagA)` and you would get no help from the compiler. \n\nInstead, convert the function to take an object: \n\n```ts\nfunction foo(config: {flagA: boolean, flagB: boolean}) {\n  const {flagA, flagB} = config;\n  // your awesome function body \n}\n```\nNow the function calls will look like `foo({flagA, flagB})` which makes it much easier to spot mistakes and code review.\n\n> Note : If your function is simple enough, and you don't expect much churn, then feel free to ignore this advice \ud83c\udf39."}
{"id": "docs\\tips\\jquery.md#0", "content": "## JQuery Tips\n\nNote: you need to install the `jquery.d.ts` file for these tips\n\n### Quickly define a new plugin \n\nJust create `jquery-foo.d.ts` with: \n\n```ts\ninterface JQuery {\n  foo: any;\n}\n```\n\nAnd now you can use `$('something').foo({whateverYouWant:'hello jquery plugin'})`"}
{"id": "docs\\tips\\lazyObjectLiteralInitialization.md#0", "content": "## Lazy Object Literal Initialization\n\nQuite commonly in JavaScript code bases you would initialize object literals in the following manner:\n\n```ts\nlet foo = {};\nfoo.bar = 123;\nfoo.bas = \"Hello World\";\n```\n\nAs soon as you move the code to TypeScript you will start to get Errors like the following:\n\n```ts\nlet foo = {};\nfoo.bar = 123; // Error: Property 'bar' does not exist on type '{}'\nfoo.bas = \"Hello World\"; // Error: Property 'bas' does not exist on type '{}'\n```\n\nThis is because from the state `let foo = {}`, TypeScript *infers* the type of `foo` (left hand side of initializing assignment) to be the type of the right hand side `{}` (i.e. an object with no properties). So, it error if you try to assign to a property it doesn't know about.\n\n### Ideal Fix\n\nThe *proper* way to initialize an object in TypeScript is to do it in the assignment:\n\n```ts\nlet foo = {\n    bar: 123,\n    bas: \"Hello World\",\n};\n```\n\nThis is also great for code review and code maintainability purposes."}
{"id": "docs\\tips\\lazyObjectLiteralInitialization.md#1", "content": "> The quick fix and middle ground *lazy* initialization patterns described below suffer from *mistakenly forgetting to initialize a property*. \n\n### Quick Fix\n\nIf you have a large JavaScript code base that you are migrating to TypeScript the ideal fix might not be a viable solution for you. In that case you can carefully use a *type assertion* to silence the compiler:\n\n```ts\nlet foo = {} as any;\nfoo.bar = 123;\nfoo.bas = \"Hello World\";\n```\n\n### Middle Ground\n\nOf course using the `any` assertion can be very bad as it sort of defeats the safety of TypeScript. The middle ground fix is to create an `interface` to ensure\n\n* Good Docs\n* Safe assignment\n\nThis is shown below:\n\n```ts\ninterface Foo {\n    bar: number\n    bas: string\n}\n\nlet foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = \"Hello World\";\n```\n\nHere is a quick example that shows the fact that using the interface can save you:\n\n```ts\ninterface Foo {\n    bar: number\n    bas: string\n}"}
{"id": "docs\\tips\\lazyObjectLiteralInitialization.md#2", "content": "let foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = \"Hello World\";\n\n// later in the codebase:\nfoo.bar = 'Hello Stranger'; // Error: You probably misspelled `bas` as `bar`, cannot assign string to number\n```"}
{"id": "docs\\tips\\main.md#0", "content": "# TIPs\nIn this section we present a number of tips that we have collected over the course of using TypeScript in the real world."}
{"id": "docs\\tips\\nominalTyping.md#0", "content": "## Nominal Typing\nThe TypeScript type system is structural [and this is one of the main motivating benefits](../why-typescript.md). However, there are real-world use cases for a system where you want two variables to be differentiated because they have a different *type name* even if they have the same structure. A very common use case is *identity* structures (which are generally just strings with semantics associated with their *name* in languages like C#/Java).\n\nThere are a few patterns that have emerged in the community. I cover them in decreasing order of personal preference:\n\n## Using literal types\n\nThis pattern uses generics and literal types: \n\n```ts\n/** Generic Id type */\ntype Id<T extends string> = {\n  type: T,\n  value: string,\n}\n\n/** Specific Id types */\ntype FooId = Id<'foo'>;\ntype BarId = Id<'bar'>;"}
{"id": "docs\\tips\\nominalTyping.md#1", "content": "/** Optional: constructors functions */\nconst createFoo = (value: string): FooId => ({ type: 'foo', value });\nconst createBar = (value: string): BarId => ({ type: 'bar', value });\n\nlet foo = createFoo('sample')\nlet bar = createBar('sample');\n\nfoo = bar; // Error\nfoo = foo; // Okay\n```\n\n* Advantages\n  - No need for any type assertions \n* Disadvantage\n  - The structure `{type,value}` might not be desireable and need server serialization support\n\n## Using Enums\n[Enums in TypeScript](../enums.md) offer a certain level of nominal typing. Two enum types aren't equal if they differ by name. We can use this fact to provide nominal typing for types that are otherwise structurally compatible.\n\nThe workaround involves:\n* Creating a *brand* enum.\n* Creating the type as an *intersection* (`&`) of the brand enum + the actual structure.\n\nThis is demonstrated below where the structure of the types is just a string:\n\n```ts\n// FOO\nenum FooIdBrand { _ = \"\" };\ntype FooId = FooIdBrand & string;"}
{"id": "docs\\tips\\nominalTyping.md#2", "content": "// BAR\nenum BarIdBrand  { _ = \"\" };\ntype BarId = BarIdBrand & string;\n\n/**\n * Usage Demo\n */\nvar fooId: FooId;\nvar barId: BarId;\n\n// Safety!\nfooId = barId; // error\nbarId = fooId; // error\n\n// Newing up\nfooId = 'foo' as FooId;\nbarId = 'bar' as BarId;\n\n// Both types are compatible with the base\nvar str: string;\nstr = fooId;\nstr = barId;\n```\n\nNote how the brand enums,  ``FooIdBrand`` and ``BarIdBrand`` above, each have single member (`_`) that maps to the empty string, as specified by ``{ _ = \"\" }``. This forces TypeScript to infer that these are string-based enums, with values of type ``string``, and not enums with values of type ``number``.  This is necessary because TypeScript infers an empty enum (``{}``) to be a numeric enum, and as of TypeScript 3.6.2 the intersection of a numeric ``enum`` and ``string`` is ``never``.\n\n## Using Interfaces"}
{"id": "docs\\tips\\nominalTyping.md#3", "content": "Because `numbers` are type compatible with `enum`s the previous technique cannot be used for them. Instead we can use interfaces to break the structural compatibility. This method is still used by the TypeScript compiler team, so worth mentioning. Using `_` prefix and a `Brand` suffix is a convention I strongly recommend (and [the one followed by the TypeScript team](https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698)).\n\nThe workaround involves the following:\n* adding an unused property on a type to break structural compatibility.\n* using a type assertion when needing to new up or cast down.\n\nThis is demonstrated below:\n\n```ts\n// FOO\ninterface FooId extends String {\n    _fooIdBrand: string; // To prevent type errors\n}\n\n// BAR\ninterface BarId extends String {\n    _barIdBrand: string; // To prevent type errors\n}\n\n/**\n * Usage Demo\n */\nvar fooId: FooId;\nvar barId: BarId;"}
{"id": "docs\\tips\\nominalTyping.md#4", "content": "// Safety!\nfooId = barId; // error\nbarId = fooId; // error\nfooId = <FooId>barId; // error\nbarId = <BarId>fooId; // error\n\n// Newing up\nfooId = 'foo' as any;\nbarId = 'bar' as any;\n\n// If you need the base string\nvar str: string;\nstr = fooId as any;\nstr = barId as any;\n```"}
{"id": "docs\\tips\\outFile.md#0", "content": "# `--outFile` is BAD {#outFile}\n\nIts a bad idea for you to use because of the following reasons:\n\n* Runtime Errors\n* Fast compile\n* Global scope\n* Hard to analyze\n* Hard to scale\n* `_references`\n* Code reuse\n* Multiple Targets\n* Isolated Compile\n\n## Runtime Errors\n\nIf your code depends on any form of js ordering you will get random errors at runtime.\n\n* **class inheritance can break at runtime.**\n\nConsider `foo.ts`: \n```ts\nclass Foo {\n    \n}\n```\n\nand a `bar.ts`:\n```ts\nclass Bar extends Foo {\n    \n}\n```\n\nIf you fail to compile it in correct order e.g. perhaps alphabetically `tsc bar.ts foo.ts` the code will compile fine but error at runtime with `ReferenceError`. \n\n* **module splitting can fail at runtime.**\n\nConsider `foo.ts`: \n```ts\nmodule App {\n    export var foo = 123;\n}\n```\nAnd `bar.ts`: \n```ts\nmodule App {\n    export var bar = foo + 456;\n}\n```"}
{"id": "docs\\tips\\outFile.md#1", "content": "If you fail to compile it in correct order e.g. perhaps alphabetically `tsc bar.ts foo.ts` the code will compile fine but  *silently* fail at runtime with `bar` set to `NaN`. \n\n## Fast compile\nIf you use `--out` then single `.ts` files cannot be codegened into single `.js` files in isolation without unnecessary hacks. `--out` essentially forces a slower incremental build.\n\nAlso source maps are positionally sensitive and run-length encoded so most of the map has to be rebuilt on a recompile if you use source maps (which you should!). At high-10s to 100s kloc combined it\u2019s going to get slow.\n\n## Global Scope\nSure you can use name spaces but its still on `window` if you run it in the browser. Namespaces are just an unnecessary workaround. Also `/// <reference` comments introduce a global context in *your code* that can get hard to maintain."}
{"id": "docs\\tips\\outFile.md#2", "content": "Also if your company has several teams working independently and then someone decides to try integrating two independently written apps there is a high likelihood of a name conflict.\n\n## Hard to analyze\nWe wish to provide more code analysis tools. These will be easier if you provide us with the dependency chain (implicitly there on a silver platter using external modules). \n\nAlso its not just the *dev tools* that have a hard time making sense of the code. The next human needs to understand a lot of the code base before they start to understand where stuff is actually imported from. Using internal modules also makes code difficult to review in isolation e.g. on github.\n\n## Hard to scale\nReally just a result of random runtime errors + slower and slower compile times + difficulty in understanding someone else's code."}
{"id": "docs\\tips\\outFile.md#3", "content": "## `_references.ts`\nIsn't supported by `tsconfig.json` : https://github.com/Microsoft/TypeScript/issues/2472#issuecomment-85330803 You'll have to manually sort the  `files` array. \n\n## Code reuse\nIf you want to reuse a portion of your code in another project, with all that *implicit* dependency management, it will be difficult to port it over without potential runtime errors. \n\n## Multiple Targets\nAlso if you decide to reuse your browser code in something like nodejs (e.g. for *testing* APIs) you are going to need to port it over to a module system or come up with ugly hacks to make the nodejs `global` your new global scope (i.e. `window`)."}
{"id": "docs\\tips\\outFile.md#4", "content": "## Isolated Compile\nFiles cannot be compiled in isolation. E.g. consider `a.ts`: \n```ts\nmodule M {\n  var s = t;\n}\n```\nWill have different output depending upon whether there is a `b.ts` of the form: \n```ts\nmodule M {\n  export var t = 5;\n}\n```\nor \n```ts\nvar t = 5;\n```\nSo `a.ts` [cannot be compiled in isolation](https://github.com/Microsoft/TypeScript/issues/2715).\n\n## Summary\n`--out` is really the job of some build tool. And even such a build tool can benefit from the dependency mentions provided by external modules. So we recommend you use external modules and then let the build tool create a single `.js` for you if you so desire.\n\nhttps://twitter.com/nycdotnet/status/613705850574778368 \n\n![The Bas Signal](https://pbs.twimg.com/media/CIRSOBmWsAQdzvP.jpg)"}
{"id": "docs\\tips\\propertySetters.md#0", "content": "## Limit usage of property setters\n\nPrefer explicit set/get functions (e.g. `setBar` and `getBar` functions) over setters/getters.\n\nConsider the following code:\n\n```ts\nfoo.bar = {\n    a: 123,\n    b: 456\n};\n```\n\nIn the presence of setter/getters:\n\n```ts\nclass Foo {\n    a: number;\n    b: number;\n    set bar(value:{a:number,b:number}) {\n        this.a = value.a;\n        this.b = value.b;\n    }\n}\nlet foo = new Foo();\n```\n\nThis is not a *good* use of property setters. The person reading the first code sample has no context about all the things that will change. Whereas someone calling `foo.setBar(value)` might have an idea that something might change on `foo`.\n\n> Bonus points: Find references works better if you have different functions. In TypeScript tools if you find references for a getter or a setter you get *both* whereas with explicit function calls you only get references to the relevant function."}
{"id": "docs\\tips\\singleton.md#0", "content": "# Singleton Pattern\n\nThe conventional singleton pattern is really something that is used to overcome the fact that all code must be in a `class`.\n\n```ts\nclass Singleton {\n    private static instance: Singleton;\n    private constructor() {\n        // do something construct...\n    }\n    static getInstance() {\n        if (!Singleton.instance) {\n            Singleton.instance = new Singleton();\n            // ... any one time initialization goes here ...\n        }\n        return Singleton.instance;\n    }\n    someMethod() { }\n}\n\nlet something = new Singleton() // Error: constructor of 'Singleton' is private.\n\nlet instance = Singleton.getInstance() // do something with the instance...\n```\n\nHowever, if you don't want lazy initialization you can instead just use a `namespace`: \n\n```ts\nnamespace Singleton {\n    // ... any one time initialization goes here ...\n    export function someMethod() { }\n}\n// Usage\nSingleton.someMethod();\n```"}
{"id": "docs\\tips\\singleton.md#1", "content": "> Warning : Singleton is just a fancy name for [global](http://stackoverflow.com/a/142450/390330)\n\nFor most projects `namespace` can additionally be replaced by a *module*.\n\n```ts\n// someFile.ts\n// ... any one time initialization goes here ...\nexport function someMethod() { }\n\n// Usage\nimport {someMethod} from \"./someFile\";\n```"}
{"id": "docs\\tips\\statefulFunctions.md#0", "content": "## Stateful Functions\nA common feature in other programming languages is usage of the `static` keyword to increase the *lifetime* (not *scope*) of a function variable to live beyond function invocations. Here is a `C` sample that achieves this:\n\n```c\nvoid called() {\n    static count = 0;\n    count++;\n    printf(\"Called : %d\", count);\n}\n\nint main () {\n    called(); // Called : 1\n    called(); // Called : 2\n    return 0;\n}\n```\n\nSince JavaScript (or TypeScript) doesn't have function statics you can achieve the same thing using various abstractions that wrap over a local variable e.g. using a `class` :\n\n```ts\nconst {called} = new class {\n    count = 0;\n    called = () => {\n        this.count++;\n        console.log(`Called : ${this.count}`);\n    }\n};\n\ncalled(); // Called : 1\ncalled(); // Called : 2\n```\n\n> C++ developers also try and achieve this using a pattern they call `functor` (a class that overrides the operator `()`)."}
{"id": "docs\\tips\\staticConstructor.md#0", "content": "# Static Constructors in TypeScript\n\nTypeScript `class` (like JavaScript `class`) cannot have a static constructor. However, you can get the same effect quite easily by just calling it yourself: \n\n```ts\nclass MyClass {\n    static initialize() {\n        // Initialization\n    }\n}\nMyClass.initialize();\n```"}
{"id": "docs\\tips\\stringEnums.md#0", "content": "## String enums\n\nSometimes you need a collection of strings collected under a common key. Prior to TypeScript 2.4, TypeScript only supported number-based enums. If using versions prior to 2.4, a work-around is to use [string literal types to create string based enums by combining with union types](../types/literal-types.md)."}
{"id": "docs\\tips\\typed-event.md#0", "content": "## Typesafe Event Emitter\n\nConventionally in Node.js and traditional JavaScript you have a single event emitter. This event emitter internally tracks listener for different event types e.g. \n\n```ts\nconst emitter = new EventEmitter();\n// Emit: \nemitter.emit('foo', foo);\nemitter.emit('bar', bar);\n// Listen: \nemitter.on('foo', (foo)=>console.log(foo));\nemitter.on('bar', (bar)=>console.log(bar));\n```\nEssentially `EventEmitter` internally stores data in the form of mapped arrays: \n```ts\n{foo: [fooListeners], bar: [barListeners]}\n```\nInstead, for the sake of *event* type safety, you can create an emitter *per* event type:\n```ts\nconst onFoo = new TypedEvent<Foo>();\nconst onBar = new TypedEvent<Bar>();\n\n// Emit: \nonFoo.emit(foo);\nonBar.emit(bar);\n// Listen: \nonFoo.on((foo)=>console.log(foo));\nonBar.on((bar)=>console.log(bar));\n```"}
{"id": "docs\\tips\\typed-event.md#1", "content": "This has the following advantages: \n* The types of events are easily discoverable as variables.\n* The event emitter variables are easily refactored independently.\n* Type safety for event data structures.\n\n### Reference TypedEvent\n```ts\nexport interface Listener<T> {\n  (event: T): any;\n}\n\nexport interface Disposable {\n  dispose();\n}\n\n/** passes through events as they happen. You will not get events from before you start listening */\nexport class TypedEvent<T> {\n  private listeners: Listener<T>[] = [];\n  private listenersOncer: Listener<T>[] = [];\n\n  on = (listener: Listener<T>): Disposable => {\n    this.listeners.push(listener);\n    return {\n      dispose: () => this.off(listener)\n    };\n  }\n\n  once = (listener: Listener<T>): void => {\n    this.listenersOncer.push(listener);\n  }\n\n  off = (listener: Listener<T>) => {\n    var callbackIndex = this.listeners.indexOf(listener);\n    if (callbackIndex > -1) this.listeners.splice(callbackIndex, 1);\n  }"}
{"id": "docs\\tips\\typed-event.md#2", "content": "emit = (event: T) => {\n    /** Update any general listeners */\n    this.listeners.forEach((listener) => listener(event));\n\n    /** Clear the `once` queue */\n    if (this.listenersOncer.length > 0) {\n      const toCall = this.listenersOncer;\n      this.listenersOncer = [];\n      toCall.forEach((listener) => listener(event));\n    }\n  }\n\n  pipe = (te: TypedEvent<T>): Disposable => {\n    return this.on((e) => te.emit(e));\n  }\n}\n```"}
{"id": "docs\\tips\\typeInstantiation.md#0", "content": "## Type Instantiation for Generics\n\nSay you have something that has a generic parameter e.g. a class `Foo`:\n\n```ts\nclass Foo<T>{\n\tfoo: T;\n}\n```\n\nYou want to create a specialized version for it for a particular type. The pattern is to copy the item into a new variable and give it the type annotation with the generics replaced with concrete types. E.g. if you want a class `Foo<number>`:\n\n```ts\nclass Foo<T>{\n\tfoo: T;\n}\nlet FooNumber = Foo as { new ():Foo<number> }; // ref 1\n```\nIn `ref 1` you are saying that `FooNumber` is the same as `Foo` but just treat it as something that when called with the `new` operator gives an instance of `Foo<Number>`.\n\n### Inheritance\nThe Type assertion pattern is unsafe in that it trusts you to do the right thing. A common pattern in other languages *for classes* is to just use inheritance :\n\n```ts\nclass FooNumber extends Foo<number>{}\n```"}
{"id": "docs\\tips\\typeInstantiation.md#1", "content": "One word of caution here: if you use decorators on the base class then the inherited class might not have the same behavior as the base class (it is no longer wrapped by the decorator).\n\nOf course if you are not specializing classes you still have to come up with a coercion / assertion pattern that works and hence we showed the general assertion pattern first, e.g.:\n\n```ts\nfunction id<T>(x: T) { return x; }\nconst idNum = id as {(x:number):number};\n```\n\n> Inspired by this [stackoverflow question](http://stackoverflow.com/a/34864705/390330)"}
{"id": "docs\\tools\\changelog.md#0", "content": "## Changelog \n> Reading a markdown file with the progress in the project is easier than reading a commit log.\n\nAutomatic changelog generation from commit messages is a fairly common pattern nowadays. There is a project called [conventional-changelog](https://github.com/conventional-changelog/conventional-changelog) that generates a changelog from commit messages that follow a *convention*. \n\n### Commit message convention\nThe most common convention is the *angular* commit messages convention which is [detailed here](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines).\n\n### Setup\n* Install: \n\n```bash\nnpm install standard-version -D\n```\n\n* Add a `script` target to your `package.json`: \n\n```js\n{\n  \"scripts\": {\n    \"release\": \"standard-version\"\n  }\n}\n```\n\n* Optionally : To automatically push the new *git commit and tag* plus publish to npm add a `postrelease` script:"}
{"id": "docs\\tools\\changelog.md#1", "content": "```js\n{\n  \"scripts\": {\n    \"release\": \"standard-version\",\n    \"postrelease\": \"git push --follow-tags origin master && npm publish\"\n  }\n}\n```\n\n### Releasing \n\nSimply run: \n\n```bash\nnpm run release\n```\n\nBased on the commit messages `major` | `minor` | `patch` is automatically determined. To *explicitly* specify a version you can specify `--release-as` e.g.: \n\n```bash\nnpm run release -- --release-as minor\n```"}
{"id": "docs\\tools\\eslint.md#0", "content": "# ESLint\n\nESLint existed to lint JavaScript, but now it is also becoming the defacto linter for [TypeScript](https://github.com/Microsoft/TypeScript/issues/29288), thanks to the [collaboration](https://eslint.org/blog/2019/01/future-typescript-eslint) between the two teams.\n\n## Install\n\nTo setup ESLint for TypeScript you need the following packages:\n\n```sh\nnpm i eslint eslint-plugin-react @typescript-eslint/parser @typescript-eslint/eslint-plugin\n```\n\n> TIP: eslint calls packages that contain lint rules as \"plugin\"\n\n* eslint : Core eslint \n* eslint-plugin-react : For react rules provided by eslint. [Supported rules list](https://github.com/yannickcr/eslint-plugin-react#list-of-supported-rules)\n* @typescript-eslint/parse : To allow eslint to understand ts / tsx files \n* @typescript-eslint/eslint-plugin : For TypeScript rules. [Supported rules list](https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin#supported-rules)"}
{"id": "docs\\tools\\eslint.md#1", "content": "> As you can see there are two eslint packages (for use with js or ts) and two @typescript-eslint packages (for use with ts). So the overhead for TypeScript is not *that much*.\n\n## Configure \nCreate `.eslintrc.js`: \n\n```js\nmodule.exports = {\n  parser: '@typescript-eslint/parser',\n  parserOptions: {\n    project: './tsconfig.json',\n  },\n  plugins: ['@typescript-eslint'],\n  extends: [\n    'plugin:react/recommended',\n    'plugin:@typescript-eslint/recommended',\n  ],\n  rules:  {\n    // Overwrite rules specified from the extended configs e.g. \n    // \"@typescript-eslint/explicit-function-return-type\": \"off\",\n  }\n}\n```\n\n## Run\n\nIn your `package.json` add to `scripts`: \n\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint \\\"src/**\\\"\"\n  }\n}\n```\n\nNow you can `npm run lint` to validate.\n\n## Configure VSCode"}
{"id": "docs\\tools\\eslint.md#2", "content": "* Install extension https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint\n* Add to `settings.json`:\n```js\n\"eslint.validate\":  [\n  \"javascript\",\n  \"javascriptreact\",\n  {\"language\":  \"typescript\",  \"autoFix\":  true  },\n  {\"language\":  \"typescriptreact\",  \"autoFix\":  true  }\n],\n```"}
{"id": "docs\\tools\\husky.md#0", "content": "# Husky \n\n> Husky can prevent bad commits, pushes and more \ud83d\udc36!\n\nIf you want to run some JavaScript / TypeScript code before a commit takes place, husky is the tool for that. \n\nFor example, you can use husky to make sure files are formatted by prettier automatically so you don't have to worry about manually formatting files ever again and focus on the objective of the code instead. Here is the setup: \n\n* `npm install husky -D`\n* Add `scripts` to `package.json`: \n\n```\n    \"precommit\": \"npm run prettier:write\",\n```\n\nNow whenever you commit code and there are any formatting changes that need to be made, you'd get them as a *modified* file in your git log. You can now \n\n* If you have pushed your code already, simply commit them with a comment `pretty`.\n* If you haven't pushed your code, amend your last commit and look like a superhero."}
{"id": "docs\\tools\\intro.md#0", "content": "# Tools\nHere are some great tools that I recommend you use or at least try in your TypeScript projects."}
{"id": "docs\\tools\\prettier.md#0", "content": "# Prettier \n\nPrettier is a great tool by facebook that makes code formatting so much easier that it's worth mentioning. Setting up with TypeScript using our recommended project setup (aka everything in `src` folder) is super easy: \n\n## Setup \n\n* `npm install prettier -D` \n* Add `scripts` to `package.json`: \n\n```\n    \"prettier:base\": \"prettier --parser typescript --single-quote\",\n    \"prettier:check\": \"npm run prettier:base -- --list-different \\\"src/**/*.{ts,tsx}\\\"\",\n    \"prettier:write\": \"npm run prettier:base -- --write \\\"src/**/*.{ts,tsx}\\\"\"\n```\n\n## Usage \nOn your build server: \n* `npm run prettier:check` \n\nDuring dev (or pre commit hook): \n* `npm run prettier:write`"}
{"id": "docs\\types\\@types.md#0", "content": "# `@types`\n\n[Definitely Typed](https://github.com/DefinitelyTyped/DefinitelyTyped) is definitely one of TypeScript's greatest strengths. The community has effectively gone ahead and **documented** the nature of nearly 90% of the top JavaScript projects out there.\n\nThis means that you can use these projects in a very interactive and exploratory manner, no need to have the docs open in a separate window and making sure you don't make a typo.\n\n## Using `@types`\n\nInstallation is fairly simple as it just works on top of `npm`. So as an example you can install type definitions for `jquery` simply as:\n\n```\nnpm install @types/jquery --save-dev\n```\n\n`@types` supports both *global* and *module* type definitions.\n\n\n### Global `@types`\n\nBy default any definitions that support global consumption are included automatically. E.g. for `jquery` you should be able to just start using `$` *globally* in your project.\n\nHowever, for *libraries*  (like `jquery`) I generally recommend using *modules*:"}
{"id": "docs\\types\\@types.md#1", "content": "### Module `@types`\n\nAfter installation, no special configuration is required really. You just use it like a module e.g.:\n\n```ts\nimport * as $ from \"jquery\";\n\n// Use $ at will in this module :)\n```\n\n## Controlling Globals\n\nAs can be seen, having a definition that allows global leak-in automatically can be a problem for some teams. So you can choose to *explicitly* only bring in the types that make sense using the `tsconfig.json` `compilerOptions.types` e.g.:\n\n```json\n{\n    \"compilerOptions\": {\n        \"types\" : [\n            \"jquery\"\n        ]\n    }\n}\n```\n\nThe above shows a sample where only `jquery` will be allowed to be used. Even if the person installs another definition like `npm install @types/node` its globals (e.g. [`process`](https://nodejs.org/api/process.html)) will not leak into your code until you add them to the `tsconfig.json` types option."}
{"id": "docs\\types\\advanced.md#0", "content": "# Functions\n\n## Optional\nThe `?` annotation can be used before a function argument or member of an interface to denote that a member is optional. That is to say that you can provide it if you want (and it will be type checked), but if it is ommited its *okay*. This is shown in the following example:\n\n## Specialized Parameters\n\n## Function Overloads\nThe JavaScript runtime does not have runtime support for function overloading. There can be only a single function body for any given name in scope. However, people do support function overloading by utilizing the highly dynamic nature of JavaScript e.g. a getter and a setter:\n\n```ts\nvar _value;\nfunction getOrSet(value) {\n    if (value === undefined) {\n        return _value;\n    } else {\n        _value = value;\n    }\n}\n\ngetOrSet(1); // set : 1\nconsole.log(getOrSet()); // get : 1\n```\n\nSuch implementation can be captured by the TypeScript's type system by providing function signatures before the function implementation:"}
{"id": "docs\\types\\advanced.md#1", "content": "```ts\nvar _value;\nfunction getOrSet(): number;\nfunction getOrSet(value: number);\nfunction getOrSet(value?: number) {\n    if (value === undefined) {\n        return _value;\n    } else {\n        _value = value;\n    }\n}\n\ngetOrSet(1); // set : 1\nconsole.log(getOrSet()); // get : 1\n```\n\nNote that when you define function overloads this way, *the last signature is actually not callable*. You have to provide it however, to help the implementer of the function be aware of the consequences of his overload signatures. For example, in the following example the function with the signature `function callMe(v1?: any, v2?: any): any` is not open to public use:\n\n```ts\nfunction callMe(): number;\nfunction callMe(v1: number);\nfunction callMe(v1: string, v2: number);\nfunction callMe(v1?: any, v2?: any): any {\n    // Implementation body goes here\n}\n\n// Allowed calls\ncallMe();\ncallMe(1);\ncallMe('jenny', 5309);\n\n// COMPILER ERROR: invalid calls\ncallMe('jenny');\ncallMe('jenny', '5309');\n```"}
{"id": "docs\\types\\advanced.md#2", "content": "TIP: Note that there is a slight overlap between union types and function overloading. If two function signatures only differ by a single parameter having different types just use a union type for that parameter instead of creating an overload signature.\n\n\n# Interfaces\n\nInterfaces have a lot of power in TypeScript. This is because they are designed to capture all the complexity of\n\n\n\n\n# Ambient Declarations\n\nWe previously had a brief look at ambient declarations in the section *why typescript?*. One of the core design goals of TypeScript is to allow easy consumption of existing JavaScript libraries. You can declare the type information for existing JavaScript using *ambient declarations*. You declare ambient stuff using the `declare` keyword. In fact this is how a bunch of stuff available by default in a browser environment (e.g `window`, `document` etc) is declared in a file called `lib.d.ts`"}
{"id": "docs\\types\\advanced.md#3", "content": "Note: You can find type definitions for nearly 90% of the most popular JavaScript libraries at [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped) with contributions from [lots of  developers](https://github.com/borisyankov/DefinitelyTyped/graphs/contributors).\n\n\n\n### lib.d.ts\n\n# Interfaces\n\n\n\n### Interfaces for primitive types\n\n### Interface for array\n\n## Type Alias\n\n## Union Types\nneeded for configuration objects\n\n## Type Inference\nIt tries to *infer* as much as it can *so that you don't need to explicitly type* your code.\n\n## Function Signatures\n\nSpecialized\n\n## Type Assertion\n\nIf A is a subtype of B or B is a subtype of A.\n\n\n\n\n\n\n\n\n[more on interfaces]\nStructural so more information is okay, but less information is an error. Duck typing is baked deep into the language design.\nOpen Ended\nType Compatibility"}
{"id": "docs\\types\\callable.md#0", "content": "## Callable\nYou can annotate callables as a part of a type or an interface as follows\n\n```ts\ninterface ReturnString {\n  (): string\n}\n```\nAn instance of such an interface would be a function that returns a string e.g.\n\n```ts\ndeclare const foo: ReturnString;\nconst bar = foo(); // bar is inferred as a string\n```\n\n### Obvious examples\nOf course such a *callable* annotation can also specify any arguments / optional arguments / rest arguments as needed. e.g. here is a complex example:\n\n```ts\ninterface Complex {\n  (foo: string, bar?: number, ...others: boolean[]): number;\n}\n```\n\nAn interface can provide multiple callable annotations to specify function overloading. For example:\n\n```ts\ninterface Overloaded {\n    (foo: string): string\n    (foo: number): number\n}"}
{"id": "docs\\types\\callable.md#1", "content": "// example implementation\nfunction stringOrNumber(foo: number): number;\nfunction stringOrNumber(foo: string): string;\nfunction stringOrNumber(foo: any): any {\n    if (typeof foo === 'number') {\n        return foo * foo;\n    } else if (typeof foo === 'string') {\n        return `hello ${foo}`;\n    }\n}\n\nconst overloaded: Overloaded = stringOrNumber;\n\n// example usage\nconst str = overloaded(''); // type of `str` is inferred as `string`\nconst num = overloaded(123); // type of `num` is inferred as `number`\n```\n\nOf course, like the body of *any* interface, you can use the body of a callable interface as a type annotation for a variable. For example:\n\n```ts\nconst overloaded: {\n  (foo: string): string\n  (foo: number): number\n} = (foo: any) => foo;\n```\n\n### Arrow Syntax\nTo make it easy to specify callable signatures, TypeScript also allows simple arrow type annotations. For example, a function that takes a `number` and returns a `string` can be annotated as:"}
{"id": "docs\\types\\callable.md#2", "content": "```ts\nconst simple: (foo: number) => string\n    = (foo) => foo.toString();\n```\n\n> Only limitation of the arrow syntax: You can't specify overloads. For overloads you must use the full bodied `{ (someArgs): someReturn }` syntax.\n\n### Newable\n\nNewable is just a special type of *callable* type annotation with the prefix `new`. It simply means that you need to *invoke* with `new` e.g.\n\n```ts\ninterface CallMeWithNewToGetString {\n  new(): string\n}\n// Usage\ndeclare const Foo: CallMeWithNewToGetString;\nconst bar = new Foo(); // bar is inferred to be of type string\n```"}
{"id": "docs\\types\\discriminated-unions.md#0", "content": "### Discriminated Union\n\nIf you have a class with a [*literal member*](./literal-types.md) then you can use that property to discriminate between union members.\n\nAs an example consider the union of a `Square` and `Rectangle`, here we have a member `kind` that exists on both union members and is of a particular *literal type*:\n\n```ts\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ntype Shape = Square | Rectangle;\n```\n\nIf you use a type guard style check (`==`, `===`, `!=`, `!==`) or `switch` on the *discriminant property* (here `kind`) TypeScript will realize that the object must be of the type that has that specific literal and do a type narrowing for you :)"}
{"id": "docs\\types\\discriminated-unions.md#1", "content": "```ts\nfunction area(s: Shape) {\n    if (s.kind === \"square\") {\n        // Now TypeScript *knows* that `s` must be a square ;)\n        // So you can use its members safely :)\n        return s.size * s.size;\n    }\n    else {\n        // Wasn't a square? So TypeScript will figure out that it must be a Rectangle ;)\n        // So you can use its members safely :)\n        return s.width * s.height;\n    }\n}\n```\n\n### Exhaustive Checks\nQuite commonly you want to make sure that all members of a union have some code(action) against them.\n\n```ts\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\n\n// Someone just added this new `Circle` Type\n// We would like to let TypeScript give an error at any place that *needs* to cater for this\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ntype Shape = Square | Rectangle | Circle;\n```\n\nAs an example of where stuff goes bad:"}
{"id": "docs\\types\\discriminated-unions.md#2", "content": "```ts\nfunction area(s: Shape) {\n    if (s.kind === \"square\") {\n        return s.size * s.size;\n    }\n    else if (s.kind === \"rectangle\") {\n        return s.width * s.height;\n    }\n    // Would it be great if you could get TypeScript to give you an error?\n}\n```\n\nYou can do that by simply adding a fall through and making sure that the inferred type in that block is compatible with the `never` type. For example if you add the exhaustive check you get a nice error:\n\n```ts\nfunction area(s: Shape) {\n    if (s.kind === \"square\") {\n        return s.size * s.size;\n    }\n    else if (s.kind === \"rectangle\") {\n        return s.width * s.height;\n    }\n    else {\n        // ERROR : `Circle` is not assignable to `never`\n        const _exhaustiveCheck: never = s;\n    }\n}\n```\n\nThat forces you to handle this new case :"}
{"id": "docs\\types\\discriminated-unions.md#3", "content": "```ts\nfunction area(s: Shape) {\n    if (s.kind === \"square\") {\n        return s.size * s.size;\n    }\n    else if (s.kind === \"rectangle\") {\n        return s.width * s.height;\n    }\n    else if (s.kind === \"circle\") {\n        return Math.PI * (s.radius **2);\n    }\n    else {\n        // Okay once more\n        const _exhaustiveCheck: never = s;\n    }\n}\n```\n\n\n### Switch\nTIP: of course you can also do it in a `switch` statement:\n\n```ts\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.width * s.height;\n        case \"circle\": return Math.PI * s.radius * s.radius;\n        default: const _exhaustiveCheck: never = s;\n    }\n}\n```\n\n[references-discriminated-union]:https://github.com/Microsoft/TypeScript/pull/9163\n\n### strictNullChecks"}
{"id": "docs\\types\\discriminated-unions.md#4", "content": "If using *strictNullChecks* and doing exhaustive checks, TypeScript might complain \"not all code paths return a value\". You can silence that by simply returning the `_exhaustiveCheck` variable (of type `never`). So:\n\n```ts\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.width * s.height;\n        case \"circle\": return Math.PI * s.radius * s.radius;\n        default:\n          const _exhaustiveCheck: never = s;\n          return _exhaustiveCheck;\n    }\n}\n```\n\n### Throw in exhaustive checks\nYou can write a function that takes a `never` (and therefore can only be called with a variable that is inferred as `never`) and then throws an error if its body ever executes: \n\n```ts\nfunction assertNever(x:never): never {\n    throw new Error('Unexpected value. Should have been never.');\n}\n```\n\nExample use with the area function:"}
{"id": "docs\\types\\discriminated-unions.md#5", "content": "```ts\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ntype Shape = Square | Rectangle;\n\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.width * s.height;\n\t\t// If a new case is added at compile time you will get a compile error\n\t\t// If a new value appears at runtime you will get a runtime error\n        default: return assertNever(s);\n    }\n}\n```\n\n### Retrospective Versioning\nSay you have a data structure of the form: \n\n```ts\ntype DTO = {\n  name: string\n}\n```\nAnd after you have a bunch of `DTO`s you realize that `name` was a poor choice. You can add versioning retrospectively by creating a new *union* with *literal number* (or string if you want) of DTO. Mark the version 0 as `undefined` and if you have *strictNullChecks* enabled it will just work out:"}
{"id": "docs\\types\\discriminated-unions.md#6", "content": "```ts\ntype DTO = \n| { \n   version: undefined, // version 0\n   name: string,\n }\n| {\n   version: 1,\n   firstName: string,\n   lastName: string, \n}\n// Even later \n| {\n    version: 2,\n    firstName: string,\n    middleName: string,\n    lastName: string, \n} \n// So on\n```\n\n Example usage of such a DTO:\n\n```ts\nfunction printDTO(dto:DTO) {\n  if (dto.version == null) {\n      console.log(dto.name);\n  } else if (dto.version == 1) {\n      console.log(dto.firstName,dto.lastName);\n  } else if (dto.version == 2) {\n      console.log(dto.firstName, dto.middleName, dto.lastName);\n  } else {\n      const _exhaustiveCheck: never = dto;\n  }\n}\n```\n\n### Redux\n\nA popular library that makes use of this is redux.\n\nHere is the [*gist of redux*](https://github.com/reactjs/redux#the-gist) with TypeScript type annotations added:\n\n```ts\nimport { createStore } from 'redux'\n\ntype Action\n  = {\n    type: 'INCREMENT'\n  }\n  | {\n    type: 'DECREMENT'\n  }"}
{"id": "docs\\types\\discriminated-unions.md#7", "content": "/**\n * This is a reducer, a pure function with (state, action) => state signature.\n * It describes how an action transforms the state into the next state.\n *\n * The shape of the state is up to you: it can be a primitive, an array, an object,\n * or even an Immutable.js data structure. The only important part is that you should\n * not mutate the state object, but return a new object if the state changes.\n *\n * In this example, we use a `switch` statement and strings, but you can use a helper that\n * follows a different convention (such as function maps) if it makes sense for your\n * project.\n */\nfunction counter(state = 0, action: Action) {\n  switch (action.type) {\n  case 'INCREMENT':\n    return state + 1\n  case 'DECREMENT':\n    return state - 1\n  default:\n    return state\n  }\n}\n\n// Create a Redux store holding the state of your app.\n// Its API is { subscribe, dispatch, getState }.\nlet store = createStore(counter)"}
{"id": "docs\\types\\discriminated-unions.md#8", "content": "// You can use subscribe() to update the UI in response to state changes.\n// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.\n// However, it can also be handy to persist the current state in the localStorage.\n\nstore.subscribe(() =>\n  console.log(store.getState())\n)\n\n// The only way to mutate the internal state is to dispatch an action.\n// The actions can be serialized, logged or stored and later replayed.\nstore.dispatch({ type: 'INCREMENT' })\n// 1\nstore.dispatch({ type: 'INCREMENT' })\n// 2\nstore.dispatch({ type: 'DECREMENT' })\n// 1\n```\n\nUsing it with TypeScript gives you safety against typo errors, increased refactor-ability and self documenting code."}
{"id": "docs\\types\\exceptions.md#0", "content": "# Exception Handling\n\nJavaScript has an `Error` class that you can use for exceptions. You throw an error with the `throw` keyword. You can catch it with a `try` / `catch` block pair e.g.\n\n```js\ntry {\n  throw new Error('Something bad happened');\n}\ncatch(e) {\n  console.log(e);\n}\n```\n\n## Error Sub Types\n\nBeyond the built in `Error` class there are a few additional built-in error classes that inherit from `Error` that the JavaScript runtime can throw:\n\n### RangeError\n\nCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\n```js\n// Call console with too many arguments\nconsole.log.apply(console, new Array(1000000000)); // RangeError: Invalid array length\n```\n\n### ReferenceError\n\nCreates an instance representing an error that occurs when de-referencing an invalid reference. e.g.\n\n```js\n'use strict';\nconsole.log(notValidVar); // ReferenceError: notValidVar is not defined\n```\n\n### SyntaxError"}
{"id": "docs\\types\\exceptions.md#1", "content": "Creates an instance representing a syntax error that occurs while parsing code that isn't valid JavaScript.\n\n```js\n1***3; // SyntaxError: Unexpected token *\n```\n\n### TypeError\n\nCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\n```js\n('1.2').toPrecision(1); // TypeError: '1.2'.toPrecision is not a function\n```\n\n### URIError\n\nCreates an instance representing an error that occurs when `encodeURI()` or `decodeURI()` are passed invalid parameters.\n\n```js\ndecodeURI('%'); // URIError: URI malformed\n```\n\n## Always use `Error`\n\nBeginner JavaScript developers sometimes just throw raw strings e.g.\n\n```js\ntry {\n  throw 'Something bad happened';\n}\ncatch(e) {\n  console.log(e);\n}\n```\n\n*Don't do that*. The fundamental benefit of `Error` objects is that they automatically keep track of where they were built and originated with the `stack` property."}
{"id": "docs\\types\\exceptions.md#2", "content": "Raw strings result in a very painful debugging experience and complicate error analysis from logs.\n\n## You don't have to `throw` an error\n\nIt is okay to pass an `Error` object around. This is conventional in Node.js callback style code which takes callbacks with the first argument as an error object.\n\n```js\nfunction myFunction (callback: (e?: Error)) {\n  doSomethingAsync(function () {\n    if (somethingWrong) {\n      callback(new Error('This is my error'))\n    } else {\n      callback();\n    }\n  });\n}\n```\n\n## Exceptional cases\n\n`Exceptions should be exceptional` is a common saying in computer science. There are a few reasons why this is true for JavaScript (and TypeScript) as well.\n\n### Unclear where it is thrown\n\nConsider the following piece of code:\n\n```js\ntry {\n  const foo = runTask1();\n  const bar = runTask2();\n}\ncatch(e) {\n  console.log('Error:', e);\n}\n```"}
{"id": "docs\\types\\exceptions.md#3", "content": "The next developer cannot know which function might throw the error. The person reviewing the code cannot know without reading the code for task1 / task2 and other functions they might call etc.\n\n### Makes graceful handling hard\n\nYou can try to make it graceful with explicit catch around each thing that might throw:\n\n```js\ntry {\n  const foo = runTask1();\n}\ncatch(e) {\n  console.log('Error:', e);\n}\ntry {\n  const bar = runTask2();\n}\ncatch(e) {\n  console.log('Error:', e);\n}\n```\n\nBut now if you need to pass stuff from the first task to the second one the code becomes messy: (notice `foo` mutation requiring `let` + explicit need for annotating it because it cannot be inferred from the return of `runTask1`):\n\n```ts\nlet foo: number; // Notice use of `let` and explicit type annotation\ntry {\n  foo = runTask1();\n}\ncatch(e) {\n  console.log('Error:', e);\n}\ntry {\n  const bar = runTask2(foo);\n}\ncatch(e) {\n  console.log('Error:', e);\n}\n```\n\n### Not well represented in the type system"}
{"id": "docs\\types\\exceptions.md#4", "content": "Consider the function:\n\n```ts\nfunction validate(value: number) {\n  if (value < 0 || value > 100) throw new Error('Invalid value');\n}\n```\n\nUsing `Error` for such cases is a bad idea as it is not represented in the type definition for the validate function (which is `(value:number) => void`). Instead a better way to create a validate method would be:\n\n```ts\nfunction validate(value: number): {error?: string} {\n  if (value < 0 || value > 100) return {error:'Invalid value'};\n}\n```\n\nAnd now its represented in the type system.\n\n> Unless you want to handle the error in a very generic (simple / catch-all etc) way, don't *throw* an error."}
{"id": "docs\\types\\freshness.md#0", "content": "* [Freshness](#freshness)\n* [Allowing extra properties](#allowing-extra-properties)\n* [Use Case: React](#use-case-react-state)\n\n## Freshness\n\nTypeScript provides a concept of **Freshness** (also called *strict object literal checking*) to make it easier to type check object literals that would otherwise be structurally type compatible.\n\nStructural typing is *extremely convenient*. Consider the following piece of code. This allows you to *very conveniently* upgrade your JavaScript to TypeScript while still preserving a level of type safety:\n\n```ts\nfunction logName(something: { name: string }) {\n    console.log(something.name);\n}\n\nvar person = { name: 'matt', job: 'being awesome' };\nvar animal = { name: 'cow', diet: 'vegan, but has milk of own species' };\nvar random = { note: `I don't have a name property` };\n\nlogName(person); // okay\nlogName(animal); // okay\nlogName(random); // Error: property `name` is missing\n```"}
{"id": "docs\\types\\freshness.md#1", "content": "However, *structural* typing has a weakness in that it allows you to misleadingly think that something accepts more data than it actually does. This is demonstrated in the following code which TypeScript will error on as shown:\n\n```ts\nfunction logName(something: { name: string }) {\n    console.log(something.name);\n}\n\nlogName({ name: 'matt' }); // okay\nlogName({ name: 'matt', job: 'being awesome' }); // Error: object literals must only specify known properties. `job` is excessive here.\n```\n\nNote that this error *only happens on object literals*. Without this error one might look at the call `logName({ name: 'matt', job: 'being awesome' })` and think that *logName* would do something useful with `job` where as in reality it will completely ignore it.\n\nAnother big use case is with interfaces that have optional members, without such object literal checking, a typo would type check just fine. This is demonstrated below:"}
{"id": "docs\\types\\freshness.md#2", "content": "```ts\nfunction logIfHasName(something: { name?: string }) {\n    if (something.name) {\n        console.log(something.name);\n    }\n}\nvar person = { name: 'matt', job: 'being awesome' };\nvar animal = { name: 'cow', diet: 'vegan, but has milk of own species' };\n\nlogIfHasName(person); // okay\nlogIfHasName(animal); // okay\nlogIfHasName({neme: 'I just misspelled name to neme'}); // Error: object literals must only specify known properties. `neme` is excessive here.\n```\n\nThe reason why only object literals are type checked this way is because in this case additional properties *that aren't actually used* is almost always a typo or a misunderstanding of the API.\n\n### Allowing extra properties\n\nA type can include an index signature to explicitly indicate that excess properties are permitted:\n\n```ts\nvar x: { foo: number, [x: string]: unknown };\nx = { foo: 1, baz: 2 };  // Ok, `baz` matched by index signature\n```\n\n### Use Case: React State"}
{"id": "docs\\types\\freshness.md#3", "content": "[Facebook ReactJS](https://facebook.github.io/react/) offers a nice use case for object freshness. Quite commonly in a component you call `setState` with only a few properties instead of passing in all the properties, i.e.: \n\n```ts\n// Assuming\ninterface State {\n    foo: string;\n    bar: string;\n}\n\n// You want to do: \nthis.setState({foo: \"Hello\"}); // Error: missing property bar\n\n// But because state contains both `foo` and `bar` TypeScript would force you to do: \nthis.setState({foo: \"Hello\", bar: this.state.bar});\n```\n\nUsing the idea of freshness you would mark all the members as optional and *you still get to catch typos*!: \n\n```ts\n// Assuming\ninterface State {\n    foo?: string;\n    bar?: string;\n}\n\n// You want to do: \nthis.setState({foo: \"Hello\"}); // Yay works fine!\n\n// Because of freshness it's protected against typos as well!\nthis.setState({foos: \"Hello\"}); // Error: Objects may only specify known properties"}
{"id": "docs\\types\\freshness.md#4", "content": "// And still type checked\nthis.setState({foo: 123}); // Error: Cannot assign number to a string\n```"}
{"id": "docs\\types\\functions.md#0", "content": "* [Parameter Annotations](#parameter-annotations)\n* [Return Type Annotation](#return-type-annotation)\n* [Optional Parameters](#optional-parameters)\n* [Overloading](#overloading)\n\n## Functions\nThe TypeScript type system pays a lot of love to functions, after all they are the core building blocks of a composable system.\n\n### Parameter annotations\nOf course you can annotate function parameters just like you can annotate other variables:\n\n```ts\n// variable annotation\nvar sampleVariable: { bar: number }\n\n// function parameter annotation\nfunction foo(sampleParameter: { bar: number }) { }\n```\n\nHere I used inline type annotations. Of course you can use interfaces etc.\n\n### Return type annotation\n\nYou can annotate the return type after the function parameter list with the same style as you use for a variable, e.g. `: Foo` in the below example:\n\n```ts\ninterface Foo {\n    foo: string;\n}\n\n// Return type annotated as `: Foo`\nfunction foo(sample: Foo): Foo {\n    return sample;\n}\n```"}
{"id": "docs\\types\\functions.md#1", "content": "Of course I used an `interface` here, but you are free to use other annotations e.g. inline annotations.\n\nQuite commonly you don't *need* to annotate the return type of a function as it can generally be inferred by the compiler.\n\n```ts\ninterface Foo {\n    foo: string;\n}\n\nfunction foo(sample: Foo) {\n    return sample; // inferred return type 'Foo'\n}\n```\n\nHowever, it is generally a good idea to add these annotation to help with errors e.g.:\n\n```ts\nfunction foo() {\n    return { fou: 'John Doe' }; // You might not find this misspelling of `foo` till it's too late\n}\n\nsendAsJSON(foo());\n```\n\nIf you don't plan to return anything from a function, you can annotate it as `:void`. You can generally drop `:void` and leave it to the inference engine though.\n\n### Optional Parameters\nYou can mark a parameter as optional:\n\n```ts\nfunction foo(bar: number, bas?: string): void {\n    // ..\n}\n\nfoo(123);\nfoo(123, 'hello');\n```"}
{"id": "docs\\types\\functions.md#2", "content": "Alternatively you can even provide a default value (using `= someValue` after the parameter declaration) which is injected for you if the caller doesn't provide that argument:\n\n```ts\nfunction foo(bar: number, bas: string = 'hello') {\n    console.log(bar, bas);\n}\n\nfoo(123);           // 123, hello\nfoo(123, 'world');  // 123, world\n```\n\n### Overloading\nTypeScript allows you to *declare* function overloads. This is useful for documentation + type safety purpose. Consider the following code:\n\n```ts\nfunction padding(a: number, b?: number, c?: number, d?: any) {\n    if (b === undefined && c === undefined && d === undefined) {\n        b = c = d = a;\n    }\n    else if (c === undefined && d === undefined) {\n        c = a;\n        d = b;\n    }\n    return {\n        top: a,\n        right: b,\n        bottom: c,\n        left: d\n    };\n}\n```"}
{"id": "docs\\types\\functions.md#3", "content": "If you look at the code carefully you realize the meaning of `a`,`b`,`c`,`d` changes based on how many arguments are passed in. Also the function only expects `1`, `2` or `4` arguments. These constraints can be *enforced* and *documented* using function overloading. You just declare the function header multiple times. The last function header is the one that is actually active *within* the function body but is not available to the outside world.\n\nThis is shown below:"}
{"id": "docs\\types\\functions.md#4", "content": "```ts\n// Overloads\nfunction padding(all: number);\nfunction padding(topAndBottom: number, leftAndRight: number);\nfunction padding(top: number, right: number, bottom: number, left: number);\n// Actual implementation that is a true representation of all the cases the function body needs to handle\nfunction padding(a: number, b?: number, c?: number, d?: number) {\n    if (b === undefined && c === undefined && d === undefined) {\n        b = c = d = a;\n    }\n    else if (c === undefined && d === undefined) {\n        c = a;\n        d = b;\n    }\n    return {\n        top: a,\n        right: b,\n        bottom: c,\n        left: d\n    };\n}\n```\n\nHere the first three function headers are available as valid calls to `padding`:\n\n```ts\npadding(1); // Okay: all\npadding(1,1); // Okay: topAndBottom, leftAndRight\npadding(1,1,1,1); // Okay: top, right, bottom, left\n\npadding(1,1,1); // Error: Not a part of the available overloads\n```"}
{"id": "docs\\types\\functions.md#5", "content": "Of course it's important for the final declaration (the true declaration as seen from inside the function) to be compatible with all the overloads. This is because that is the true nature of the function calls that the function body needs to account for.\n\n> Function overloading in TypeScript doesn't come with any runtime overhead. It just allows you to document the manner you expect the function to be called in and the compiler holds the rest of your code in check.\n\n### Declaring Functions\n> Quick Tip: *Type Declarations* are how you describe the types of existing implementations. \n\nThere are two ways to *declare* the type of a function without providing an implementation. E.g. \n\n```ts\ntype LongHand = {\n    (a: number): number;\n};\n\ntype ShortHand = (a: number) => number;\n```\nThe example above are both *exactly* equivalent. The differences exist when you want to add overloads. You can only add overloads in the long hand declaration version e.g."}
{"id": "docs\\types\\functions.md#6", "content": "```ts\ntype LongHandAllowsOverloadDeclarations = {\n    (a: number): number;\n    (a: string): string;\n};\n```\n\n[](### Type Compatibility)"}
{"id": "docs\\types\\generics.md#0", "content": "## Generics\n\nThe key motivation for generics is to document meaningful type dependencies between members. The members can be:\n\n* Class instance members\n* Class methods\n* function arguments\n* function return value\n\n## Motivation and samples\n\nConsider the simple `Queue` (first in, first out) data structure implementation. A simple one in TypeScript / JavaScript looks like:\n\n```ts\nclass Queue {\n  private data = [];\n  push(item) { this.data.push(item); }\n  pop() { return this.data.shift(); }\n}\n```\n\nOne issue with this implementation is that it allows people to add *anything* to the queue and when they pop it - it can be *anything*. This is shown below, where someone can push a `string` onto the queue while the usage actually assumes that only `numbers` were pushed in:\n\n```ts\nclass Queue {\n  private data = [];\n  push(item) { this.data.push(item); }\n  pop() { return this.data.shift(); }\n}\n\nconst queue = new Queue();\nqueue.push(0);\nqueue.push(\"1\"); // Oops a mistake"}
{"id": "docs\\types\\generics.md#1", "content": "// a developer walks into a bar\nconsole.log(queue.pop().toPrecision(1));\nconsole.log(queue.pop().toPrecision(1)); // RUNTIME ERROR\n```\n\nOne solution (and in fact the only one in languages that don't support generics) is to go ahead and create *special* classes just for these constraints. E.g. a quick and dirty number queue:\n\n```ts\nclass QueueNumber extends Queue {\n  push(item: number) { super.push(item); }\n  pop(): number { return this.data.shift(); }\n}\n\nconst queue = new QueueNumber();\nqueue.push(0);\nqueue.push(\"1\"); // ERROR : cannot push a string. Only numbers allowed\n\n// ^ if that error is fixed the rest would be fine too\n```\n\nOf course this can quickly become painful e.g. if you want a string queue you have to go through all that effort again. What you really want is a way to say that whatever the type is of the stuff getting *pushed* it should be the same for whatever gets *popped*. This is done easily with a *generic* parameter (in this case, at the class level):"}
{"id": "docs\\types\\generics.md#2", "content": "```ts\n/** A class definition with a generic parameter */\nclass Queue<T> {\n  private data = [];\n  push(item: T) { this.data.push(item); }\n  pop(): T | undefined { return this.data.shift(); }\n}\n\n/** Again sample usage */\nconst queue = new Queue<number>();\nqueue.push(0);\nqueue.push(\"1\"); // ERROR : cannot push a string. Only numbers allowed\n\n// ^ if that error is fixed the rest would be fine too\n```\n\nAnother example that we have already seen is that of a *reverse* function, here the constraint is between what gets passed into the function and what the function returns:\n\n```ts\nfunction reverse<T>(items: T[]): T[] {\n    var toreturn = [];\n    for (let i = items.length - 1; i >= 0; i--) {\n        toreturn.push(items[i]);\n    }\n    return toreturn;\n}\n\nvar sample = [1, 2, 3];\nvar reversed = reverse(sample);\nconsole.log(reversed); // 3,2,1\n\n// Safety!\nreversed[0] = '1';     // Error!\nreversed = ['1', '2']; // Error!\n\nreversed[0] = 1;       // Okay\nreversed = [1, 2];     // Okay\n```"}
{"id": "docs\\types\\generics.md#3", "content": "In this section you have seen examples of generics being defined *at class level* and at *function level*. One minor addition worth mentioning is that you can have generics created just for a member function. As a toy example consider the following where we move the `reverse` function into a `Utility` class:\n\n```ts\nclass Utility {\n  reverse<T>(items: T[]): T[] {\n      var toreturn = [];\n      for (let i = items.length - 1; i >= 0; i--) {\n          toreturn.push(items[i]);\n      }\n      return toreturn;\n  }\n}\n```\n\n> TIP: You can call the generic parameter whatever you want. It is conventional to use `T`, `U`, or `V` when you have simple generics. If you have more than one generic argument try to use meaningful names like `TKey` and `TValue`. The convention is to prefix with `T` because generics are also called *templates* in other languages like C++.\n\n\n### Design Pattern: Convenience generic\n\nConsider the function: \n\n```ts\ndeclare function parse<T>(name: string): T;\n```"}
{"id": "docs\\types\\generics.md#4", "content": "In this case you can see that the type `T` is only used in one place. So there is no constraint *between* members. This is equivalent to a type assertion in terms of type safety:\n\n```ts\ndeclare function parse(name: string): any;\n\nconst something = parse('something') as TypeOfSomething;\n```\n\nGenerics used *only once* are no better than an assertion in terms of type safety. That said they do provide *convenience* to your API.\n\nA more obvious example is a function that loads a json response. It returns a promise of *whatever type you pass in*:\n```ts\nconst getJSON = <T>(config: {\n    url: string,\n    headers?: { [key: string]: string },\n  }): Promise<T> => {\n    const fetchConfig = ({\n      method: 'GET',\n      'Accept': 'application/json',\n      'Content-Type': 'application/json',\n      ...(config.headers || {})\n    });\n    return fetch(config.url, fetchConfig)\n      .then<T>(response => response.json());\n  }\n```"}
{"id": "docs\\types\\generics.md#5", "content": "Note that you still have to explicitly annotate what you want, but the `getJSON<T>` signature `(config) => Promise<T>` saves you a few key strokes (you don't need to annotate the return type of `loadUsers` as it can be inferred):\n\n```ts\ntype LoadUsersResponse = {\n  users: {\n    name: string;\n    email: string;\n  }[];  // array of user objects\n}\nfunction loadUsers() {\n  return getJSON<LoadUsersResponse>({ url: 'https://example.com/users' });\n}\n```\n\nAlso `Promise<T>` as a return value is definitely better than alternatives like `Promise<any>`.\n\nAnother example is where a generic is only used as an argument: \n\n```ts\ndeclare function send<T>(arg: T): void;\n```\n\nHere the generic `T` can be used to annote the type that you want the argument to match e.g. \n\n```ts\nsend<Something>({\n  x:123,\n  // Also you get autocomplete  \n}); // Will TSError if `x:123` does not match the structure expected for Something\n\n```"}
{"id": "docs\\types\\index-signatures.md#0", "content": "# Index Signatures\n\nAn `Object` in JavaScript (and hence TypeScript) can be accessed with a **string** to hold a reference to any other JavaScript **object**.\n\nHere is a quick example:\n\n```ts\nlet foo: any = {};\nfoo['Hello'] = 'World';\nconsole.log(foo['Hello']); // World\n```\n\nWe store a string `\"World\"` under the key `\"Hello\"`. Remember we said it can store any JavaScript **object**, so lets store a class instance just to show the concept:\n\n```ts\nclass Foo {\n  constructor(public message: string){};\n  log(){\n    console.log(this.message)\n  }\n}\n\nlet foo: any = {};\nfoo['Hello'] = new Foo('World');\nfoo['Hello'].log(); // World\n```\n\nAlso remember that we said that it can be accessed with a **string**. If you pass any other object to the index signature the JavaScript runtime actually calls `.toString` on it before getting the result. This is demonstrated below:\n\n```ts\nlet obj = {\n  toString(){\n    console.log('toString called')\n    return 'Hello'\n  }\n}"}
{"id": "docs\\types\\index-signatures.md#1", "content": "let foo: any = {};\nfoo[obj] = 'World'; // toString called\nconsole.log(foo[obj]); // toString called, World\nconsole.log(foo['Hello']); // World\n```\n\nNote that `toString` will get called whenever the `obj` is used in an index position.\n\nArrays are slightly different. For `number` indexing JavaScript VMs will try to optimise (depending on things like is it actually an array and do the structures of items stored match etc.). So `number` should be considered as a valid object accessor in its own right (distinct from `string`). Here is a simple array example:\n\n```ts\nlet foo = ['World'];\nconsole.log(foo[0]); // World\n```\n\nSo that's JavaScript. Now let's look at TypeScript's graceful handling of this concept.\n\n## TypeScript Index Signature"}
{"id": "docs\\types\\index-signatures.md#2", "content": "First off, because JavaScript *implicitly* calls `toString` on any object index signature, TypeScript will give you an error to prevent beginners from shooting themselves in the foot (I see users shooting themselves in the foot when using JavaScript all the time on stackoverflow):\n\n```ts\nlet obj = {\n  toString(){\n    return 'Hello'\n  }\n}\n\nlet foo: any = {};\n\n// ERROR: the index signature must be string, number ...\nfoo[obj] = 'World';\n\n// FIX: TypeScript forces you to be explicit\nfoo[obj.toString()] = 'World';\n```\n\nThe reason for forcing the user to be explicit is because the default `toString` implementation on an object is pretty awful, e.g. on v8 it always returns `[object Object]`:\n\n```ts\nlet obj = {message:'Hello'}\nlet foo: any = {};\n\n// ERROR: the index signature must be string, number ...\nfoo[obj] = 'World';\n\n// Here is where you actually stored it!\nconsole.log(foo[\"[object Object]\"]); // World\n```\n\nOf course `number` is supported because"}
{"id": "docs\\types\\index-signatures.md#3", "content": "1. its needed for excellent Array / Tuple support.\n1. even if you use it for an `obj` its default `toString` implementation is nice (not `[object Object]`).\n\nPoint 2 is shown below:\n\n```ts\nconsole.log((1).toString()); // 1\nconsole.log((2).toString()); // 2\n```\n\nSo lesson 1:\n\n> TypeScript index signatures must be either `string` or `number`\n\nQuick note: `symbols` are also valid and supported by TypeScript. But let's not go there just yet. Baby steps.\n\n### Declaring an index signature\n\nSo we've been using `any` to tell TypeScript to let us do whatever we want. We can actually specify an *index* signature explicitly. E.g. say you want to make sure that anything that is stored in an object using a string conforms to the structure `{message: string}`. This can be done with the declaration `{ [index:string] : {message: string} }`. This is demonstrated below:\n\n```ts\nlet foo:{ [index:string] : {message: string} } = {};"}
{"id": "docs\\types\\index-signatures.md#4", "content": "/**\n * Must store stuff that conforms to the structure\n */\n/** Ok */\nfoo['a'] = { message: 'some message' };\n/** Error: must contain a `message` of type string. You have a typo in `message` */\nfoo['a'] = { messages: 'some message' };\n\n/**\n * Stuff that is read is also type checked\n */\n/** Ok */\nfoo['a'].message;\n/** Error: messages does not exist. You have a typo in `message` */\nfoo['a'].messages;\n```\n\n> TIP: the name of the index signature e.g. `index` in `{ [index:string] : {message: string} }` has no significance for TypeScript and is only for readability. e.g. if it's user names you can do `{ [username:string] : {message: string} }` to help the next dev who looks at the code (which just might happen to be you).\n\nOf course `number` indexes are also supported e.g. `{ [count: number] : SomeOtherTypeYouWantToStoreEgRebate }`\n\n### All members must conform to the `string` index signature"}
{"id": "docs\\types\\index-signatures.md#5", "content": "As soon as you have a `string` index signature, all explicit members must also conform to that index signature. This is shown below:\n\n```ts\n/** Okay */\ninterface Foo {\n  [key:string]: number;\n  x: number;\n  y: number;\n}\n/** Error */\ninterface Bar {\n  [key:string]: number;\n  x: number;\n  y: string; // ERROR: Property `y` must be of type number\n}\n```\n\nThis is to provide safety so that any string access gives the same result:\n\n```ts\ninterface Foo {\n  [key:string]: number;\n  x: number;\n}\nlet foo: Foo = {x:1,y:2};\n\n// Directly\nfoo['x']; // number\n\n// Indirectly\nlet x = 'x'\nfoo[x]; // number\n```\n\n### Using a limited set of string literals\n\nAn index signature can require that index strings be members of a union of literal strings by using *Mapped Types* e.g.:\n\n```ts\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}"}
{"id": "docs\\types\\index-signatures.md#6", "content": "// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n\nThis is often used together with `keyof typeof` to capture vocabulary types, described on the next page.\n\nThe specification of the vocabulary can be deferred generically:\n\n```ts\ntype FromSomeIndex<K extends string> = { [key in K]: number }\n```\n\n### Having both `string` and `number` indexers\n\nThis is not a common use case, but TypeScript compiler supports it nonetheless.\n\nHowever, it has the restriction that the `string` indexer is more strict than the `number` indexer. This is intentional e.g. to allow typing stuff like:\n\n```ts\ninterface ArrStr {\n  [key: string]: string | number; // Must accommodate all members\n\n  [index: number]: string; // Can be a subset of string indexer\n\n  // Just an example member\n  length: number;\n}\n```"}
{"id": "docs\\types\\index-signatures.md#7", "content": "### Design Pattern: Nested index signature\n\n> API consideration when adding index signatures\n\nQuite commonly in the JS community you will see APIs that abuse string indexers. e.g. a common pattern among CSS in JS libraries:\n\n```ts\ninterface NestedCSS {\n  color?: string;\n  [selector: string]: string | NestedCSS | undefined;\n}\n\nconst example: NestedCSS = {\n  color: 'red',\n  '.subclass': {\n    color: 'blue'\n  }\n}\n```\n\nTry not to mix string indexers with *valid* values this way. E.g. a typo in the padding will remain uncaught:\n\n```ts\nconst failsSilently: NestedCSS = {\n  colour: 'red', // No error as `colour` is a valid string selector\n}\n```\n\nInstead separate out the nesting into its own property e.g. in a name like `nest` (or `children` or `subnodes` etc.):\n\n```ts\ninterface NestedCSS {\n  color?: string;\n  nest?: {\n    [selector: string]: NestedCSS;\n  }\n}\n\nconst example: NestedCSS = {\n  color: 'red',\n  nest: {\n    '.subclass': {\n      color: 'blue'\n    }\n  }\n}"}
{"id": "docs\\types\\index-signatures.md#8", "content": "const failsSilently: NestedCSS = {\n  colour: 'red', // TS Error: unknown property `colour`\n}\n```\n\n### Excluding certain properties from the index signature\n\nSometimes you need to combine properties into the index signature. This is not advised, and you *should* use the Nested index signature pattern mentioned above. \n\nHowever, if you are modeling *existing JavaScript* you can get around it with an intersection type. The following shows an example of the error you will encounter without using an intersection:\n\n```ts\ntype FieldState = {\n  value: string\n}\n\ntype FormState = {\n  isValid: boolean  // Error: Does not conform to the index signature\n  [fieldName: string]: FieldState\n}\n```\n\nHere is the workaround using an intersection type:\n\n```ts\ntype FieldState = {\n  value: string\n}\n\ntype FormState =\n  { isValid: boolean }\n  & { [fieldName: string]: FieldState }\n```\n\nNote that even though you can declare it to model existing JavaScript, you cannot create such an object using TypeScript:"}
{"id": "docs\\types\\index-signatures.md#9", "content": "```ts\ntype FieldState = {\n  value: string\n}\n\ntype FormState =\n  { isValid: boolean }\n  & { [fieldName: string]: FieldState }\n\n\n// Use it for some JavaScript object you are getting from somewhere \ndeclare const foo:FormState; \n\nconst isValidBool = foo.isValid;\nconst somethingFieldState = foo['something'];\n\n// Using it to create a TypeScript object will not work\nconst bar: FormState = { // Error `isValid` not assignable to `FieldState\n  isValid: false\n}\n```"}
{"id": "docs\\types\\interfaces.md#0", "content": "## Interfaces\n\nInterfaces have *zero* runtime JS impact. There is a lot of power in TypeScript interfaces to declare the structure of variables.\n\nThe following two are equivalent declarations, the first uses an *inline annotation*, the second uses an *interface*:\n\n```ts\n// Sample A\ndeclare var myPoint: { x: number; y: number; };\n\n// Sample B\ninterface Point {\n    x: number; y: number;\n}\ndeclare var myPoint: Point;\n```\n\nHowever, the beauty of *Sample B* is that if someone authors a library that builds on the `myPoint` library to add new members, they can easily add to the existing declaration of `myPoint`:\n\n```ts\n// Lib a.d.ts\ninterface Point {\n    x: number; y: number;\n}\ndeclare var myPoint: Point;\n\n// Lib b.d.ts\ninterface Point {\n    z: number;\n}\n\n// Your code\nvar myPoint.z; // Allowed!\n```\n\nThis is because **interfaces in TypeScript are open ended**. This is a vital tenet of TypeScript that it allows you to mimic the extensibility of JavaScript using *interfaces*."}
{"id": "docs\\types\\interfaces.md#1", "content": "## Classes can implement interfaces\n\nIf you want to use *classes* that must follow an object structure that someone declared for you in an `interface` you can use the `implements` keyword to ensure compatibility:\n\n```ts\ninterface Point {\n    x: number; y: number;\n}\n\nclass MyPoint implements Point {\n    x: number; y: number; // Same as Point\n}\n```\n\nBasically in the presence of that `implements`, any changes in that external `Point` interface will result in a compile error in your code base so you can easily keep it in sync:\n\n```ts\ninterface Point {\n    x: number; y: number;\n    z: number; // New member\n}\n\nclass MyPoint implements Point { // ERROR : missing member `z`\n    x: number; y: number;\n}\n```\n\nNote that `implements` restricts the structure of the class *instances* i.e.:\n\n```ts\nvar foo: Point = new MyPoint();\n```\n\nAnd stuff like `foo: Point = MyPoint` is not the same thing.\n\n\n## TIPs\n\n### Not every interface is implementable easily"}
{"id": "docs\\types\\interfaces.md#2", "content": "Interfaces are designed to declare *any arbitrarily crazy* structure that might be present in JavaScript.\n\nConsider the following interface where something is callable with `new`:\n\n```ts\ninterface Crazy {\n    new (): {\n        hello: number\n    };\n}\n```\n\nYou would essentially have something like:\n\n```ts\nclass CrazyClass implements Crazy {\n    constructor() {\n        return { hello: 123 };\n    }\n}\n// Because\nconst crazy = new CrazyClass(); // crazy would be {hello:123}\n```\n\nYou can *declare* all the crazy JS out there with interfaces and even use them safely from TypeScript. Doesn't mean you can use TypeScript classes to implement them."}
{"id": "docs\\types\\lib.d.ts.md#0", "content": "* [lib.d.ts](#libdts)\n* [Example Usage](#example-usage)\n* [Inside look](#libdts-inside-look)\n* [Modifying Native types](#modifying-native-types)\n* [Using custom lib.d.ts](#using-your-own-custom-libdts)\n* [Compiler `target` effect on lib.d.ts](#compiler-target-effect-on-libdts)\n* [`lib` option](#lib-option)\n* [Polyfill for old JavaScript engines](#polyfill-for-old-javascript-engines)\n\n## `lib.d.ts`\n\nA special declaration file `lib.d.ts` ships with every installation of TypeScript. This file contains the ambient declarations for various common JavaScript constructs present in JavaScript runtimes and the DOM.\n\n* This file is automatically included in the compilation context of a TypeScript project.\n* The objective of this file is to make it easy for you to start writing *type checked* JavaScript code.\n\nYou can exclude this file from the compilation context by specifying the `--noLib` compiler command line flag (or `\"noLib\" : true` in `tsconfig.json`).\n\n### Example Usage"}
{"id": "docs\\types\\lib.d.ts.md#1", "content": "As always let's look at examples of this file being used in action:\n\n```ts\nvar foo = 123;\nvar bar = foo.toString();\n```\nThis code type checks fine *because* the `toString` function is defined in `lib.d.ts` for all JavaScript objects.\n\nIf you use the same sample code with the `noLib` option you get a type check error:\n\n```ts\nvar foo = 123;\nvar bar = foo.toString(); // ERROR: Property 'toString' does not exist on type 'number'.\n```\nSo now that you understand the importance of `lib.d.ts`, what do its contents look like? We examine that next.\n\n### `lib.d.ts` Inside Look\n\nThe contents of `lib.d.ts` are primarily a bunch of *variable* declarations e.g. `window`, `document`, `math` and a bunch of similar *interface* declarations e.g. `Window` , `Document`, `Math`.\n\nThe simplest way to read the documentation and type annotations of global stuff is to type in code *that you know works* e.g. `Math.floor` and then F12 (go to definition) using your IDE (VSCode has great support for this)."}
{"id": "docs\\types\\lib.d.ts.md#2", "content": "Let's look at a sample *variable* declaration, e.g. `window` is defined as:\n```ts\ndeclare var window: Window;\n```\nThat is just a simple `declare var` followed by the variable name (here `window`) and an interface for a type annotation (here the `Window` interface). These variables generally point to some global *interface* e.g. here is a small sample of the (actually quite massive) `Window` interface:"}
{"id": "docs\\types\\lib.d.ts.md#3", "content": "```ts\ninterface Window extends EventTarget, WindowTimers, WindowSessionStorage, WindowLocalStorage, WindowConsole, GlobalEventHandlers, IDBEnvironment, WindowBase64 {\n    animationStartTime: number;\n    applicationCache: ApplicationCache;\n    clientInformation: Navigator;\n    closed: boolean;\n    crypto: Crypto;\n    // so on and so forth...\n}\n```\nYou can see that there is a *lot* of type information in these interfaces. In the absence of TypeScript *you* would need to keep this in *your* head. Now you can offload that knowledge on the compiler with easy access to it using things like `intellisense`.\n\nThere is a good reason for using *interfaces* for these globals. It allows you to *add additional properties* to these globals *without* a need to change `lib.d.ts`. We will cover this concept next.\n\n### Modifying Native Types"}
{"id": "docs\\types\\lib.d.ts.md#4", "content": "Since an `interface` in TypeScript is open ended this means that you can just add members to the interfaces declared in `lib.d.ts` and TypeScript will pick up on the additions. Note that you need to make these changes in a [*global module*](../project/modules.md) for these interfaces to be associated with `lib.d.ts`. We even recommend creating a special file called [`global.d.ts`](../project/globals.md) for this purpose.\n\nHere are a few example cases where we add stuff to `window`, `Math`, `Date`:\n\n#### Example `window`\n\nJust add stuff to the `Window` interface e.g.:\n\n```ts\ninterface Window {\n    helloWorld(): void;\n}\n```\n\nThis will allow you to use it in a *type safe* manner:\n\n```ts\n// Add it at runtime\nwindow.helloWorld = () => console.log('hello world');\n// Call it\nwindow.helloWorld();\n// Misuse it and you get an error:\nwindow.helloWorld('gracius'); // Error: Supplied parameters do not match the signature of the call target\n```"}
{"id": "docs\\types\\lib.d.ts.md#5", "content": "#### Example `Math`\nThe global variable `Math` is defined in `lib.d.ts` as (again, use your dev tools to navigate to definition):\n\n```ts\n/** An intrinsic object that provides basic mathematics functionality and constants. */\ndeclare var Math: Math;\n```\n\ni.e. the variable `Math` is an instance of the `Math` interface. The `Math` interface is defined as:\n\n```ts\ninterface Math {\n    E: number;\n    LN10: number;\n    // others ...\n}\n```\n\nThis means that if you want to add stuff to the `Math` global variable you just need to add it to the `Math` global interface, e.g. consider the [`seedrandom` project](https://www.npmjs.com/package/seedrandom) which adds a `seedrandom` function to the global `Math` object. This can be declared quite easily:\n\n```ts\ninterface Math {\n    seedrandom(seed?: string);\n}\n```\n\nAnd then you can just use it:\n\n```ts\nMath.seedrandom();\n// or\nMath.seedrandom(\"Any string you want!\");\n```\n\n#### Example `Date`"}
{"id": "docs\\types\\lib.d.ts.md#6", "content": "If you look at the definition of the `Date` *variable* in `lib.d.ts` you will find:\n\n```ts\ndeclare var Date: DateConstructor;\n```\nThe interface `DateConstructor` is similar to what you have seen before with `Math` and `Window` in that it contains members you can use off of the `Date` global variable e.g. `Date.now()`. In addition to these members it contains *construct* signatures which allow you to create `Date` instances (e.g. `new Date()`). A snippet of the `DateConstructor` interface is shown below:\n\n```ts\ninterface DateConstructor {\n    new (): Date;\n    // ... other construct signatures\n\n    now(): number;\n    // ... other member functions\n}\n```"}
{"id": "docs\\types\\lib.d.ts.md#7", "content": "Consider the project [`datejs`](https://github.com/abritinthebay/datejs). DateJS adds members to both the `Date` global variable and `Date` instances. Therefore a TypeScript definition for this library would look like ([BTW the community has already written this for you in this case](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/datejs/index.d.ts)):\n\n```ts\n/** DateJS Public Static Methods */\ninterface DateConstructor {\n    /** Gets a date that is set to the current date. The time is set to the start of the day (00:00 or 12:00 AM) */\n    today(): Date;\n    // ... so on and so forth\n}\n\n/** DateJS Public Instance Methods */\ninterface Date {\n    /** Adds the specified number of milliseconds to this instance. */\n    addMilliseconds(milliseconds: number): Date;\n    // ... so on and so forth\n}\n```\nThis allows you to do stuff like the following in a TypeSafe manner:\n\n```ts\nvar today = Date.today();\nvar todayAfter1second = today.addMilliseconds(1000);\n```"}
{"id": "docs\\types\\lib.d.ts.md#8", "content": "#### Example `string`\n\nIf you look inside `lib.d.ts` for string you will find stuff similar to what we saw for `Date` (`String` global variable, `StringConstructor` interface, `String` interface). One thing of note though is that the `String` interface also impacts string *literals* as demonstrated in the below code sample:\n\n```ts\n\ninterface String {\n    endsWith(suffix: string): boolean;\n}\n\nString.prototype.endsWith = function(suffix: string): boolean {\n    var str: string = this;\n    return str && str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\nconsole.log('foo bar'.endsWith('bas')); // false\nconsole.log('foo bas'.endsWith('bas')); // true\n```\n\nSimilar variables and interfaces exist for other things that have both static and instance members like `Number`, `Boolean`, `RegExp`, etc. and these interfaces affect literal instances of these types as well.\n\n### Example `string` redux"}
{"id": "docs\\types\\lib.d.ts.md#9", "content": "We recommended creating a `global.d.ts` for maintainability reasons. However, you can break into the *global namespace* from within *a file module* if you desire so. This is done using `declare global { /*global namespace here*/ }`. E.g. the previous example can also be done as:\n\n```ts\n// Ensure this is treated as a module.\nexport {};\n\ndeclare global {\n    interface String {\n        endsWith(suffix: string): boolean;\n    }\n}\n\nString.prototype.endsWith = function(suffix: string): boolean {\n    var str: string = this;\n    return str && str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\n\nconsole.log('foo bar'.endsWith('bas')); // false\nconsole.log('foo bas'.endsWith('bas')); // true\n```\n\n### Using your own custom lib.d.ts\nAs we mentioned earlier, using the `--noLib` boolean compiler flag causes TypeScript to exclude the automatic inclusion of `lib.d.ts`. There are various reasons why this is a useful feature. Here are a few of the common ones:"}
{"id": "docs\\types\\lib.d.ts.md#10", "content": "* You are running in a custom JavaScript environment that differs *significantly* from the standard browser based runtime environment.\n* You like to have *strict* control over the *globals* available in your code. E.g. lib.d.ts defines `item` as a global variable and you don't want this to leak into your code.\n\nOnce you have excluded the default `lib.d.ts` you can include a similarly named file into your compilation context and TypeScript will pick it up for type checking.\n\n> Note: be careful with `--noLib`. Once you are in noLib land, if you choose to share your project with others, they will be *forced* into noLib land (or rather *your lib* land). Even worse, if you bring *their* code into your project you might need to port it to *your lib* based code.\n\n### Compiler target effect on `lib.d.ts`"}
{"id": "docs\\types\\lib.d.ts.md#11", "content": "Setting the compiler target to `es6` causes the `lib.d.ts` to include *additional* ambient declarations for more modern (es6) stuff like `Promise`. This magical effect of the compiler target changing the *ambience* of the code is desirable for some people and for others it's problematic as it conflates *code generation* with *code ambience*.\n\nHowever, if you want finer grained control of your environment, you should use the `--lib` option which we discuss next.\n\n### lib option\n\nSometimes (many times) you want to decouple the relationship between the compile target (the generated JavaScript version) and the ambient library support. A common example is `Promise`, e.g. today (in June 2016) you most likely want to `--target es5` but still use the latest features like `Promise`. To support this you can take explicit control of `lib` using the `lib` compiler option.\n\n> Note: using `--lib` decouples any lib magic from `--target` giving you better control."}
{"id": "docs\\types\\lib.d.ts.md#12", "content": "You can provide this option on the command line or in `tsconfig.json` (recommended):\n\n**Command line**:\n```\ntsc --target es5 --lib dom,es6\n```\n**tsconfig.json**:\n```json\n\"compilerOptions\": {\n    \"lib\": [\"dom\", \"es6\"]\n}\n```\n\nThe libs can be categorized as follows:\n\n* JavaScript Bulk Feature:\n    * es5\n    * es6\n    * es2015\n    * es7\n    * es2016\n    * es2017\n    * esnext\n* Runtime Environment\n    * dom\n    * dom.iterable\n    * webworker\n    * scripthost\n* ESNext By-Feature Options (even smaller than bulk feature)\n    * es2015.core\n    * es2015.collection\n    * es2015.generator\n    * es2015.iterable\n    * es2015.promise\n    * es2015.proxy\n    * es2015.reflect\n    * es2015.symbol\n    * es2015.symbol.wellknown\n    * es2016.array.include\n    * es2017.object\n    * es2017.sharedmemory\n    * esnext.asynciterable"}
{"id": "docs\\types\\lib.d.ts.md#13", "content": "> NOTE: the `--lib` option provides extremely fine tuned control. So you most likely want to pick an item from the bulk + environment categories.\n> If --lib is not specified a default library is injected:\n  - For --target es5 => es5, dom, scripthost\n  - For --target es6 => es6, dom, dom.iterable, scripthost\n\nMy Personal Recommendation:\n\n```json\n\"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"es6\", \"dom\"]\n}\n```\n\nExample Including Symbol with ES5:\n\nSymbol API is not included when target is es5. In fact, we receive an error like: [ts] Cannot find name 'Symbol'.\nWe can use \"target\": \"es5\" in combination with \"lib\" to provide Symbol API in TypeScript:\n\n```json\n\"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"es5\", \"dom\", \"scripthost\", \"es2015.symbol\"]\n}\n```\n\n## Polyfill for old JavaScript engines\n\n> [Egghead PRO Video on this subject](https://egghead.io/lessons/typescript-using-es6-and-esnext-with-typescript)"}
{"id": "docs\\types\\lib.d.ts.md#14", "content": "There are quite a few runtime features that are like `Map` / `Set` and even `Promise` (this list will of course change over time) that you can use with modern `lib` options. To use these all you need to do is use `core-js`. Simply install:\n\n```\nnpm install core-js --save-dev\n```\nAnd add an import to your application entry point: \n\n```js\nimport \"core-js\";\n```\n\nAnd it should polyfill these runtime features for you \ud83c\udf39."}
{"id": "docs\\types\\literal-types.md#0", "content": "## Literals\nLiterals are *exact* values that are JavaScript primitives. \n\n### String Literals\n\nYou can use a string literal as a type. For example:\n\n```ts\nlet foo: 'Hello';\n```\n\nHere we have created a variable called `foo` that *will only allow the literal value `'Hello'` to be assigned to it*. This is demonstrated below:\n\n```ts\nlet foo: 'Hello';\nfoo = 'Bar'; // Error: \"Bar\" is not assignable to type \"Hello\"\n```\n\nThey are not very useful on their own but can be combined in a type union to create a powerful (and useful) abstraction e.g.:\n\n```ts\ntype CardinalDirection =\n    | \"North\"\n    | \"East\"\n    | \"South\"\n    | \"West\";\n\nfunction move(distance: number, direction: CardinalDirection) {\n    // ...\n}\n\nmove(1,\"North\"); // Okay\nmove(1,\"Nurth\"); // Error!\n```\n\n### Other literal types\nTypeScript also supports `boolean` and `number` literal types, e.g.: \n\n```ts\ntype OneToFive = 1 | 2 | 3 | 4 | 5;\ntype Bools = true | false;\n```"}
{"id": "docs\\types\\literal-types.md#1", "content": "### Inference \nQuite commonly you get an error like `Type string is not assignable to type \"foo\"`. The following example demonstrates this.\n\n```js\nfunction iTakeFoo(foo: 'foo') { }\nconst test = {\n  someProp: 'foo'\n};\niTakeFoo(test.someProp); // Error: Argument of type string is not assignable to parameter of type 'foo'\n```\n\nThis is because `test` is inferred to be of type `{someProp: string}`. The fix here is to use a simple type assertion to tell TypeScript the literal you want it to infer as shown below: \n\n```js\nfunction iTakeFoo(foo: 'foo') { }\nconst test = {\n  someProp: 'foo' as 'foo'\n};\niTakeFoo(test.someProp); // Okay!\n```\n\nor use a type annotation that helps TypeScript infer the correct thing at the point of declaration: \n\n```ts\nfunction iTakeFoo(foo: 'foo') { }\ntype Test = {\n  someProp: 'foo',\n}\nconst test: Test = { // Annotate - inferred someProp is always === 'foo'\n  someProp: 'foo' \n}; \niTakeFoo(test.someProp); // Okay!\n```"}
{"id": "docs\\types\\literal-types.md#2", "content": "### Use cases\nValid use cases for string literal types are:\n\n#### String based enums\n\n[TypeScript enums are number based](../enums.md). You can use string literals with union types to mock a string based enum as we did in the `CardinalDirection` example above. You can even generate a `Key:Value` structure using the following function: \n\n```ts\n/** Utility function to create a K:V from a list of strings */\nfunction strEnum<T extends string>(o: Array<T>): {[K in T]: K} {\n  return o.reduce((res, key) => {\n    res[key] = key;\n    return res;\n  }, Object.create(null));\n}\n```\n\nAnd then generate the literal type union using `keyof typeof`. Here is a complete example:\n\n```ts\n/** Utility function to create a K:V from a list of strings */\nfunction strEnum<T extends string>(o: Array<T>): {[K in T]: K} {\n  return o.reduce((res, key) => {\n    res[key] = key;\n    return res;\n  }, Object.create(null));\n}\n\n/**\n  * Sample create a string enum\n  */"}
{"id": "docs\\types\\literal-types.md#3", "content": "/** Create a K:V */\nconst Direction = strEnum([\n  'North',\n  'South',\n  'East',\n  'West'\n])\n/** Create a Type */\ntype Direction = keyof typeof Direction;\n\n/** \n  * Sample using a string enum\n  */\nlet sample: Direction;\n\nsample = Direction.North; // Okay\nsample = 'North'; // Okay\nsample = 'AnythingElse'; // ERROR!\n```\n\n#### Modelling existing JavaScript APIs\n\nE.g. [CodeMirror editor has an option `readOnly`](https://codemirror.net/doc/manual.html#option_readOnly) that can either be a `boolean` or the literal string `\"nocursor\"` (effective valid values `true,false,\"nocursor\"`).  It can be declared as:\n\n```ts\nreadOnly: boolean | 'nocursor';\n```\n\n#### Discriminated Unions\n\nWe will cover [this later in the book](./discriminated-unions.md).\n\n\n[](https://github.com/Microsoft/TypeScript/pull/5185)"}
{"id": "docs\\types\\migrating.md#0", "content": "## Migrating From JavaScript\n\nAssuming:\n* you know JavaScript.\n* you know patterns and build tools (e.g. webpack) used in the project. \n\nWith that assumption out of the way, in general the process consists of the following steps:\n\n* Add a `tsconfig.json`.\n* Change your source code file extensions from `.js` to `.ts`. Start *suppressing* errors using `any`.\n* Write new code in TypeScript and make as little use of `any` as possible.\n* Go back to the old code and start adding type annotations and fix identified bugs.\n* Use ambient definitions for third party JavaScript code.\n\nLet us discuss a few of these points further.\n\nNote that all JavaScript is *valid* TypeScript. That is to say that if you give the TypeScript compiler some JavaScript -> the JavaScript emitted by the TypeScript compiler will behave exactly the same as the original JavaScript. This means that changing the extension from `.js` to `.ts` will not adversely affect your codebase."}
{"id": "docs\\types\\migrating.md#1", "content": "### Suppressing Errors\nTypeScript will immediately start TypeChecking your code and your original JavaScript code *might not be as neat as you thought it was* and hence you get diagnostic errors. Many of these errors you can suppress with using `any` e.g.:\n\n```ts\nvar foo = 123;\nvar bar = 'hey';\n\nbar = foo; // ERROR: cannot assign a number to a string\n```\n\nEven though the **error is valid** (and in most cases the inferred information will be better than what the original authors of different portions of the code bases imagined), your focus will probably be writing new code in TypeScript while progressively updating the old code base. Here you can suppress this error with a type assertion as shown below:\n\n```ts\nvar foo = 123;\nvar bar = 'hey';\n\nbar = foo as any; // Okay!\n```\n\nIn other places you might want to annotate something as `any` e.g.:\n\n```ts\nfunction foo() {\n    return 1;\n}\nvar bar = 'hey';\nbar = foo(); // ERROR: cannot assign a number to a string\n```\n\nSuppressed:"}
{"id": "docs\\types\\migrating.md#2", "content": "```ts\nfunction foo(): any { // Added `any`\n    return 1;\n}\nvar bar = 'hey';\nbar = foo(); // Okay!\n```\n\n> Note: Suppressing errors is dangerous, but it allows you to take notice of errors in your *new* TypeScript code. You might want to leave `// TODO:` comments as you go along.**\n\n### Third Party JavaScript\nYou can change your JavaScript to TypeScript, but you can't change the whole world to use TypeScript. This is where TypeScript's ambient definition support comes in. In the beginning we recommend you create a `vendor.d.ts` (the `.d.ts` extension specifies the fact that this is a *declaration file*) and start adding dirty stuff to it. Alternatively create a file specific for the library e.g. `jquery.d.ts` for jquery."}
{"id": "docs\\types\\migrating.md#3", "content": "> Note: Well maintained and strongly typed definitions for nearly the top 90% JavaScript libraries out there exists in an OSS Repository called [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped). We recommend looking there before creating your own definitions as we present here. Nevertheless this quick and dirty way is vital knowledge to decrease your initial friction with TypeScript**.\n\nConsider the case of `jquery`, you can create a *trivial* definition for it quite easily:\n\n```ts\ndeclare var $: any;\n```\n\nSometimes you might want to add an explicit annotation on something (e.g. `JQuery`) and you need something in *type declaration space*. You can do that quite easily using the `type` keyword:\n\n```ts\ndeclare type JQuery = any;\ndeclare var $: JQuery;\n```\n\nThis provides you an easier future update path."}
{"id": "docs\\types\\migrating.md#4", "content": "Again, a high quality `jquery.d.ts` exists at [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped). But you now know how to overcome any JavaScript -> TypeScript friction *quickly* when using third party JavaScript. We will look at ambient declarations in detail next.\n\n\n# Third Party NPM modules\n\nSimilar to global variable declaration you can declare a global module quite easily. E.g. for `jquery` if you want to use it as a module (https://www.npmjs.com/package/jquery) you can write the following yourself: \n\n```ts\ndeclare module \"jquery\";\n```\n\nAnd then you can import it in your file as needed: \n\n```ts\nimport * as $ from \"jquery\";\n```\n\n> Again, a high quality `jquery.d.ts` exists at [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped) that provides a much higher quality jquery module declaration. But it might not exist for your library, so now you have a quick low friction way of continuing the migration \ud83c\udf39\n\n# External non js resources"}
{"id": "docs\\types\\migrating.md#5", "content": "You can even allow import of any file e.g. `.css` files (if you are using something like webpack style loaders or css modules) with a simple `*` style declaration (ideally in a [`global.d.ts` file](../project/globals.md)): \n\n```ts\ndeclare module \"*.css\";\n```\n\nNow people can `import * as foo from \"./some/file.css\";`\n\nSimilarly if you are using html templates (e.g. angular) you can: \n\n```ts\ndeclare module \"*.html\";\n```\n\n# More \nIf you want to be more silent about your upgrade because you couldn't get team buy in to move to TypeScript, [TypeScript has a blog post on upgrading silently without having to convince your team up front](https://devblogs.microsoft.com/typescript/how-to-upgrade-to-typescript-without-anybody-noticing-part-1/)."}
{"id": "docs\\types\\mixins.md#0", "content": "# Mixins\n\nTypeScript (and JavaScript) classes support strict single inheritance. So you *cannot* do:\n\n```ts\nclass User extends Tagged, Timestamped { // ERROR : no multiple inheritance\n}\n```\n\nAnother way of building up classes from reusable components is to build them by combining simpler partial classes called mixins.\n\nThe idea is simple, instead of a *class A extending class B* to get its functionality, *function B takes class A* and returns a new class with this added functionality. Function `B` is a mixin.  \n\n> [A mixin is] a function that\n>\n> 1. takes a constructor,\n> 1. creates a class that extends that constructor with new functionality\n> 1. returns the new class\n\nA complete example\n\n```ts\n// Needed for all mixins\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\n////////////////////\n// Example mixins\n////////////////////"}
{"id": "docs\\types\\mixins.md#1", "content": "// A mixin that adds a property\nfunction Timestamped<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    timestamp = Date.now();\n  };\n}\n\n// a mixin that adds a property and methods\nfunction Activatable<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    isActivated = false;\n\n    activate() {\n      this.isActivated = true;\n    }\n\n    deactivate() {\n      this.isActivated = false;\n    }\n  };\n}\n\n////////////////////\n// Usage to compose classes\n////////////////////\n\n// Simple class\nclass User {\n  name = '';\n}\n\n// User that is Timestamped\nconst TimestampedUser = Timestamped(User);\n\n// User that is Timestamped and Activatable\nconst TimestampedActivatableUser = Timestamped(Activatable(User));\n\n////////////////////\n// Using the composed classes\n////////////////////\n\nconst timestampedUserExample = new TimestampedUser();\nconsole.log(timestampedUserExample.timestamp);"}
{"id": "docs\\types\\mixins.md#2", "content": "const timestampedActivatableUserExample = new TimestampedActivatableUser();\nconsole.log(timestampedActivatableUserExample.timestamp);\nconsole.log(timestampedActivatableUserExample.isActivated);\n\n```\n\nLet's decompose this example.\n\n## Take a constructor\n\nMixins take a class and extend it with new functionality. So we need to define what is a *constructor*. Easy as:\n\n```ts\n// Needed for all mixins\ntype Constructor<T = {}> = new (...args: any[]) => T;\n```\n\n## Extend the class and return it\n\nPretty easy:\n\n```ts\n// A mixin that adds a property\nfunction Timestamped<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    timestamp = Date.now();\n  };\n}\n```\n\nAnd that is it \ud83c\udf39"}
{"id": "docs\\types\\moving-types.md#0", "content": "# Moving Types\n\nTypeScript's type system is extremely powerful and allows moving and slicing types in ways not possible in any other single language out there.\n\nThis is because TypeScript is designed to allow you to work seamlessly with a *highly dynamic* language like JavaScript. Here we cover a few tricks for moving types around in TypeScript.\n\nKey motivation for these : You change one thing and everything else just updates automatically and you get nice errors if something is going to break, like a well designed constraint system.\n\n## Copying both the Type + Value\n\nIf you want to move a class around, you might be tempted to do the following:\n\n```ts\nclass Foo { }\nvar Bar = Foo;\nvar bar: Bar; // ERROR: cannot find name 'Bar'\n```"}
{"id": "docs\\types\\moving-types.md#1", "content": "This is an error because `var` only copied the `Foo` into the *variable* declaration space and you therefore cannot use `Bar` as a type annotation. The proper way is to use the `import` keyword. Note that you can only use the `import` keyword in such a way if you are using *namespaces* or *modules* (more on these later):\n\n```ts\nnamespace importing {\n    export class Foo { }\n}\n\nimport Bar = importing.Foo;\nvar bar: Bar; // Okay\n```\n\nThis `import` trick only works for things that are *both type and variable*.\n\n## Capturing the type of a variable\n\nYou can actually use a variable in a type annotation using the `typeof` operator. This allows you to tell the compiler that one variable is the same type as another. Here is an example to demonstrate this:\n\n```ts\nvar foo = 123;\nvar bar: typeof foo; // `bar` has the same type as `foo` (here `number`)\nbar = 456; // Okay\nbar = '789'; // ERROR: Type `string` is not `assignable` to type `number`\n```\n\n## Capturing the type of a class member"}
{"id": "docs\\types\\moving-types.md#2", "content": "You can traverse into any non-nullable object type to retrieve the type of a property:\n\n```ts\nclass Foo {\n  foo: number; // some member whose type we want to capture\n}\n\nlet bar: Foo['foo']; // `bar` has type `number`\n```\n\nAlternatively, similar to capturing the type of a variable, you just declare a variable purely for type capturing purposes:\n\n```ts\n// Purely to capture type\ndeclare let _foo: Foo;\n\n// Same as before\nlet bar: typeof _foo.foo; // `bar` has type `number`\n```\n\n## Capturing the type of magic strings\n\nLots of JavaScript libraries and frameworks work off of raw JavaScript strings. You can use `const` variables to capture their type e.g.\n\n```ts\n// Capture both the *type* _and_ *value* of magic string:\nconst foo = \"Hello World\";\n\n// Use the captured type:\nlet bar: typeof foo;\n\n// bar can only ever be assigned to `Hello World`\nbar = \"Hello World\"; // Okay!\nbar = \"anything else \"; // Error!\n```"}
{"id": "docs\\types\\moving-types.md#3", "content": "In this example `bar` has the literal type `\"Hello World\"`. We cover this more in the [literal type section](./literal-types.md).\n\n## Capturing Key Names\n\nThe `keyof` operator lets you capture the key names of a type. E.g. you can use it to capture the key names of a variable by first grabbing its type using `typeof`:\n\n```ts\nconst colors = {\n  red: 'reddish',\n  blue: 'bluish'\n}\ntype Colors = keyof typeof colors;\n\nlet color: Colors; // same as let color: \"red\" | \"blue\"\ncolor = 'red'; // okay\ncolor = 'blue'; // okay\ncolor = 'anythingElse'; // Error: Type '\"anythingElse\"' is not assignable to type '\"red\" | \"blue\"'\n```\n\nThis allows you to have stuff like string enums + constants quite easily, as you just saw in the above example."}
{"id": "docs\\types\\never.md#0", "content": "# Never\n> [Professional Lesson on BooleanArt](https://www.booleanart.com/course/typescript/never)\n\n> [Youtube: Video lesson on the never type](https://www.youtube.com/watch?v=aldIFYWu6xc)\n\n> [Egghead: Video lesson on the never type](https://egghead.io/lessons/typescript-use-the-never-type-to-avoid-code-with-dead-ends-using-typescript)\n\nProgramming language design does have a concept of *bottom* type that is a **natural** outcome as soon as you do *code flow analysis*. TypeScript does *code flow analysis* (\ud83d\ude0e) and so it needs to reliably represent stuff that might never happen.\n\nThe `never` type is used in TypeScript to denote this *bottom* type. Cases when it occurs naturally:\n\n* A function never returns (e.g. if the function body has `while(true){}`)\n* A function always throws (e.g. in `function foo(){throw new Error('Not Implemented')}` the return type of `foo` is `never`)\n\nOf course you can use this annotation yourself as well\n\n```ts\nlet foo: never; // Okay\n```"}
{"id": "docs\\types\\never.md#1", "content": "However, *only `never` can be assigned to another never*. e.g.\n\n```ts\nlet foo: never = 123; // Error: Type number is not assignable to never\n\n// Okay as the function's return type is `never`\nlet bar: never = (() => { throw new Error(`Throw my hands in the air like I just don't care`) })();\n```\n\nGreat. Now let's just jump into its key use case :)\n\n# Use case: Exhaustive Checks\n\nYou can call never functions in a never context.\n\n```ts\nfunction foo(x: string | number): boolean {\n  if (typeof x === \"string\") {\n    return true;\n  } else if (typeof x === \"number\") {\n    return false;\n  }\n\n  // Without a never type we would error :\n  // - Not all code paths return a value (strict null checks)\n  // - Or Unreachable code detected\n  // But because TypeScript understands that `fail` function returns `never`\n  // It can allow you to call it as you might be using it for runtime safety / exhaustive checks.\n  return fail(\"Unexhaustive!\");\n}"}
{"id": "docs\\types\\never.md#2", "content": "function fail(message: string): never { throw new Error(message); }\n```\n\nAnd because `never` is only assignable to another `never` you can use it for *compile time* exhaustive checks as well. This is covered in the [*discriminated union* section](./discriminated-unions.md).\n\n# Confusion with `void`\n\nAs soon as someone tells you that `never` is returned when a function never exits gracefully you intuitively want to think of it as the same as `void`. However, `void` is a Unit. `never` is a falsum.\n\nA function that *returns* nothing returns a Unit `void`. However, a function *that never returns* (or always throws) returns `never`. `void` is something that can be assigned (without `strictNullChecking`) but `never` can *never* be assigned to anything other than `never`.\n\n# Type inference in never returning functions\n\nFor function declarations TypeScript infers `void` by default as shown below:"}
{"id": "docs\\types\\never.md#3", "content": "```ts\n// Inferred return type: void\nfunction failDeclaration(message: string) {\n  throw new Error(message);\n}\n\n// Inferred return type: never\nconst failExpression = function(message: string) {\n  throw new Error(message);\n};\n```\n\nOf course you can fix it by an explict annotation: \n\n```ts\nfunction failDeclaration(message: string): never {\n  throw new Error(message);\n}\n```\n\nKey reason is backword compatability with real world JavaScript code: \n\n```ts\nclass Base {\n    overrideMe() {\n        throw new Error(\"You forgot to override me!\");\n    }\n}\n\nclass Derived extends Base {\n    overrideMe() {\n        // Code that actually returns here\n    }\n}\n```\n\nIf `Base.overrideMe` . \n\n> Real world TypeScript can overcome this with `abstract` functions but this inferrence is maintained for compatability.\n\n<!--\nPR: https://github.com/Microsoft/TypeScript/pull/8652\nIssue : https://github.com/Microsoft/TypeScript/issues/3076\nConcept : https://en.wikipedia.org/wiki/Bottom_type\n-->"}
{"id": "docs\\types\\readonly.md#0", "content": "## readonly\nTypeScript's type system allows you to mark individual properties on an interface as `readonly`. This allows you to work in a functional way (unexpected mutation is bad):\n\n```ts\nfunction foo(config: {\n    readonly bar: number,\n    readonly bas: number\n}) {\n    // ..\n}\n\nlet config = { bar: 123, bas: 123 };\nfoo(config);\n// You can be sure that `config` isn't changed \ud83c\udf39\n```\n\nOf course you can use `readonly` in `interface` and `type` definitions as well e.g.:\n\n```ts\ntype Foo = {\n    readonly bar: number;\n    readonly bas: number;\n}\n\n// Initialization is okay\nlet foo: Foo = { bar: 123, bas: 456 };\n\n// Mutation is not\nfoo.bar = 456; // Error: Left-hand side of assignment expression cannot be a constant or a read-only property\n```\n\nYou can even declare a class property as `readonly`. You can initialize them at the point of declaration or in the constructor as shown below:"}
{"id": "docs\\types\\readonly.md#1", "content": "```ts\nclass Foo {\n    readonly bar = 1; // OK\n    readonly baz: string;\n    constructor() {\n        this.baz = \"hello\"; // OK\n    }\n}\n```\n\n## Readonly\nThere is a type `Readonly` that takes a type `T` and marks all of its properties as `readonly` using mapped types. Here is a demo that uses it in practice: \n\n```ts\ntype Foo = {\n  bar: number;\n  bas: number;\n}\n\ntype FooReadonly = Readonly<Foo>; \n\nlet foo: Foo = {bar: 123, bas: 456};\nlet fooReadonly: FooReadonly = {bar: 123, bas: 456};\n\nfoo.bar = 456; // Okay\nfooReadonly.bar = 456; // ERROR: bar is readonly\n```\n\n### Various Use Cases\n\n#### ReactJS\nOne library that loves immutability is ReactJS, you *could* mark your `Props` and `State` to be immutable e.g.:"}
{"id": "docs\\types\\readonly.md#2", "content": "```ts\ninterface Props {\n    readonly foo: number;\n}\ninterface State {\n    readonly bar: number;\n}\nexport class Something extends React.Component<Props,State> {\n  someMethod() {\n    // You can rest assured no one is going to do\n    this.props.foo = 123; // ERROR: (props are immutable)\n    this.state.baz = 456; // ERROR: (one should use this.setState)  \n  }\n}\n```\n\nYou do not need to, however, as the type definitions for React mark these as `readonly` already (by internally wrapping the passed in generic types with the `Readonly` type mentioned above).\n\n```ts\nexport class Something extends React.Component<{ foo: number }, { baz: number }> {\n  // You can rest assured no one is going to do\n  someMethod() {\n    this.props.foo = 123; // ERROR: (props are immutable)\n    this.state.baz = 456; // ERROR: (one should use this.setState)  \n  }\n}\n```\n\n#### Seamless Immutable\n\nYou can even mark index signatures as readonly:"}
{"id": "docs\\types\\readonly.md#3", "content": "```ts\n/**\n * Declaration\n */\ninterface Foo {\n    readonly[x: number]: number;\n}\n\n/**\n * Usage\n */\nlet foo: Foo = { 0: 123, 2: 345 };\nconsole.log(foo[0]);   // Okay (reading)\nfoo[0] = 456;          // Error (mutating): Readonly\n```\n\nThis is great if you want to use native JavaScript arrays in an *immutable* fashion. In fact TypeScript ships with a `ReadonlyArray<T>` interface to allow you to do just that:\n\n```ts\nlet foo: ReadonlyArray<number> = [1, 2, 3];\nconsole.log(foo[0]);   // Okay\nfoo.push(4);           // Error: `push` does not exist on ReadonlyArray as it mutates the array\nfoo = foo.concat([4]); // Okay: create a copy\n```\n\n#### Automatic Inference\nIn some cases the compiler can automatically infer a particular item to be readonly e.g. within a class if you have a property that only has a getter but no setter, it is assumed readonly e.g.:"}
{"id": "docs\\types\\readonly.md#4", "content": "```ts\nclass Person {\n    firstName: string = \"John\";\n    lastName: string = \"Doe\";\n    get fullName() {\n        return this.firstName + this.lastName;\n    }\n}\n\nconst person = new Person();\nconsole.log(person.fullName); // John Doe\nperson.fullName = \"Dear Reader\"; // Error! fullName is readonly\n```\n\n### Difference from `const`\n`const`\n\n1. is for a variable reference\n1. the variable cannot be reassigned to anything else.\n\n`readonly` is\n\n1. for a property\n1. the property can be modified because of aliasing\n\nSample explaining 1:\n\n```ts\nconst foo = 123; // variable reference\nvar bar: {\n    readonly bar: number; // for property\n}\n```\n\nSample explaining 2:\n\n```ts\nlet foo: {\n    readonly bar: number;\n} = {\n        bar: 123\n    };\n\nfunction iMutateFoo(foo: { bar: number }) {\n    foo.bar = 456;\n}\n\niMutateFoo(foo); // The foo argument is aliased by the foo parameter\nconsole.log(foo.bar); // 456!\n```"}
{"id": "docs\\types\\readonly.md#5", "content": "Basically `readonly` ensures that a property *cannot be modified by me*, but if you give it to someone that doesn't have that guarantee (allowed for type compatibility reasons) they can modify it. Of course if `iMutateFoo` said that they do not mutate `foo.bar` the compiler would correctly flag it as an error as shown:\n\n```ts\ninterface Foo {\n    readonly bar: number;\n}\nlet foo: Foo = {\n    bar: 123\n};\n\nfunction iTakeFoo(foo: Foo) {\n    foo.bar = 456; // Error! bar is readonly\n}\n\niTakeFoo(foo); // The foo argument is aliased by the foo parameter\n```\n\n[](https://github.com/Microsoft/TypeScript/pull/6532)"}
{"id": "docs\\types\\type-assertion.md#0", "content": "## Type Assertion\nTypeScript allows you to override its inferred and analyzed view of types in any way you want to. This is done by a mechanism called \"type assertion\". TypeScript's type assertion is purely you telling the compiler that you know about the types better than it does, and that it should not second guess you.\n\nA common use case for type assertion is when you are porting over code from JavaScript to TypeScript. For example consider the following pattern:\n\n```ts\nvar foo = {};\nfoo.bar = 123; // Error: property 'bar' does not exist on `{}`\nfoo.bas = 'hello'; // Error: property 'bas' does not exist on `{}`\n```\n\nHere the code errors because the *inferred* type of `foo` is `{}` i.e. an object with zero properties. Therefore you are not allowed to add `bar` or `bas` to it. You can fix this simply by a type assertion `as Foo`:\n\n```ts\ninterface Foo {\n    bar: number;\n    bas: string;\n}\nvar foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n```"}
{"id": "docs\\types\\type-assertion.md#1", "content": "### `as foo` vs. `<foo>`\nOriginally the syntax that was added was `<foo>`. This is demonstrated below:\n\n```ts\nvar foo: any;\nvar bar = <string> foo; // bar is now of type \"string\"\n```\n\nHowever, there is an ambiguity in the language grammar when using `<foo>` style assertions in JSX:\n\n```ts\nvar foo = <string>bar;\n</string>\n```\n\nTherefore it is now recommended that you just use `as foo` for consistency.\n\n### Type Assertion vs. Casting\nThe reason why it's not called \"type casting\" is that *casting* generally implies some sort of runtime support. However, *type assertions* are purely a compile time construct and a way for you to provide hints to the compiler on how you want your code to be analyzed."}
{"id": "docs\\types\\type-assertion.md#2", "content": "### Assertion considered harmful\nIn many cases assertion will allow you to easily migrate legacy code (and even copy paste other code samples into your codebase). However, you should be careful with your use of assertions. Take our original code as a sample, the compiler will not protect you from forgetting to *actually add the properties you promised*:\n\n```ts\ninterface Foo {\n    bar: number;\n    bas: string;\n}\nvar foo = {} as Foo;\n// ahhhh .... forget something?\n```\n\nAlso another common thought is using an assertion as a means of providing *autocomplete* e.g.:\n\n```ts\ninterface Foo {\n    bar: number;\n    bas: string;\n}\nvar foo = <Foo>{\n    // the compiler will provide autocomplete for properties of Foo\n    // But it is easy for the developer to forget adding all the properties\n    // Also this code is likely to break if Foo gets refactored (e.g. a new property added)\n};\n```"}
{"id": "docs\\types\\type-assertion.md#3", "content": "but the hazard here is the same, if you forget a property the compiler will not complain. It is better if you do the following:\n\n```ts\ninterface Foo {\n    bar: number;\n    bas: string;\n}\nvar foo: Foo = {\n    // the compiler will provide autocomplete for properties of Foo\n};\n```\n\nIn some cases you might need to create a temporary variable, but at least you will not be making (possibly false) promises and instead relying on the type inference to do the checking for you.\n\n### Double assertion\n\n> [Pro Video Lesson on Double Assertion](https://www.booleanart.com/course/typescript/double-assertion)\n\nThe type assertion, despite being a bit unsafe as we've shown, is not *completely open season*. E.g. the following is a very valid use case (e.g. the user thinks the event passed in will be a more specific case of an event) and the type assertion works as expected:\n\n```ts\nfunction handler (event: Event) {\n    let mouseEvent = event as MouseEvent;\n}\n```"}
{"id": "docs\\types\\type-assertion.md#4", "content": "However, the following is most likely an error and TypeScript will complain as shown despite the user's type assertion:\n\n```ts\nfunction handler(event: Event) {\n    let element = event as HTMLElement; // Error: Neither 'Event' nor type 'HTMLElement' is assignable to the other\n}\n```\n\nIf you *still want that Type, you can use a double assertion*, but first asserting to `unknown` (or `any`) which is compatible with all types and therefore the compiler no longer complains:\n\n```ts\nfunction handler(event: Event) {\n    let element = event as unknown as HTMLElement; // Okay!\n}\n```\n\n#### How TypeScript determines if a single assertion is not enough\nBasically, the assertion from type `S` to `T` succeeds if either `S` is a subtype of `T` or `T` is a subtype of `S`. This is to provide extra safety when doing type assertions ... completely wild assertions can be very unsafe and you need to use `unknown` (or `any`) to be that unsafe."}
{"id": "docs\\types\\type-assertion.md#5", "content": "#### `as any as` vs `as unknown as`\nBoth are *equally unsafe* as far as TypeScript is concerned. Use what makes you happy. Considerations: \n\n* Linters prefer `unknown` (with `no-explicit-any` rule)\n* `any` is less characters to type than `unknown`"}
{"id": "docs\\types\\type-compatibility.md#0", "content": "* [Type Compatibility](#type-compatibility)\n* [Soundness](#soundness)\n* [Structural](#structural)\n* [Generics](#generics)\n* [Variance](#variance)\n* [Functions](#functions)\n  * [Return Type](#return-type)\n  * [Number of arguments](#number-of-arguments)\n  * [Optional and rest parameters](#optional-and-rest-parameters)\n  * [Types of arguments](#types-of-arguments)\n* [Enums](#enums)\n* [Classes](#classes)\n* [Generics](#generics)\n* [FootNote: Invariance](#footnote-invariance)\n\n## Type Compatibility\n\nType Compatibility (as we discuss here) determines if one thing can be assigned to another. E.g. `string` and `number` are not compatible:\n\n```ts\nlet str: string = \"Hello\";\nlet num: number = 123;\n\nstr = num; // ERROR: `number` is not assignable to `string`\nnum = str; // ERROR: `string` is not assignable to `number`\n```\n\n## Soundness"}
{"id": "docs\\types\\type-compatibility.md#1", "content": "TypeScript's type system is designed to be convenient and allows for *unsound* behaviours e.g. anything can be assigned to `any` which means telling the compiler to allow you to do whatever you want:\n\n```ts\nlet foo: any = 123;\nfoo = \"Hello\";\n\n// Later\nfoo.toPrecision(3); // Allowed as you typed it as `any`\n```\n\n## Structural\n\nTypeScript objects are structurally typed. This means the *names* don't matter as long as the structures match\n\n```ts\ninterface Point {\n    x: number,\n    y: number\n}\n\nclass Point2D {\n    constructor(public x:number, public y:number){}\n}\n\nlet p: Point;\n// OK, because of structural typing\np = new Point2D(1,2);\n```\n\nThis allows you to create objects on the fly (like you do in vanilla JS) and still have safety whenever it can be inferred.\n\nAlso *more* data is considered fine:"}
{"id": "docs\\types\\type-compatibility.md#2", "content": "```ts\ninterface Point2D {\n    x: number;\n    y: number;\n}\ninterface Point3D {\n    x: number;\n    y: number;\n    z: number;\n}\nvar point2D: Point2D = { x: 0, y: 10 }\nvar point3D: Point3D = { x: 0, y: 10, z: 20 }\nfunction iTakePoint2D(point: Point2D) { /* do something */ }\n\niTakePoint2D(point2D); // exact match okay\niTakePoint2D(point3D); // extra information okay\niTakePoint2D({ x: 0 }); // Error: missing information `y`\n```\n\n## Variance\n\nVariance is an easy to understand and important concept for type compatibility analysis.\n\nFor simple types `Base` and `Child`, if `Child` is a child of `Base`, then instances of `Child` can be assigned to a variable of type `Base`.\n\n> This is polymorphism 101\n\nIn type compatibility of complex types composed of such `Base` and `Child` types depends on where the `Base` and `Child` in similar scenarios is driven by *variance*."}
{"id": "docs\\types\\type-compatibility.md#3", "content": "* Covariant : (co aka joint) only in *same direction*\n* Contravariant : (contra aka negative) only in *opposite direction*\n* Bivariant : (bi aka both) both co and contra.\n* Invariant : if the types aren't exactly the same then they are incompatible.\n\n> Note: For a completely sound type system in the presence of mutable data like JavaScript, `invariant` is the only valid option. But as mentioned *convenience* forces us to make unsound choices.\n\n## Functions\n\nThere are a few subtle things to consider when comparing two functions.\n\n### Return Type\n\n`covariant`: The return type must contain at least enough data.\n\n```ts\n/** Type Hierarchy */\ninterface Point2D { x: number; y: number; }\ninterface Point3D { x: number; y: number; z: number; }\n\n/** Two sample functions */\nlet iMakePoint2D = (): Point2D => ({ x: 0, y: 0 });\nlet iMakePoint3D = (): Point3D => ({ x: 0, y: 0, z: 0 });"}
{"id": "docs\\types\\type-compatibility.md#4", "content": "/** Assignment */\niMakePoint2D = iMakePoint3D; // Okay\niMakePoint3D = iMakePoint2D; // ERROR: Point2D is not assignable to Point3D\n```\n\n### Number of arguments\n\nFewer arguments are okay (i.e. functions can choose to ignore additional parameters). After all you are guaranteed to be called with at least enough arguments.\n\n```ts\nlet iTakeSomethingAndPassItAnErr\n    = (x: (err: Error, data: any) => void) => { /* do something */ };\n\niTakeSomethingAndPassItAnErr(() => null) // Okay\niTakeSomethingAndPassItAnErr((err) => null) // Okay\niTakeSomethingAndPassItAnErr((err, data) => null) // Okay\n\n// ERROR: Argument of type '(err: any, data: any, more: any) => null' is not assignable to parameter of type '(err: Error, data: any) => void'.\niTakeSomethingAndPassItAnErr((err, data, more) => null);\n```\n\n### Optional and Rest Parameters\n\nOptional (pre determined count) and Rest parameters (any count of arguments) are compatible, again for convenience."}
{"id": "docs\\types\\type-compatibility.md#5", "content": "```ts\nlet foo = (x:number, y: number) => { /* do something */ }\nlet bar = (x?:number, y?: number) => { /* do something */ }\nlet bas = (...args: number[]) => { /* do something */ }\n\nfoo = bar = bas;\nbas = bar = foo;\n```\n\n> Note: optional (in our example `bar`) and non optional (in our example `foo`) are only compatible if strictNullChecks is false.\n\n### Types of arguments\n\n`bivariant` : This is designed to support common event handling scenarios\n\n```ts\n/** Event Hierarchy */\ninterface Event { timestamp: number; }\ninterface MouseEvent extends Event { x: number; y: number }\ninterface KeyEvent extends Event { keyCode: number }\n\n/** Sample event listener */\nenum EventType { Mouse, Keyboard }\nfunction addEventListener(eventType: EventType, handler: (n: Event) => void) {\n    /* ... */\n}\n\n// Unsound, but useful and common. Works as function argument comparison is bivariant\naddEventListener(EventType.Mouse, (e: MouseEvent) => console.log(e.x + \",\" + e.y));"}
{"id": "docs\\types\\type-compatibility.md#6", "content": "// Undesirable alternatives in presence of soundness\naddEventListener(EventType.Mouse, (e: Event) => console.log((<MouseEvent>e).x + \",\" + (<MouseEvent>e).y));\naddEventListener(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(e.x + \",\" + e.y)));\n\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\naddEventListener(EventType.Mouse, (e: number) => console.log(e));\n```\n\nAlso makes `Array<Child>` assignable to `Array<Base>` (covariance) as the functions are compatible. Array covariance requires all `Array<Child>` functions to be assignable to `Array<Base>` e.g. `push(t:Child)` is assignable to `push(t:Base)` which is made possible by function argument bivariance.\n\n**This can be confusing for people coming from other languages** who would expect the following to error but will not in TypeScript:\n\n```ts\n/** Type Hierarchy */\ninterface Point2D { x: number; y: number; }\ninterface Point3D { x: number; y: number; z: number; }"}
{"id": "docs\\types\\type-compatibility.md#7", "content": "/** Two sample functions */\nlet iTakePoint2D = (point: Point2D) => { /* do something */ }\nlet iTakePoint3D = (point: Point3D) => { /* do something */ }\n\niTakePoint3D = iTakePoint2D; // Okay : Reasonable\niTakePoint2D = iTakePoint3D; // Okay : WHAT\n```\n\n## Enums\n\n* Enums are compatible with numbers, and numbers are compatible with enums.\n\n```ts\nenum Status { Ready, Waiting };\n\nlet status = Status.Ready;\nlet num = 0;\n\nstatus = num; // OKAY\nnum = status; // OKAY\n```\n\n* Enum values from different enum types are considered incompatible. This makes enums useable *nominally* (as opposed to structurally)\n\n```ts\nenum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet status = Status.Ready;\nlet color = Color.Red;\n\nstatus = color; // ERROR\n```\n\n## Classes\n\n* Only instance members and methods are compared. *constructors* and *statics* play no part.\n\n```ts\nclass Animal {\n    feet: number;\n    constructor(name: string, numFeet: number) { /** do something */ }\n}"}
{"id": "docs\\types\\type-compatibility.md#8", "content": "class Size {\n    feet: number;\n    constructor(meters: number) { /** do something */ }\n}\n\nlet a: Animal;\nlet s: Size;\n\na = s;  // OK\ns = a;  // OK\n```\n\n* `private` and `protected` members *must originate from the same class*. Such members essentially make the class *nominal*.\n\n```ts\n/** A class hierarchy */\nclass Animal { protected feet: number; }\nclass Cat extends Animal { }\n\nlet animal: Animal;\nlet cat: Cat;\n\nanimal = cat; // OKAY\ncat = animal; // OKAY\n\n/** Looks just like Animal */\nclass Size { protected feet: number; }\n\nlet size: Size;\n\nanimal = size; // ERROR\nsize = animal; // ERROR\n```\n\n## Generics\n\nSince TypeScript has a structural type system, type parameters only affect compatibility when used by a member. For example, in the  following `T` has no impact on compatibility:\n\n```ts\ninterface Empty<T> {\n}\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y;  // okay, y matches structure of x\n```"}
{"id": "docs\\types\\type-compatibility.md#9", "content": "However, if `T` is used, it will play a role in compatibility based on its *instantiation* as shown below:\n\n```ts\ninterface NotEmpty<T> {\n    data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\n\nx = y;  // error, x and y are not compatible\n```\n\nIn cases where generic arguments haven't been *instantiated* they are substituted by `any` before checking compatibility:\n\n```ts\nlet identity = function<T>(x: T): T {\n    // ...\n}\n\nlet reverse = function<U>(y: U): U {\n    // ...\n}\n\nidentity = reverse;  // Okay because (x: any)=>any matches (y: any)=>any\n```\n\nGenerics involving classes are matched by relevant class compatibility as mentioned before. e.g. \n\n```ts\nclass List<T> {\n  add(val: T) { }\n}\n\nclass Animal { name: string; }\nclass Cat extends Animal { meow() { } }\n\nconst animals = new List<Animal>();\nanimals.add(new Animal()); // Okay \nanimals.add(new Cat()); // Okay \n\nconst cats = new List<Cat>();\ncats.add(new Animal()); // Error \ncats.add(new Cat()); // Okay\n```"}
{"id": "docs\\types\\type-compatibility.md#10", "content": "## FootNote: Invariance\n\nWe said invariance is the only sound option. Here is an example where both `contra` and `co` variance are shown to be unsafe for arrays.\n\n```ts\n/** Hierarchy */\nclass Animal { constructor(public name: string){} }\nclass Cat extends Animal { meow() { } }\n\n/** An item of each */\nvar animal = new Animal(\"animal\");\nvar cat = new Cat(\"cat\");\n\n/**\n * Demo : polymorphism 101\n * Animal <= Cat\n */\nanimal = cat; // Okay\ncat = animal; // ERROR: cat extends animal\n\n/** Array of each to demonstrate variance */\nlet animalArr: Animal[] = [animal];\nlet catArr: Cat[] = [cat];\n\n/**\n * Obviously Bad : Contravariance\n * Animal <= Cat\n * Animal[] >= Cat[]\n */\ncatArr = animalArr; // Okay if contravariant\ncatArr[0].meow(); // Allowed but BANG \ud83d\udd2b at runtime"}
{"id": "docs\\types\\type-compatibility.md#11", "content": "/**\n * Also Bad : covariance\n * Animal <= Cat\n * Animal[] <= Cat[]\n */\nanimalArr = catArr; // Okay if covariant\nanimalArr.push(new Animal('another animal')); // Just pushed an animal into catArr!\ncatArr.forEach(c => c.meow()); // Allowed but BANG \ud83d\udd2b at runtime\n```"}
{"id": "docs\\types\\type-inference.md#0", "content": "# Type Inference in TypeScript\n\nTypeScript can infer (and then check) the type of a variable based on a few simple rules. Because these rules\nare simple you can train your brain to recognize safe / unsafe code (it happened for me and my teammates quite quickly).\n\n> The types flowing is just how I imagine in my brain the flow of type information.\n\n## Variable Definition\n\nTypes of a variable are inferred by definition.\n\n```ts\nlet foo = 123; // foo is a `number`\nlet bar = \"Hello\"; // bar is a `string`\nfoo = bar; // Error: cannot assign `string` to a `number`\n```\n\nThis is an example of types flowing from right to left.\n\n## Function Return Types\n\nThe return type is inferred by the return statements e.g. the following function is inferred to return a `number`.\n\n```ts\nfunction add(a: number, b: number) {\n    return a + b;\n}\n```\n\nThis is an example of types flowing bottom out.\n\n## Assignment"}
{"id": "docs\\types\\type-inference.md#1", "content": "The type of function parameters / return values can also be inferred by assignment e.g. here we say that `foo` is an `Adder`, that makes `number` the type of `a` and `b`.\n\n```ts\ntype Adder = (a: number, b: number) => number;\nlet foo: Adder = (a, b) => a + b;\n```\n\nThis fact can be demonstrated by the below code which raises an error as you would hope:\n\n```ts\ntype Adder = (a: number, b: number) => number;\nlet foo: Adder = (a, b) => {\n    a = \"hello\"; // Error: cannot assign `string` to a `number`\n    return a + b;\n}\n```\n\nThis is an example of types flowing from left to right.\n\nThe same *assignment* style type inference works if you create a function for a callback argument. After all an `argument -> parameter`is just another form of variable assignment."}
{"id": "docs\\types\\type-inference.md#2", "content": "```ts\ntype Adder = (a: number, b: number) => number;\nfunction iTakeAnAdder(adder: Adder) {\n    return adder(1, 2);\n}\niTakeAnAdder((a, b) => {\n    // a = \"hello\"; // Would Error: cannot assign `string` to a `number`\n    return a + b;\n})\n```\n\n## Structuring\n\nThese simple rules also work in the presence of **structuring** (object literal creation). For example in the following case the type of `foo` is inferred to be `{a:number, b:number}`\n\n```ts\nlet foo = {\n    a: 123,\n    b: 456\n};\n// foo.a = \"hello\"; // Would Error: cannot assign `string` to a `number`\n```\n\nSimilarly for arrays:\n\n```ts\nconst bar = [1,2,3];\n// bar[0] = \"hello\"; // Would error: cannot assign `string` to a `number`\n```\n\nAnd of course any nesting:\n\n```ts\nlet foo = {\n    bar: [1, 3, 4]\n};\n// foo.bar[0] = 'hello'; // Would error: cannot assign `string` to a `number`\n```\n\n## Destructuring\n\nAnd of course, they also work with destructuring, both objects:"}
{"id": "docs\\types\\type-inference.md#3", "content": "```ts\nlet foo = {\n    a: 123,\n    b: 456\n};\nlet {a} = foo;\n// a = \"hello\"; // Would Error: cannot assign `string` to a `number`\n```\n\nand arrays:\n\n```ts\nconst bar = [1, 2];\nlet [a, b] = bar;\n// a = \"hello\"; // Would Error: cannot assign `string` to a `number`\n```\n\nAnd if the function parameter can be inferred, so can its destructured properties. For example here we destructure the argument into its `a`/`b` members.\n\n```ts\ntype Adder = (numbers: { a: number, b: number }) => number;\nfunction iTakeAnAdder(adder: Adder) {\n    return adder({ a: 1, b: 2 });\n}\niTakeAnAdder(({a, b}) => { // Types of `a` and `b` are inferred\n    // a = \"hello\"; // Would Error: cannot assign `string` to a `number`\n    return a + b;\n})\n```\n\n## Type Guards\n\nWe have already seen how [Type Guards](./typeGuard.md) help change and narrow down types (particularly in the case of unions). Type guards are just another form of type inference for a variable in a block.\n\n## Warnings\n\n### Be careful around parameters"}
{"id": "docs\\types\\type-inference.md#4", "content": "Types do not flow into the function parameters if it cannot be inferred from an assignment. For example in the following case the compiler does not know the type of `foo` so it cannot infer the type of `a` or `b`.\n\n```ts\nconst foo = (a,b) => { /* do something */ };\n```\n\nHowever, if `foo` was typed the function parameters type can be inferred (`a`,`b` are both inferred to be of type `number` in the example below).\n\n```ts\ntype TwoNumberFunction = (a: number, b: number) => void;\nconst foo: TwoNumberFunction = (a, b) => { /* do something */ };\n```\n\n### Be careful around return\n\nAlthough TypeScript can generally infer the return type of a function, it might not be what you expect. For example here function `foo` has a return type of `any`.\n\n```ts\nfunction foo(a: number, b: number) {\n    return a + addOne(b);\n}\n// Some external function in a library someone wrote in JavaScript\nfunction addOne(c) {\n    return c + 1;\n}\n```"}
{"id": "docs\\types\\type-inference.md#5", "content": "This is because the return type is impacted by the poor type definition for `addOne` (`c` is `any` so the return of `addOne` is `any` so the return of `foo` is `any`).\n\n> I find it simplest to always be explicit about function returns. After all, these annotations are a theorem and the function body is the proof.\n\nThere are other cases that one can imagine, but the good news is that there is a compiler flag that can help catch such bugs.\n\n## `noImplicitAny`\n\nThe flag `noImplicitAny` instructs the compiler to raise an error if it cannot infer the type of a variable (and therefore can only have it as an *implicit* `any` type). You can then\n\n* either say that *yes I want it to be of type `any`* by *explicitly* adding an `: any` type annotation\n* help the compiler out by adding a few more *correct* annotations."}
{"id": "docs\\types\\type-system.md#0", "content": "# TypeScript Type System\nWe covered the main features of the TypeScript Type System back when we discussed [Why TypeScript?](../why-typescript.md). The following are a few key takeaways from that discussion which don't need further explanation:\n* The type system in TypeScript is designed to be *optional* so that *your JavaScript is TypeScript*.\n* TypeScript does not block *JavaScript emit* in the presence of Type Errors, allowing you to *progressively update your JS to TS*.\n\nNow let's start with the *syntax* of the TypeScript type system. This way you can start using these annotations in your code immediately and see the benefit. This will prepare you for a deeper dive later.\n\n## Basic Annotations\nAs mentioned before Types are annotated using `:TypeAnnotation` syntax. Anything that is available in the type declaration space can be used as a Type Annotation.\n\nThe following example demonstrates type annotations for variables, function parameters and function return values:"}
{"id": "docs\\types\\type-system.md#1", "content": "```ts\nvar num: number = 123;\nfunction identity(num: number): number {\n    return num;\n}\n```\n\n### Primitive Types\nThe JavaScript primitive types are well represented in the TypeScript type system. This means `string`, `number`, `boolean` as demonstrated below:\n\n```ts\nvar num: number;\nvar str: string;\nvar bool: boolean;\n\nnum = 123;\nnum = 123.456;\nnum = '123'; // Error\n\nstr = '123';\nstr = 123; // Error\n\nbool = true;\nbool = false;\nbool = 'false'; // Error\n```\n\n### Arrays\nTypeScript provides dedicated type syntax for arrays to make it easier for you to annotate and document your code. The syntax is basically postfixing `[]` to any valid type annotation (e.g. `:boolean[]`). It allows you to safely do any array manipulation that you would normally do and protects you from errors like assigning a member of the wrong type.  This is demonstrated below:\n\n```ts\nvar boolArray: boolean[];"}
{"id": "docs\\types\\type-system.md#2", "content": "boolArray = [true, false];\nconsole.log(boolArray[0]); // true\nconsole.log(boolArray.length); // 2\nboolArray[1] = true;\nboolArray = [false, false];\n\nboolArray[0] = 'false'; // Error!\nboolArray = 'false'; // Error!\nboolArray = [true, 'false']; // Error!\n```\n\n### Interfaces\nInterfaces are the core way in TypeScript to compose multiple type annotations into a single named annotation. Consider the following example:\n\n```ts\ninterface Name {\n    first: string;\n    second: string;\n}\n\nvar name: Name;\nname = {\n    first: 'John',\n    second: 'Doe'\n};\n\nname = {           // Error : `second` is missing\n    first: 'John'\n};\nname = {           // Error : `second` is the wrong type\n    first: 'John',\n    second: 1337\n};\n```\n\nHere we've composed the annotations `first: string` + `second: string` into a new annotation `Name` that enforces the type checks on individual members. Interfaces have a lot of power in TypeScript and we will dedicate an entire section to how you can use that to your advantage."}
{"id": "docs\\types\\type-system.md#3", "content": "### Inline Type Annotation\nInstead of creating a new `interface` you can annotate anything you want *inline* using `:{ /*Structure*/ }`. The previous example presented again with an inline type:\n\n```ts\nvar name: {\n    first: string;\n    second: string;\n};\nname = {\n    first: 'John',\n    second: 'Doe'\n};\n\nname = {           // Error : `second` is missing\n    first: 'John'\n};\nname = {           // Error : `second` is the wrong type\n    first: 'John',\n    second: 1337\n};\n```\n\nInline types are great for quickly providing a one off type annotation for something. It saves you the hassle of coming up with (a potentially bad) type name. However, if you find yourself putting in the same type annotation inline multiple times it's a good idea to consider refactoring it into an interface (or a `type alias` covered later in this section)."}
{"id": "docs\\types\\type-system.md#4", "content": "## Special Types\nBeyond the primitive types that have been covered there are a few types that have special meaning in TypeScript. These are `any`, `null`, `undefined`, `void`.\n\n### any\nThe `any` type holds a special place in the TypeScript type system. It gives you an escape hatch from the type system to tell the compiler to bugger off. `any` is compatible with *any and all* types in the type system. This means that *anything can be assigned to it* and *it can be assigned to anything*. This is demonstrated in the example below:\n\n```ts\nvar power: any;\n\n// Takes any and all types\npower = '123';\npower = 123;\n\n// Is compatible with all types\nvar num: number;\npower = num;\nnum = power;\n```"}
{"id": "docs\\types\\type-system.md#5", "content": "If you are porting JavaScript code to TypeScript, you are going to be close friends with `any` in the beginning. However, don't take this friendship too seriously as it means that *it is up to you to ensure the type safety*. You are basically telling the compiler to *not do any meaningful static analysis*.\n\n### `null` and `undefined`\n\nHow they are treated by the type system depends on the `strictNullChecks` compiler flag (we cover this flag later). When in `strictNullCheck:false`, the `null` and `undefined` JavaScript literals are effectively treated by the type system the same as something of type `any`. These literals can be assigned to any other type. This is demonstrated in the below example:\n\n```ts\nvar num: number;\nvar str: string;\n\n// These literals can be assigned to anything\nnum = null;\nstr = undefined;\n```\n\n### `:void`\nUse `:void` to signify that a function does not have a return type:\n\n```ts\nfunction log(message): void {\n    console.log(message);\n}\n```"}
{"id": "docs\\types\\type-system.md#6", "content": "## Generics\nMany algorithms and data structures in computer science do not depend on the *actual type* of the object. However, you still want to enforce a constraint between various variables. A simple toy example is a function that takes a list of items and returns a reversed list of items. The constraint here is between what is passed in to the function and what is returned by the function:\n\n```ts\nfunction reverse<T>(items: T[]): T[] {\n    var toreturn = [];\n    for (let i = items.length - 1; i >= 0; i--) {\n        toreturn.push(items[i]);\n    }\n    return toreturn;\n}\n\nvar sample = [1, 2, 3];\nvar reversed = reverse(sample);\nconsole.log(reversed); // 3,2,1\n\n// Safety!\nreversed[0] = '1';     // Error!\nreversed = ['1', '2']; // Error!\n\nreversed[0] = 1;       // Okay\nreversed = [1, 2];     // Okay\n```"}
{"id": "docs\\types\\type-system.md#7", "content": "Here you are basically saying that the function `reverse` takes an array (`items: T[]`) of *some* type `T` (notice the type parameter in `reverse<T>`) and returns an array of type `T` (notice `: T[]`). Because the `reverse` function returns items of the same type as it takes, TypeScript knows the `reversed` variable is also of type `number[]` and will give you Type safety. Similarly if you pass in an array of `string[]` to the reverse function the returned result is also an array of `string[]` and you get similar type safety as shown below:\n\n```ts\nvar strArr = ['1', '2'];\nvar reversedStrs = reverse(strArr);\n\nreversedStrs = [1, 2]; // Error!\n```\n\nIn fact JavaScript arrays already have a `.reverse` function and TypeScript does indeed use generics to define its structure:\n\n```ts\ninterface Array<T> {\n reverse(): T[];\n // ...\n}\n```\n\nThis means that you get type safety when calling `.reverse` on any array as shown below:\n\n```ts\nvar numArr = [1, 2];\nvar reversedNums = numArr.reverse();"}
{"id": "docs\\types\\type-system.md#8", "content": "reversedNums = ['1', '2']; // Error!\n```\n\nWe will discuss more about the `Array<T>` interface later when we present `lib.d.ts` in the section **Ambient Declarations**.\n\n## Union Type\nQuite commonly in JavaScript you want to allow a property to be one of multiple types e.g. *a `string` or a `number`*. This is where the *union type* (denoted by `|` in a type annotation e.g. `string|number`) comes in handy. A common use case is a function that can take a single object or an array of the object e.g.:\n\n```ts\nfunction formatCommandline(command: string[]|string) {\n    var line = '';\n    if (typeof command === 'string') {\n        line = command.trim();\n    } else {\n        line = command.join(' ').trim();\n    }\n\n    // Do stuff with line: string\n}\n```"}
{"id": "docs\\types\\type-system.md#9", "content": "## Intersection Type\n`extend` is a very common pattern in JavaScript where you take two objects and create a new one that has the features of both these objects. An **Intersection Type** allows you to use this pattern in a safe way as demonstrated below:\n\n```ts\nfunction extend<T, U>(first: T, second: U): T & U {\n  return { ...first, ...second };\n}\n\nconst x = extend({ a: \"hello\" }, { b: 42 });\n\n// x now has both `a` and `b`\nconst a = x.a;\nconst b = x.b;\n```\n\n## Tuple Type\nJavaScript doesn't have first class tuple support. People generally just use an array as a tuple. This is exactly what the TypeScript type system supports. Tuples can be annotated using `: [typeofmember1, typeofmember2]` etc. A tuple can have any number of members. Tuples are demonstrated in the below example:\n\n```ts\nvar nameNumber: [string, number];\n\n// Okay\nnameNumber = ['Jenny', 8675309];\n\n// Error!\nnameNumber = ['Jenny', '867-5309'];\n```"}
{"id": "docs\\types\\type-system.md#10", "content": "Combine this with the destructuring support in TypeScript, tuples feel fairly first class despite being arrays underneath:\n\n```ts\nvar nameNumber: [string, number];\nnameNumber = ['Jenny', 8675309];\n\nvar [name, num] = nameNumber;\n```\n\n## Type Alias\nTypeScript provides convenient syntax for providing names for type annotations that you would like to use in more than one place. The aliases are created using the `type SomeName = someValidTypeAnnotation` syntax. An example is demonstrated below:\n\n```ts\ntype StrOrNum = string|number;\n\n// Usage: just like any other notation\nvar sample: StrOrNum;\nsample = 123;\nsample = '123';\n\n// Just checking\nsample = true; // Error!\n```\n\nUnlike an `interface` you can give a type alias to literally any type annotation (useful for stuff like union and intersection types). Here are a few more examples to make you familiar with the syntax:"}
{"id": "docs\\types\\type-system.md#11", "content": "```ts\ntype Text = string | { text: string };\ntype Coordinates = [number, number];\ntype Callback = (data: string) => void;\n```\n\n> TIP: If you need to have hierarchies of Type annotations use an `interface`. They can be used with `implements` and `extends`\n\n> TIP: Use a type alias for simpler object structures (like `Coordinates`) just to give them a semantic name. Also when you want to give semantic names to Union or Intersection types, a Type alias is the way to go.\n\n## Summary\nNow that you can start annotating most of your JavaScript code we can jump into the nitty gritty details of all the power available in TypeScript's Type System."}
{"id": "docs\\types\\typeGuard.md#0", "content": "* [Type Guard](#type-guard)\n* [User Defined Type Guards](#user-defined-type-guards)\n\n## Type Guard\nType Guards allow you to narrow down the type of an object within a conditional block. \n\n\n### typeof\n\nTypeScript is aware of the usage of the JavaScript `instanceof` and `typeof` operators. If you use these in a conditional block, TypeScript will understand the type of the variable to be different within that conditional block. Here is a quick example where TypeScript realizes that a particular function does not exist on `string` and points out what was probably a user typo:\n\n```ts\nfunction doSomething(x: number | string) {\n    if (typeof x === 'string') { // Within the block TypeScript knows that `x` must be a string\n        console.log(x.subtr(1)); // Error, 'subtr' does not exist on `string`\n        console.log(x.substr(1)); // OK\n    }\n    x.substr(1); // Error: There is no guarantee that `x` is a `string`\n}\n```\n\n### instanceof\n\nHere is an example with a class and `instanceof`:"}
{"id": "docs\\types\\typeGuard.md#1", "content": "```ts\nclass Foo {\n    foo = 123;\n    common = '123';\n}\n\nclass Bar {\n    bar = 123;\n    common = '123';\n}\n\nfunction doStuff(arg: Foo | Bar) {\n    if (arg instanceof Foo) {\n        console.log(arg.foo); // OK\n        console.log(arg.bar); // Error!\n    }\n    if (arg instanceof Bar) {\n        console.log(arg.foo); // Error!\n        console.log(arg.bar); // OK\n    }\n\n    console.log(arg.common); // OK\n    console.log(arg.foo); // Error!\n    console.log(arg.bar); // Error!\n}\n\ndoStuff(new Foo());\ndoStuff(new Bar());\n```\n\nTypeScript even understands `else` so when an `if` narrows out one type it knows that within the else *it's definitely not that type*. Here is an example:\n\n```ts\nclass Foo {\n    foo = 123;\n}\n\nclass Bar {\n    bar = 123;\n}"}
{"id": "docs\\types\\typeGuard.md#2", "content": "function doStuff(arg: Foo | Bar) {\n    if (arg instanceof Foo) {\n        console.log(arg.foo); // OK\n        console.log(arg.bar); // Error!\n    }\n    else {  // MUST BE Bar!\n        console.log(arg.foo); // Error!\n        console.log(arg.bar); // OK\n    }\n}\n\ndoStuff(new Foo());\ndoStuff(new Bar());\n```\n\n### in \n\nThe `in` operator does a safe check for the existence of a property on an object and can be used as a type guard. E.g. \n\n```ts\ninterface A {\n  x: number;\n}\ninterface B {\n  y: string;\n}\n\nfunction doStuff(q: A | B) {\n  if ('x' in q) {\n    // q: A\n  }\n  else {\n    // q: B\n  }\n}\n```\n\n### Literal Type Guard\n\nYou can use `===` / `==` / `!==` / `!=` to distinguish between literal values\n\n```ts\ntype TriState = 'yes' | 'no' | 'unknown';\n\nfunction logOutState(state:TriState) {\n  if (state == 'yes') {\n    console.log('User selected yes');\n  } else if (state == 'no') {\n    console.log('User selected no');\n  } else {\n    console.log('User has not made a selection yet');\n  }\n}\n```"}
{"id": "docs\\types\\typeGuard.md#3", "content": "This even works when you have literal types in a union. You can check the value of a shared property name to discriminate the union e.g. \n\n```ts\ntype Foo = {\n  kind: 'foo', // Literal type \n  foo: number\n}\ntype Bar = {\n  kind: 'bar', // Literal type \n  bar: number\n}\n\nfunction doStuff(arg: Foo | Bar) {\n    if (arg.kind === 'foo') {\n        console.log(arg.foo); // OK\n        console.log(arg.bar); // Error!\n    }\n    else {  // MUST BE Bar!\n        console.log(arg.foo); // Error!\n        console.log(arg.bar); // OK\n    }\n}\n```\n\n### null and undefined with `strictNullChecks`\n\nTypeScript is smart enough to rule out both `null` and `undefined` with a `== null` / `!= null` check. For example:\n\n```ts\nfunction foo(a?: number | null) {\n  if (a == null) return;\n\n  // a is number now.\n}\n```"}
{"id": "docs\\types\\typeGuard.md#4", "content": "### User Defined Type Guards\nJavaScript doesn't have very rich runtime introspection support built in. When you are using just plain JavaScript Objects (using structural typing to your advantage), you do not even have access to `instanceof` or `typeof`. For these cases you can create *User Defined Type Guard functions*. These are just functions that return `someArgumentName is SomeType`. Here is an example:\n\n```ts\n/**\n * Just some interfaces\n */\ninterface Foo {\n    foo: number;\n    common: string;\n}\n\ninterface Bar {\n    bar: number;\n    common: string;\n}\n\n/**\n * User Defined Type Guard!\n */\nfunction isFoo(arg: any): arg is Foo {\n    return arg.foo !== undefined;\n}\n\n/**\n * Sample usage of the User Defined Type Guard\n */\nfunction doStuff(arg: Foo | Bar) {\n    if (isFoo(arg)) {\n        console.log(arg.foo); // OK\n        console.log(arg.bar); // Error!\n    }\n    else {\n        console.log(arg.foo); // Error!\n        console.log(arg.bar); // OK\n    }\n}"}
{"id": "docs\\types\\typeGuard.md#5", "content": "doStuff({ foo: 123, common: '123' });\ndoStuff({ bar: 123, common: '123' });\n```\n\n### Type Guards and callbacks\n\nTypeScript doesn't assume type guards remain active in callbacks as making this assumption is dangerous. e.g. \n\n```js\n// Example Setup\ndeclare var foo:{bar?: {baz: string}};\nfunction immediate(callback: ()=>void) {\n  callback();\n}\n\n\n// Type Guard\nif (foo.bar) {\n  console.log(foo.bar.baz); // Okay\n  functionDoingSomeStuff(() => {\n    console.log(foo.bar.baz); // TS error: Object is possibly 'undefined'\"\n  });\n}\n```\n\nThe fix is as easy as storing the inferred safe value in a local variable, automatically ensuring it doesn't get changed externally, and TypeScript can easily understand that: \n\n```js\n// Type Guard\nif (foo.bar) {\n  console.log(foo.bar.baz); // Okay\n  const bar = foo.bar;\n  functionDoingSomeStuff(() => {\n    console.log(bar.baz); // Okay\n  });\n}\n```"}
{"id": "docs\\types\\ambient\\d.ts.md#0", "content": "### Declaration file\nYou can tell TypeScript that you are trying to describe code that exists elsewhere (e.g. written in JavaScript/CoffeeScript/The runtime environment like the browser or Node.js) using the `declare` keyword. As a quick example:\n\n```ts\nfoo = 123; // Error: `foo` is not defined\n```\nvs.\n```ts\ndeclare var foo: any;\nfoo = 123; // allowed\n```\n\nYou have the option of putting these declarations in a `.ts` file or in a `.d.ts` file. We highly recommend that in your real world projects you use a separate `.d.ts` (start with one called something like `global.d.ts` or `vendor.d.ts`).\n\nIf a file has the extension `.d.ts` then each root level definition must have the `declare` keyword prefixed to it. This helps make it clear to the author that there will be *no code emitted by TypeScript*. The author needs to ensure that the declared item will exist at runtime."}
{"id": "docs\\types\\ambient\\d.ts.md#1", "content": "> * Ambient declarations is a promise that you are making with the compiler. If these do not exist at runtime and you try to use them, things will break without warning.\n* Ambient declarations are like docs. If the source changes the docs need to be kept updated. So you might have new behaviours that work at runtime but no one's updated the ambient declaration and hence you get compiler errors."}
{"id": "docs\\types\\ambient\\intro.md#0", "content": "## Ambient Declarations\n\nAs we mentioned in [why TypeScript](../../why-typescript.md):\n\n> A major design goal of TypeScript was to make it possible for you to safely and easily use existing JavaScript libraries in TypeScript. TypeScript does this by means of *declaration*.\n\nAmbient declarations allow you to *safely use existing popular JavaScript libraries* and *incrementally migrate your JavaScript/CoffeeScript/Other-Compile-To-Js-Language project to TypeScript*.\n\nStudying patterns in ambient declarations for *third party JavaScript code* is good practice for annotating *your* TypeScript code base as well. This is why we present it so early on."}
{"id": "docs\\types\\ambient\\variables.md#0", "content": "### Variables\nFor example to tell TypeScript about the [`process` variable](https://nodejs.org/api/process.html) you *can* do:\n\n```ts\ndeclare var process: any;\n```\n\n> You don't *need* to do this for `process` as there is already a [community maintained `node.d.ts`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/index.d.ts).\n\nThis allows you to use the `process` variable without TypeScript complaining:\n\n```ts\nprocess.exit();\n```\n\nWe recommend using an interface wherever possible e.g.:\n\n```ts\ninterface Process {\n    exit(code?: number): void;\n}\ndeclare var process: Process;\n```\n\nThis allows other people to *extend* the nature of these global variables while still telling TypeScript about such modifications. E.g. consider the following case where we add an `exitWithLogging` function to process for our amusement:"}
{"id": "docs\\types\\ambient\\variables.md#1", "content": "```ts\ninterface Process {\n    exitWithLogging(code?: number): void;\n}\nprocess.exitWithLogging = function() {\n    console.log(\"exiting\");\n    process.exit.apply(process, arguments);\n};\n```\n\nLet's look at interfaces in a bit more detail next."}
